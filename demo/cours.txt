<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Les exceptions</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
 <dd id="smenu1">
    <ul>
	 <li><a onclick="javascript=cacher_menu()" href="excep.html#erreur">Que faire en cas d'erreur ?</a></li> 
     <li><a onclick="javascript=cacher_menu()" href="excep.html#poste">Une analogie avec la vie courante</a></li> 
     <li><a onclick="javascript=cacher_menu()" href="excep.html#excep">Le syst&egrave;me d'exceptions</a> 
     <ul>
       <li><a onclick="javascript=cacher_menu()" href="excep.html#hier">Les hi&eacute;rarchies d'objets exceptions</a></li> 
       <li><a onclick="javascript=cacher_menu()" href="excep.html#decl">La d&eacute;claration de fonction</a></li> 
       <li><a onclick="javascript=cacher_menu()" href="excep.html#gene">La g&eacute;n&eacute;ration d'exception</a></li> 
       <li><a onclick="javascript=cacher_menu()" href="excep.html#capt">La capture des exceptions</a></li> 
       <li><a onclick="javascript=cacher_menu()" href="excep.html#noncapt">Exceptions non captur&eacute;es</a></li> 
	 </ul></li>
     <li><a onclick="javascript=cacher_menu()" href="excep.html#excepet">Exceptions et ...</a> 
     <ul>
	   <li><a onclick="javascript=cacher_menu()" href="excep.html#const">...constructeurs</a></li>			
	   <li><a onclick="javascript=cacher_menu()" href="excep.html#dest">...destructeurs</a></li>
	 </ul></li>
	</ul>
 </dd>
</dl>
<dl>
 <dt><a href="exos.html#exceptions" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1><a name="surch-fonc-op">Exceptions</a></h1>


<h2><a name="erreur">Que faire en cas d'erreur ?</a></h2>

<p>Que  le  programme doit-il faire  lorsqu'il d&eacute;couvre une  condition d'erreur lors  de son ex&eacute;cution: par exemple une division  par 0, ou encore l'ouverture d'un fichier inexistant  (ou qui ne  peut pas &ecirc;tre  lu pour un  probl&egrave;me de  permissions).  Le probl&egrave;me est g&eacute;n&eacute;ralement  le suivant: l'erreur se produit dans une biblioth&egrave;que; un objet doit ouvrir un fichier dont on lui a pass&eacute; le nom en  param&egrave;tres.  L'objet voit bien qu'il y a une erreur (il n'a pas trouv&eacute;  le fichier), mais comment doit-il r&eacute;agir
? En fait, il ne <em>le sait pas</em>...  parce que ce n'est pas &agrave; lui
de  r&eacute;agir.  C'est au  programme utilisateur  de l'objet:  suivant les
cas,  la r&eacute;action  de celui-ci  sera  soit l'arr&ecirc;t  du programme  avec
impression d'un message, soit tentative de reprise apr&egrave;s avoir demand&eacute;
&agrave; l'utilisateur un nouveau nom de fichier, soit g&eacute;n&eacute;ration automatique
d'un  nouveau nom  de  fichier, ...   L'objet  doit donc  se borner  &agrave;
pr&eacute;venir le programme  appelant qu'il y a eu une erreur.  Il y a trois
moyens:</p>

<ul>
  <li>Retourner un code d'erreur comme valeur de retour de la fonction.</li>
  <li>Mettre un code d'erreur dans une valeur globale (<code>errno</code> en C)</li>
  <li>G&eacute;n&eacute;rer une exception.</li>
</ul>

<p>Les  deux   premiers  moyens   pr&eacute;sentent  certains
inconv&eacute;nients: tout  d'abord, si la fonction,  dans son fonctionnement
normal,  doit  d&eacute;j&agrave; renvoyer  une  valeur,  comment  renvoyer le  code
d'erreur  ? Par  une  valeur  ill&eacute;gale peut-&ecirc;tre,  mais  ce n'est  pas
toujours possible... ainsi une fonction qui doit renvoyer un entier ne
peut renvoyer une valeur ill&eacute;gale.   D'autre part, une bonne partie du
code utilisateur risque d'&ecirc;tre  consacr&eacute;e au traitement des erreurs...
&agrave; condition que  le programmeur ait assez de  courage ou de conscience
professionnelle.   On  estime  que  dans  certains cas  le  code  peut
<em>doubler</em>  simplement  &agrave;  cause  du traitement  d'erreurs.   De
mani&egrave;re plus fondamentale,  on aura une totale imbrication  du code de
traitement   d'erreurs  et   du  code   de  l'application,   d'o&ugrave;  une
 mauvaise lisibilit&eacute; du  code.  Le  C++ offre  un syst&egrave;me
d'exceptions qui am&eacute;liore consid&eacute;rablement la situation.</p>

<p><a href="#"></a></p><hr />
<h2><a name="poste"><img src="61.gif" alt="Pour les terriens"  width="20" />Une analogie avec la vie courante</a></h2>

<p>Afin de bien comprendre le syst&egrave;me des exceptions, imaginons l'administration des
 postes d'un pays quelconque: l'organisation  est la suivante:</p>

<ol>
   <li>Service National des Postes</li>
   <li>Service R&eacute;gional des Postes</li>
   <li>Bureau de Postes de quartier</li>
   <li>Facteur</li>
</ol>

<p>Il faut comprendre cette analogie de la mani&egrave;re suivante:</p>

<ol>
   <li>Le Service National des Postes correspond au programme principal</li>
   <li>Le Service R&eacute;gional 
   correspond &agrave; une fonction appel&eacute;e par le programme principal.</li>
   <li>Le Bureau de postes de quartier correspond &agrave; une fonction appel&eacute;e 
   par la fonction pr&eacute;c&eacute;dente.</li>
   <li>Le facteur est une m&eacute;thode appartenant &agrave; un objet utilis&eacute; par
   la fonction pr&eacute;c&eacute;dente.</li>
</ol>

<p>Imaginons donc le facteur, en train de distribuer le courrier.  La plupart du temps, tout se passe correctement
 et la mission du facteur est men&eacute;e &agrave; bien. Mais quelques probl&egrave;mes peuvent  survenir; 
 par exemple, une lettre adress&eacute;e &agrave; M. Dupond est not&eacute;e 105 rue des Mimosas, alors que les dupond
 habitent au 15 rue des Mimosas: le facteur connait le quartier, il mettra l'enveloppe dans la bo&icirc;te aux lettres des
 Dupond, m&ecirc;me si l'adresse est mauvaise. Il s'agit d'un cas d'erreur qui a pu &ecirc;tre corrig&eacute; par le facteur - par
 l'objet. Rien ni personne ne sera au courant qu'il y a eu un probl&egrave;me avec cette enveloppe. 
Autre probl&egrave;me possible: une lettre est adress&eacute;e &agrave; M. Durand, or il n'y a pas de M. Durand 
dans le quartier. Cette fois, le facteur mettra la lettre dans une bo&icirc;te appel&eacute;e "Adresses inconnues", 
et il continuera sa tourn&eacute;e. <br />
Voil&agrave; que le facteur tombe sur une lettre qui comporte la bonne adresse, mais il s'agit d'une rue 
situ&eacute;e dans un autre quartier: le facteur mettra la lettre dans une nouvelle bo&icirc;te, appel&eacute;e 
"autres quartiers". <br />A la fin de sa tourn&eacute;e, le facteur regarde l'&eacute;tat de ses deux bo&icirc;tes: si 
elles sont vides, il rentre chez lui tout simplement. La m&eacute;thode "facteur" a fait son travail sans histoire.
 Si au moins l'une des deux est pleine, le facteur, avant de rentrer chez lui, va d&eacute;poser &agrave; un endroit 
 r&eacute;serv&eacute; &agrave; cet usage, au bureau de postes, le ou les cartons contenant les lettres en cause: il 
 "lance une exception"; celle-ci sera trait&eacute;e soit au niveau du bureau de poste du quartier, soit  au niveau 
 sup&eacute;rieur; <i>mais en aucun cas le facteur ne prend de d&eacute;cision &agrave; propos de cette lettre</i>:
 ce n'est tout simplement pas son travail.<br />Le bureau de poste de quartier, voyant qu'il y a une "exception", va 
 alors la traiter: si l'adresse situ&eacute;e sur la lettre "autres secteurs" correspond &agrave; un secteur 
 g&eacute;r&eacute; par ce bureau de poste, il suffira de la donner &agrave; un autre facteur pour que le probl&egrave;me
 soit r&eacute;solu. L'erreur a &eacute;t&eacute; corrig&eacute;e au niveau Bureau de Poste, et personne &agrave; un 
 plus haut niveau n'en saura rien. Sinon, le bureau de poste la renvoie &agrave; l'&eacute;chelon sup&eacute;rieur 
 (r&eacute;gional) qui se chargera du probl&egrave;me, &agrave; moins qu'il ne le renvoie &agrave; nouveau &agrave; un
 &eacute;chelon sup&eacute;rieur... </p>
 
<p>C'est un syst&egrave;me analogue qui est employ&eacute; par le C++ pour traiter les exceptions:</p>

<ul>
   <li>Si une fonction peut traiter l'exception, elle la traite.</li>
   <li>Si une fonction ne peut pas la traiter, elle renvoie un objet; celui-ci sera intercept&eacute; &agrave; un niveau d'appel
   sup&eacute;rieur: &agrave; ce niveau de d&eacute;cider
   s'il sait traiter l'exception ou s'il la renvoie lui aussi &agrave; un niveau sup&eacute;rieur</li>
</ul>

<p>Il est possible de renvoyer ainsi n'importe quel objet, et de mettre donc dans cet objet n'importe quelle information:
 un code d'erreur, par exemple, avec une cha&icirc;ne de caract&egrave;res explicative, mais aussi des donn&eacute;es 
 (d'autres objets, par exemple) permettant aux niveaux sup&eacute;rieurs de traiter effectivement l'exception.</p>

<p><a href="#"></a></p><hr />

<h2><a name="excep">Le syst&egrave;me d'exceptions</a></h2>

<p>Supposons  qu'on ajoute  &agrave;  notre  type complexe  un
constructeur ayant pour objet l'initialisation du complexe &agrave; partir de
donn&eacute;es se trouvant dans un fichier.  Le  code  du constructeur  correspondant  se
trouve ci-dessous:</p>

<pre class="demo">
complexe::complexe(const char* fn) {
  ifstream input(fn);
  float x,y;
  input &gt;&gt; x;
  input &gt;&gt; y;
  input.close();
  set_r(x);
  set_i(y);
};
</pre>

<p>Il  n'y a ici <em>aucun  traitement d'erreur.</em> Si
le  fichier est  inexistant, le  r&eacute;sultat sera  n'importe quoi.  Si le
fichier existe  mais contient une  seule ligne, la partie  r&eacute;elle sera
correctement initialis&eacute;e, mais pas la partie imaginaire. Voici comment
nous pouvons ajouter un traitement d'erreur:</p>

<h3><a name="hier">Les hi&eacute;rarchies d'objets exceptions</a></h3>

<p>Nous allons  tout d'abord  d&eacute;finir  quelques objets,
sous forme de classe ou  de structure, g&eacute;n&eacute;ralement tr&egrave;s simples, mais
li&eacute;s entre eux par une relation d'h&eacute;ritage. En particulier, tous
d&eacute;riveront de la hi&eacute;rarchie d'exceptions standards, qui est
partiellement d&eacute;crite ci-dessous:</p>

<h4>Les exceptions standards</h4>

<p>Plusieurs objets <code>exception</code> sont d&eacute;finis dans la biblioth&egrave;que 
standard (en-t&ecirc;te <code>&lt;stdexcept&gt;</code>), en pratique on utilise 
l'objet de plus haut niveau, <code>exception</code>: <em>Toute nouvelle exception d&eacute;finie
dans votre code devra d&eacute;river de cet objet</em>. Elle devra fournir une fonction virtuelle
appel&eacute;e <code>what()</code>, qui renvoie une chaine de caract&egrave;res 
d&eacute;crivant l'exception. Il est possible d'ajouter un constructeur recevant 
un argument de type <code>char *</code> pour fixer la valeur de la chaine renvoy&eacute;e par
<code>what</code>. Bien s&ucirc;r, toute autre extension (par exemple un champ de type <code>int</code>
pour indiquer un code d'erreur num&eacute;rique) sera &eacute;galement possible.</p>

<h4>Exceptions complexes</h4>

<pre class="demo">
class CE : public exception {
public:
   const char* what() throw() const {return "Complexe exception";};
};

class CE_F: public CE {
public:
   CE_F(char* filename) : _name(filename) {};
   const char* what() throw() const {
      string pb = "Complexe exception = File pb, filename = " + _name;
      return pb;
   };
protected:
   string _name;
};   

class CE_O: public CE_F {     
 public:
  CE_O(char* filename, int e) : CE_F(filename), _err(e) {};
  int geterror() const { return _err;};
 private:
  int _err;
};

class CE_R: public CE_F {};
</pre>

<p>La classe  <code>CE</code>  d&eacute;finit les  "exceptions
complexes" de mani&egrave;re g&eacute;n&eacute;rale, c'est-&agrave;-dire que toutes les exceptions
g&eacute;n&eacute;r&eacute;es par  la classe <code>complexe</code> seront de  ce type. Ces
exceptions peuvent &ecirc;tre de plusieurs sortes: un 
probl&egrave;me  de fichier, avec  notre classe  <code>fcomplexe</code>, mais
aussi  un probl&egrave;me num&eacute;rique  (division par  z&eacute;ro).  Les  probl&egrave;mes de
fichiers donneront  lieu &agrave; une exception de  type <code>CE_F</code>. A
nouveau, plusieurs probl&egrave;mes  peuvent se pr&eacute;senter: fichier impossible
&agrave; ouvrir parce que inexistant (<code>CE_O</code>), ou fichier ayant un
mauvais format (<code>CE_F</code>). La classe <code>CE_O</code> est un
peu  plus compliqu&eacute;e  que  les  autres, car  elle  contiendra le  code
d'erreur.</p>

<h3><a name="decl">La d&eacute;claration de fonction</a></h3>

<p>Bien que ce ne soit pas obligatoire, il est fortement
conseill&eacute; de montrer lors de la d&eacute;claration qu'une fonction donn&eacute;e est
susceptible  de g&eacute;n&eacute;rer  une exception.  Par exemple, nous aurons la 
d&eacute;claration suivante:</p>

<pre class="demo">
class complexe: public  {
public:
  complexe(const char* ) throw(CE);
  char* get_fn() const throw() {return fn;};
  ...
private:
  char * fn;
  ...
}
</pre>

<p><code>throw(CE)</code>  dans   la   d&eacute;claration  du
constructeur signifie  qu'en cas de malheur,  celui-ci est susceptible
de  g&eacute;n&eacute;rer  une  exception   de  type  <code>CE</code>.  La  fonction
<code>get_fn</code>, elle, ne peut g&eacute;n&eacute;rer aucune exception.  Cela est
indiqu&eacute; par <code>throw()</code>.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> Il n'est
pas obligatoire de mettre la sp&eacute;cification <code>throw</code> dans les
d&eacute;clarations de  fonction.  Cependant, cela est  pr&eacute;f&eacute;rable: en effet,
les  utilisateurs de  vos classes  (vous ou  un autre)  sauront alors,
simplement  en  lisant  le  fichier  d'ent&ecirc;te de  la  classe,  quelles
exceptions   la    fonction   est   susceptible    de   g&eacute;n&eacute;rer.    Si
<code>throw</code> n'est  pas sp&eacute;cifi&eacute;, ils seront oblig&eacute;s  de lire le
code source.</p></div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> Le compilateur v&eacute;rifiera la
coh&eacute;rence  entre  d&eacute;claration et  d&eacute;finition  de  fonction. Ainsi,  la
d&eacute;finition du constructeur de <code>fcomplexe</code>, devra ressembler
&agrave; ce qui suit:</p>

<pre class="demo">
<b>complexe::complexe(const char* fn) throw(CE) </b>{
...
}
</pre>

<p>Par contre,  le compilateur <em>ne v&eacute;rifiera pas</em>
si vous  &ecirc;tes menteur ou  pas: en d'autres  termes, s'il n'y  a aucune
instruction <code>throw</code>  dans le  corps de la  fonction, aucune
erreur ne sera g&eacute;n&eacute;r&eacute;e et personne ne vous mettra en garde.</p>
</div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Si vous avez sp&eacute;cifi&eacute; une ou plusieurs exceptions dans la d&eacute;claration
de fonction, 
et que c'est en fait <i>une autre</i> exception qui est g&eacute;n&eacute;r&eacute;e, dans
ce cas une fonction particuli&egrave;re, appel&eacute;e <code>unexpected</code>, est
appel&eacute;e. G&eacute;n&eacute;ralement, la cons&eacute;quence de cette fonction est l'arr&ecirc;t du
programme.</p></div>

<h3><a name="gene">La g&eacute;n&eacute;ration d'exception</a></h3>

<p>L'exception  est  g&eacute;n&eacute;r&eacute;e,   dans  le  corps  de  la
fonction,  par  la   fonction  <code>throw</code>.   Le  param&egrave;tre  de
<code>throw</code>   <em>est   un   objet   d'un   type   d&eacute;fini   par
l'utilisateur</em>. Voici le code de notre constructeur:</p>

<pre class="demo">
complexe::complexe(const char* fn) throw(CE) {
  ifstream input(fn);
  if (! input) {
    CE_O e(fn,input.rdstate());
    throw(e);
  };
  input &gt;&gt; e;
  CE_R e;
  if (! input) {
    throw(e);
  };
  input &gt;&gt; i;
  if (! input) {
    throw(e); 
  };
};
</pre>

<h3><a name="capt">La capture des exceptions</a></h3>

<p>Notre constructeur va  donc g&eacute;n&eacute;rer des exceptions le
cas   &eacute;ch&eacute;ant,  encore   faut-il   que  la   fonction  appelante   les
"capture". Voici un  exemple de fonction appelante, qui  va demander &agrave;
l'utilisateur un nom de fichier, jusqu'&agrave; ce que ce fichier puisse &ecirc;tre
ouvert:</p>

<pre class="demo">
complexe* create_compl() {
  complexe* fc;
  for (;;) {
    String fn;
    cout &lt;&lt; "entrer un nom de fichier ";
    cin &gt;&gt; fn;
    try {
      fc = new fcomplexe(fn);
      break;
    }
    catch (const CE_O &amp; e) {
      cerr &lt;&lt; "Erreur d'ouverture de fichier - etat " &lt;&lt; e.geterror() &lt;&lt; "\n";
      cerr &lt;&lt; "Entrez un autre nom\n";
      continue;
    }
  };
  return fc;
};

void main() {
  complexe::set_debug();
  fcomplexe* D = create_compl();
} 
</pre>

<p>Tout    se   passe   dans    une   boucle   infinie
(<code>for(;;)</code>), qui permettra la reprise en cas
d'erreur  d'ouverture  de   fichier.   L'appel  du  constructeur  (via
l'op&eacute;rateur   <code>new</code>)   est    &agrave;   l'int&eacute;rieur   d'un   bloc
<code>try</code>.   Ce  bloc est  suivi  (<em>attention</em>, le  bloc
<code>try</code> se termine par un <code><b>}</b></code>, <em>pas</em> par un
<code><b>};</b></code>)         d'un        ou         plusieurs        blocs
<code>catch</code>.  <code>catch</code> prend  un  param&egrave;tre (de  m&ecirc;me
qu'une fonction), le type de  ce param&egrave;tre est le type d'exception que
l'on  cherche  &agrave;  capturer  (ici <code>CE_O</code>).  L'exception  est
trait&eacute;e dans le bloc <code>catch</code>.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> En
fait, plusieurs programmes de capture d'exceptions auraient pu &ecirc;tre
&eacute;crits, suivant la finesse avec laquelle on veut traiter les
exceptions:</p>
<ul>
  <li>On pourrait se contenter de capturer les exceptions de type
      <code>CE</code></li>
  <li>Dans un traitement plus grossier, on peut capturer les exceptions
      de type <code>run_time</code></li>
  <li>Dans un traitement encore plus grossier, on peut se contenter de
       capturer les exceptions de type <code>exception</code>.</li>
</ul>
</div>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
Il est donc important de passer l'objet exception par <code><b>const&nbsp;exception&nbsp;&amp;</b></code>,
afin de s'assurer que le bon objet sera au final utilis&eacute; (notamment la bonne version
de la fonction <code>what()</code>).</p></div>
<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
Si la syntaxe ne le rend pas obligatoire, il est
important de bien d&eacute;finir les exceptions de mani&egrave;re hi&eacute;rarchique, et
de pr&eacute;f&eacute;rence comme des classes d&eacute;riv&eacute;es de la classe
<code>exception</code>. Cela permet en effet le traitement
hi&eacute;rarchis&eacute; des exceptions, ainsi qu'on vient de le voir.
</p></div>

<h3><a name="noncapt">Exceptions non captur&eacute;es</a></h3>

<p>Et    que   se   passe-t-il    si   une   exception
<code>CE_R</code> est g&eacute;n&eacute;r&eacute;e ?  Elle ne sera pas trait&eacute;e: &agrave; la place,
elle sera transmise &agrave; nouveau &agrave; la fonction appelante.  Dans l'exemple
ci-dessus,  puisque   <code>main</code>  ne  pr&eacute;voit   aucune  capture
d'exception, l'exception se terminera  par un arr&ecirc;t du programme. Mais
il est parfaitement possible  d'envisager un traitement des exceptions
restant  &agrave; capturer  par  la fonction  <code>main</code>;  le code  de
celle-ci devient alors:</p>

<pre class="demo">
void main() {
  complexe::set_debug();
  try {
    complexe* D = create_compl();
    cout &lt;&lt; *D &lt;&lt; "\n";
  }
  catch (const CE_F &amp;) {
    cout &lt;&lt; e.what();
  }
  catch (...) {
    cout &lt;&lt; "Autre exception\n";
  };
} 
</pre>

<p>Le premier  bloc  <code>catch</code> correspond  aux
erreurs de format de fichier, qui peuvent effectivement &ecirc;tre renvoy&eacute;es
par <code>fcomplexe</code>.  Le second  correspond &agrave; toutes les autres
exceptions.</p>

<h4><a name="renvoi">Renvoyer les exceptions</a></h4>

<p>Un bloc <code>catch</code> peut parfaitement se
terminer par le renvoi d'une exception. Cela permet par exemple de
d&eacute;finir dans une fonction quelques traitements sp&eacute;cialis&eacute;s et de
renvoyer le traitement des exceptions restantes au code appelant. A
cet effet, on peut appeler la fonction <b><code>throw()</code></b> qui
renvoie l'exception en cours de traitement.</p>

<p><a href="#"></a></p><hr />

<h2><a name="excepet">Exceptions et ...</a></h2>

<h3><a name="const">...constructeurs</a></h3>

<p>Le  syst&egrave;me des  exceptions  est  <em>le syst&egrave;me  de
traitement d'erreurs</em>  &agrave; employer pour  des constructeurs d'objet,
<em>&agrave;  l'exclusion  de tout  autre</em>:   on pourrait  par
exemple  imaginer une  variable <code>err</code>  qui  indiquerait que
l'objet est construit,  certes, mais dans un &eacute;tat  "bizarre", donc pas
vraiment utilisable.   C'est ce qu'on appelle  les "objets zombies"...
cela peut conduire &agrave;  des comportements inattendus (variables internes
non initialis&eacute;es, par exemple),  &agrave; moins que l'objet soit suffisamment
bien &eacute;crit pour que toutes  les fonctions-membres testent la valeur de
<code>err</code>  afin   de  s'assurer   que  l'objet  n'est   pas  un
zombie... mais dans  ce cas, que de code inutile !  A l'inverse, si le
constructeur est interrompu par une exception, <em>l'objet ne sera pas
construit</em>...  Or, un vrai mort  vaut mieux qu'un faux zombie, qui
ira  pr&eacute;tendre le  contraire ?   Si une  exception a  lieu  dans le
constructeur d'une  classe d&eacute;riv&eacute;e,  comme c'est le  cas avec  le type
<code>fcomplexe</code>,    le    processus    de   construction    est
interrompu... mais  le constructeur  de la classe  de base a  d&eacute;j&agrave; &eacute;t&eacute;
appel&eacute;. Avant que la main soit rendue au bloc <code>catch</code> de la
fonction appelante,  le destructeur  de la classe  de base  sera alors
autmatiquement appel&eacute;, de sorte qu'on  ne risque pas d'avoir de "fuite
de m&eacute;moire".</p>

<h3><a name="dest">...destructeurs</a></h3>

<p>Le   syst&egrave;me  des  exceptions  est   le  syst&egrave;me  de
traitement d'erreurs <em>&agrave; ne pas employer</em> avec les destructeurs:
en effet, un  destructeur peut &ecirc;tre appel&eacute; lors  du d&eacute;roulement normal
du programme;  mais il  peut aussi &ecirc;tre  appel&eacute; lors de  la g&eacute;n&eacute;ration
<em>d'une  autre  exception</em>.   Dans  ce cas,  le  programme  sera
imm&eacute;diatement arr&ecirc;t&eacute;.<br /> Evidemment, rien  n'emp&ecirc;che un destructeur
d'appeler des  fonctions qui, elles,  sont suceptibles de  g&eacute;n&eacute;rer une
exception.  Mais dans  ce cas,  ces  appels de  fonction doivent  &ecirc;tre
encadr&eacute;s  par   des  blocs  <code>try...catch</code>,   et  <em>aucune
exception ne  doit s'&eacute;chapper</em>  du destructeur. Cela  signifie que
les  destructeurs, s'ils  ont  une erreur  &agrave;  faire remonter,  devront
trouver un autre  syst&egrave;me. Par exemple &eacute;crire sur  une fen&ecirc;tre ou dans
un fichier de log.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
  Cette dissym&eacute;trie  peut  para&icirc;tre surprenante  &agrave;
premi&egrave;re vue...  mais  en fait, en informatique comme  dans la vie, il
est bien plus  simple de d&eacute;truire que de  construire: on  peut avoir  du mal  &agrave; construire  une maison,  rien  ne devrait
pouvoir vous emp&ecirc;cher de la d&eacute;truire...  De m&ecirc;me, le constructeur peut
rencontrer  un grand  nombre  de probl&egrave;mes  (ressources impossibles  &agrave;
trouver, par exemple), mais  normalement le destructeur ne <em>devrait
pas</em> g&eacute;n&eacute;rer d'erreur...  ou alors, c'est grave, car cela signifie
que le syst&egrave;me refuse de r&eacute;cup&eacute;rer une ressource. </p></div>

<p><a href="#"></a></p><hr />

<div class="autres langages"><img alt="DECHIRURE" src="dechirure.gif" />
<table class="tableau">
  <tr>
    <th> Langage </th>
    <th> Exceptions </th>
  </tr>
  <tr>
    <td><b>C++</b> </td>
    <td><b>OUI</b></td>
  </tr>
  <tr>
    <td><b>perl</b></td>
    <td>NON</td>
  </tr>
  <tr>
    <td><b>java</b></td>
    <td><b>OUI</b></td>
  </tr>
  <tr>
    <td><b>python</b></td>
    <td><b>OUI</b></td>
  </tr>
</table>
</div>
<p><a href="#"></a></p><hr />
<address><a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>
<p>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p></div></body> </html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Exercices</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
    <dd id="smenu1">
    <ul>
      <li><a onclick="javascript=cacher_menu()" href="#pointeurs">Pointeurs et r&eacute;f&eacute;rences</a></li>
      <li><a onclick="javascript=cacher_menu()" href="#class">Le type class</a></li>
      <li><a onclick="javascript=cacher_menu()" href="#surcharge">surcharge des fonctions et op&eacute;rateurs"</a></li>
      <li><a onclick="javascript=cacher_menu()" href="#heritage">H&eacute;ritage</a></li>
      <li><a onclick="javascript=cacher_menu()" href="#modeles">Mod&egrave;les</a></li>
      <li><a onclick="javascript=cacher_menu()" href="#exceptions">Exceptions</a></li>
      <li><a onclick="javascript=cacher_menu()" href="#memoire">Gestion de la m&eacute;moire</a></li>
      <li><a onclick="javascript=cacher_menu()" href="#stdlib">La biblioth&egrave;que standard.</a></li>
   </ul>
   </dd>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="contenu">
<h1>Exercices du cours C++</h1>

<h2><a id="pointeurs">Pointeurs et r&eacute;f&eacute;rences</a></h2>
<ol>
  <li> <b>corrig&eacute; <a href="exos/p1.C">code</a>, <a href="exos/p1.html">html</a></b><br /> Programme <code>p1.C</code>:
      <ul>
	<li>On d&eacute;clare un tableau d'entiers <code>A</code> de dimension
	    10</li>
	<li>Deux sous-programmes, <code>remplitA</code> et
	    <code>impA</code>, permettent de remplir et imprimer le
	    tableau.</li>
	<li>D&eacute;clarer une r&eacute;f&eacute;rence vers l'&eacute;l&eacute;ment 5 du tableau et
	    incr&eacute;menter sa valeur</li>
	<li>D&eacute;clarer un pointeur vers l'&eacute;l&eacute;ment 7, incr&eacute;menter le
	    pointeur et la valeur point&eacute;e</li>
      </ul></li>
  <li><b>corrig&eacute; <a href="exos/p2.C">code</a>, <a href="exos/p2.html">html</a></b><br />  Programme <code>p2.C</code>:
      <ul>
	<li>D&eacute;clarer un entier</li>
	<li>D&eacute;clarer une r&eacute;f&eacute;rence vers cet entier</li>
	<li>D&eacute;clarer un pointeur vers cet entier</li>
	<li>Dans les deux cas, imprimer la variable, l'adresse de la
	    variable, la valeur point&eacute;e.</li>
      </ul></li>
  <li><b>corrig&eacute; <a href="exos/p3.C">code</a>, <a href="exos/p3.html">html</a></b><br />  En reprenant <code>p1.C</code>, d&eacute;clarer des pointeurs sur A[5], en
      utilisant ou non les attributs <code>const</code>.
      <ul>
	<li>V&eacute;rifier que certaines instructions ne seront pas
	    compil&eacute;es</li>
	<li>V&eacute;rifier que, malgr&eacute; tout, <code>*a</code> peut changer de
	    valeur...</li>
      </ul></li>
  <li><b>corrig&eacute; <a href="exos/alea.C">code</a>, <a href="exos/alea.html">html</a></b><br /> Programme
      <code>alea.C</code>:  Soit  un tableau  de  dimension 
      200. Ecrire une fonction qui renvoie de mani&egrave;re al&eacute;atoire chaque
      cellule du tableau, sous forme de lvalue</li>
</ol>

<h2><a id="class">Le type class</a></h2>

<ol>
  <li><b>corrig&eacute; <a href="exos/stack.C">code</a>, <a href="exos/stack.html">html</a></b><br /> Programme
      <code>stack.C:</code>Ecrire  une classe pile d'entiers 
      ayant les caract&eacute;ristiques suivantes:
      <ul>
	<li>Repose sur un tableau de dimension n, n &eacute;tant pass&eacute; au
	    constructeur (allocation dynamique)</li>
	<li>Permet d'empiler et d&eacute;piler les donn&eacute;es</li>
	<li>Une fonction <code>length()</code> permet de savoir
	    combien de donn&eacute;es sont empil&eacute;es</li>
      </ul></li>
  <li><b>corrig&eacute; <a href="exos/stack1.C">code</a>, <a href="exos/stack1.html">html</a></b><br /> Modifier le programme
      pr&eacute;c&eacute;dent afin de visualiser les appels de 
      constructeurs et de destructeurs: v&eacute;rifier les r&egrave;gles de port&eacute;e
      des variables.</li>
</ol>
<hr />

<h2><a id="surcharge">Surcharge des fonctions et op&eacute;rateurs</a></h2>

<ol>
   <li><b>corrig&eacute; <a href="exos/tableau.C">code</a>, <a href="exos/tableau.html">html</a></b><br /> Programme tableau.C: d&eacute;finir
   une classe <code>tableau</code> 
   ayant les caract&eacute;ristiques suivantes:
   <ul>
      <li>Repose sur un tableau de dimension n, n &eacute;tant pass&eacute; au
      constructeur (allocation dynamique)</li>
      <li>Impl&eacute;menter les op&eacute;rateurs +=,-=,+,-</li>
      <li>On acc&egrave;de aux donn&eacute;es &agrave; l'aide de l'op&eacute;rateur
      <code>[]</code>. En cas de d&eacute;bordement, cet op&eacute;rateur
      imprime un message et ne fera rien de dangereux.</li>
   </ul></li>
   <li>Reprendre le programme pr&eacute;c&eacute;dent et introduire une
   fonction-membre <code>transform</code>, qui applique une fonction sur tout le
   tableau. Utiliser deux impl&eacute;mentations diff&eacute;rentes:
   <ul>
      <li><b>corrig&eacute; <a href="exos/tableau1-ptrfct.C">code</a>, <a href="exos/tableau1-ptrfct.html">html</a></b><br /> En utilisant
      les pointeurs de fonctions &agrave; la C</li> 
      <li><b>corrig&eacute; <a href="exos/tableau1-ofct.C">code</a>, <a href="exos/tableau1-ofct.html">html</a></b><br /> En utilisant
      les objets-fonctions &agrave; la C++</li>
   </ul></li>
   <li><b>corrig&eacute; <a href="exos/tableau2-ofct.C">code</a>, <a href="exos/tableau2-ofct.html">html</a> </b><br /> Reprendre le
   programme pr&eacute;c&eacute;dent (version objets-fonctions), en 
   d&eacute;finissant un objet-fonction qui &eacute;cr&egrave;grave;te le tableau de d&eacute;part:
   si la valeur est sup&eacute;rieure &agrave; un seuil param&eacute;trable,
   on la remplace par le max. Faire cela en
   utilisant un objet-fonction un peu plus sophistiqu&eacute; que
   pr&eacute;c&eacute;demment.<br />
   Comment aurait-on pu faire la m&ecirc;me chose avec des pointeurs de
   fonction &agrave; la C ?</li>
   <li>Expliquer pourquoi le code suivant:<code>truc &amp; operator=(const
   truc &amp;t) { *this=t; return *this};</code> aboutit &agrave; un plantage.</li>
</ol>
<hr />

<h2><a id="heritage">H&eacute;ritage</a></h2>

<ol>
  <li><b>corrig&eacute; <a href="exos/tableau3-ofct.C">code</a>, <a href="exos/tableau3-ofct.html">html</a></b><br />
      R&eacute;&eacute;crire la fonction
      transform ci-dessus (tableau), en passant en 
      param&egrave;tres une classe de base fonction-objet, afin de gagner en souplesse.</li>
  <li>Lire les trois fichiers:
      <ul>
	<li><a href="exos/seqprot1.h"><code>seqprot1.h</code></a> (<a href="exos/seqprot1.h.html">html</a>)</li>
	<li><a href="exos/seqprot1.C"><code>seqprot1.C</code></a> (<a href="exos/seqprot1.C.html">html</a>)</li>
	<li><a href="exos/seqprot-main.C"><code>seqprot-main.C</code></a> (<a href="exos/seqprot-main.C.html">html</a>)</li>
      </ul>
      Essayez de comprendre le code, puis r&eacute;&eacute;crivez le module seqprot
      en faisant en sorte que les classes <code>seqprot</code>
      (s&eacute;quence de prot&eacute;ine) et
      <code>seqadn</code> (s&eacute;quence d'adn) d&eacute;rivent toutes les deux d'une m&ecirc;me classe,
      que vous appellerez <code>seqmac</code> (s&eacute;quence de
      machin). <br />
      <b>Corrig&eacute;: <a href="exos/seqprot2.h"><code>.h</code></a>, <a href="exos/seqprot2.h.html"><code>.h (html)</code></a> et <a
      href="exos/seqprot2.C"><code>.C</code></a> <a
      href="exos/seqprot2.C.html"><code>.C (html)</code></a></b>. Le programme principal devra
      rester inchang&eacute;</li>
  <li>Ecrire alors le code d'une nouvelle classe, <code>seqarn</code>
      (acides nucl&eacute;iques = <code>CAGU</code>), et r&eacute;&eacute;crire un programme
      principal afin de la tester. <br />
      <b>Corrig&eacute;:  <a href="exos/seqarn.h"><code>.h</code></a>, <a href="exos/seqarn.h.html"><code>.h (html)</code></a> et 
      <a href="exos/seqarn.C"><code>.C</code></a>, <a href="exos/seqarn.C.html"><code>.C (html)</code></a>,
      <a href="exos/seqarn-main.C">programme principal</a> <a href="exos/seqarn-main.C.html">(html)</a>.</b></li>
</ol>

<hr />

<h2><a id="modeles">Mod&egrave;les</a></h2>

<ol>
  <li><b>corrig&eacute; <a href="exos/tableau4-ofct.C">code</a>, <a href="exos/tableau4-ofct.html">html</a>.</b><br />
  R&eacute;&eacute;crire le tableau (et les fonctions-objets associ&eacute;s) en 
  rempla&ccedil;ant le type de base du tableau (<code>int</code>) par un
  mod&egrave;le.</li>
  <li><b>corrig&eacute; <a href="exos/tableau5-ofct.C">code</a>, <a href="exos/tableau5-ofct.html">html</a></b><br />
  R&eacute;&eacute;crire &agrave; nouveau le tableau en rempla&ccedil;ant la dimension par un param&egrave;tre de mod&egrave;le</li>
  <li><b>corrig&eacute; <a href="exos/tableau6-ofct.C">code</a>, <a href="exos/tableau6-ofct.html">html</a></b><br />
  Ajouter des fonctions permettant de convertir des tableaux de divers types (mais de m&ecirc;me taille).</li>
</ol>

<hr />

<h2><a id="exceptions">Exceptions</a></h2>

<ol>
  <li>Reprendre les classes <code>seqprot</code>, <code>seqadn</code>,
      <code>seqarn</code> ci-dessus et les (ou un seul ?) modifier
      afin de lancer une exception lorsqu'ils sont initialis&eacute;s avec
      une lettre ne convenant pas (un P pour l'arn, par exemple).<br />
      Dans le programme principal, trois cas diff&eacute;rents seront
      abord&eacute;s:
      <ol>
	<li><code>seqprot </code> Lorsque l'exception est rencontr&eacute;e,
	    &eacute;crire un message &agrave; l'&eacute;cran en donnant l'id&eacute;e de la
	    s&eacute;quence qui aurait &eacute;t&amp; acceptable, puis sortir
	    proprement.</li>
	<li><code>seqadn</code> Arrangez-vous pour que le comportement
	    du programme soit <i>identique</i> &agrave; ce qu'il &eacute;tait
	    lorsqu'on ignorait simplement les lettres ne figurant pas
	    dans l'alphabet.</li>
	<li><code>seqarn</code> Pas de traitement d'exception</li>
      </ol>
      <b>Corrig&eacute;:  <a href="exos/seqprot2-except.h"><code>.h</code></a>, <a href="exos/seqprot2-except.h.html"><code>.h (html)</code></a>, 
      <a href="exos/seqprot2-except.C"><code>.C</code></a>, <a href="exos/seqprot2-except.C.html"><code>.C (html)</code></a> et 
      <a href="exos/seqarn-except-main.C">programme principal</a>, <a href="exos/seqarn-except-main.C.html"> (html)</a></b></li>
      
  <li>R&eacute;&eacute;crire le tableau
      en impl&eacute;mentant un m&eacute;canisme d'exception lorsqu'on essaie
      d'acc&eacute;der &agrave; une cellule du tableau en-dehors des limites.<br />
      <b>corrig&eacute; <a href="exos/tableau7-ofct.C">code</a>, <a href="exos/tableau7-ofct.C.html">(html)</a></b> 
      </li>
</ol>

<hr />

<h2><a id="memoire">Gestion de la m&eacute;moire</a></h2>

<ol><li> <b>corrig&eacute;: <a href="exos/p11.C">code</a>,  <a href="exos/p11.C.html">html</a></b> 
      <ul>
	<li>Ecrire un objet (dans le style de tableau) qui fait un new dans son constructeur et un
	    delete dans son destructeur. </li>
	<li>Modifier cet objet en le faisant g&eacute;n&eacute;rer une exception de mani&egrave;re syst&eacute;matique
	    apr&egrave;s le new. </li>
	<li>Faire une boucle infinie afin d'allouer et d&eacute;sallouer syst&eacute;matiquement ce objet dans la boucle et 
	observez (avec <code>top</code> par exemple) la fuite de m&eacute;moire.</li>
	<li>Remplacez le pointeur par un <code>auto_ptr</code> et refaites l'exp&eacute;rience.</li>
      </ul></li>
</ol>
<hr />

<h2><a id="stdlib">biblioth&egrave;que standard</a></h2>

<ol>
<li> <b>corrig&eacute;: <a href="exos/p12.C">code</a>,  <a href="exos/p12.C.html">html</a></b> <br />
    Ecrire un code qui lise un texte sur l'entr&eacute;e standard, qui
    compte les occurrences de chaque mot, et qui imprime sur la
    sortie standard chaque mot, en ordre alphab&eacute;tique, suivi du
    nombre d'occurences de ce mot. On ne gardera que les mots contenant uniquement des lettres, en supprimant 
    les mots contenant des chiffres ou des caract&egrave;res sp&eacute;ciaux, et on affichera unique√πent les mots apparaissant
    plus de 5 fois</li>
</ol>
<hr />
<address><a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>
</div>
</body> </html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>H&eacute;ritage</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
 <dd id="smenu1">
 <ul>
	<li><a onclick="javascript=cacher_menu()" href="heritage.html#abstraites">Classes abstraites...</a></li> 
    <li><a onclick="javascript=cacher_menu()" href="heritage.html#concretes">...Classes concr&ecirc;tes</a> 
	<ul>
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#prot">Acc&egrave;s aux donn&eacute;es: la section protected</a></li> 
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#const">Constructeurs...</a></li>
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#copie">Le constructeur de copie</a></li>
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#autres-const">Autres constructeurs</a></li>
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#dest">...et destructeurs</a></li> 
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#poly">Le polymorphisme</a></li>
	</ul></li>
    <li><a onclick="javascript=cacher_menu()" href="heritage.html#abc">Classes de bases abstraites</a>
    <ul>
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#virt-const">Constructeurs virtuels...</a></li> 
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#virt-dest">...et destructeurs virtuels</a></li> 
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#virt-fct-const-dest">Appel de fonctions virtuelles depuis le constructeur ou le destructeur</a></li>
		<li><a onclick="javascript=cacher_menu()" href="heritage.html#affect">L'op&eacute;rateur d'affectation dans une classe de base</a></li> 
	</ul></li>
    <li><a onclick="javascript=cacher_menu()" href="heritage.html#mult">L'h&eacute;ritage multiple</a>
    <ul>
        <li><a onclick="javascript=cacher_menu()" href="heritage.html#mult">Impl&eacute;mentation du "pattern" observateur en utilisant l'h&eacute;ritage multiple</a></li>
    </ul></li>
	</ul>
    </dd>
</dl>
<dl>
 <dt><a href="exos.html#heritage" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1 id="heritage">H&eacute;ritage</h1>

<p>Jusqu'&agrave; pr&eacute;sent, nous  avons vu comment d&eacute;finir des
classes, qui permettront de cr&eacute;er des objets dans notre programme. Or,
pour  l'instant,  nous  ne  pouvons  exprimer que certaines relations entre  nos  objets: 
les relations d'association, d'agr&eacute;gation et de composition, qui s'expriment 
par le fait  qu'une donn&eacute;e membre d'un objet peut
&ecirc;tre elle aussi un objet. L'h&eacute;ritage est l'outil qui va nous permettre
d'exprimer entre nos classes une  relation de type "est une sorte de".
Cet outil  est tr&egrave;s puissant, car  gr&acirc;ce &agrave; lui  nous pourrons d&eacute;clarer
des classes d'objets tr&egrave;s g&eacute;n&eacute;raux, puis progressivement "sp&eacute;cialiser"
ces classes  d'objets. Cette sp&eacute;cialisation est  aussi une "extension"
de la classe  de base: si l'on reste dans les  g&eacute;n&eacute;ralit&eacute;s, on n'a pas
grand-chose  &agrave;  dire.  Plus  les  choses  se  pr&eacute;cisent, plus  on doit d&eacute;tailler.
 Donc  &agrave; chaque &eacute;tape du  processus, on rajoutera  du code.  Le
fait de partir  d'une classe de base g&eacute;n&eacute;rale  permet  d'exprimer directement dans le code des concepts abstraits</p>

<h2 id="abstraites">Classes abstraites...</h2>

<p>Reprenons  l'exemple des machines &agrave;  caf&eacute; abord&eacute; lors
de l'introduction  &agrave; la programmation  objet pour les gens  normaux <a
href="progobj.html#cafeteria"><img     alt="avant"     src="avant.gif" /></a>.
Posons-nous la question suivante: "qu'est-ce qu'un cafeti&egrave;re ?" On peut aussi poser la question autrement: "Quels sont les <em>points communs</em> &agrave; toutes les cafeti&egrave;res ?".</p>

<p>Une petite r&eacute;flexion montre qu'une cafeti&egrave;re est une machine qui est capable de:</p>

<ul>
   <li>faire du caf&eacute;</li>
   <li>Produire un syst&egrave;me de voyants permettant &agrave; l'utilisateur de lire son &eacute;tat.</li>
   <li>Prendre un gobelet, une cuiller, un peu d'eau chaude, &agrave; partir de trois r&eacute;servoirs distincts.</li>
</ul>

<p> Nous devrons donc avoir deux fonctions: <code>faire_le_cafe</code> d'une part, <code>lire_etat</code> d'autre part. Mais quel code mettrons-nous dans ces fonctions, puisque &agrave; ce stade nous n'avons aucune id&eacute;e de la mani&egrave;re dont le caf&eacute; serait fait ? La r&eacute;ponse est simple: nous ne mettrons... rien ! Par contre, nous pouvons d'ores et d&eacute;j&agrave; impl&eacute;menter les m&eacute;canismes concernant les r&eacute;servoirs cit&eacute;s ci-dessus. D'o&ugrave; la mod&eacute;lisation UML suivante:</p> 

<p class="uml"><img alt="cafetiere en UML" src="heritage/cafetiere.png" /></p>

<p>et le code suivant:</p>

<pre class="demo">
class cafetiere {
   public:
      <strong>virtual faire_le_cafe() = 0;
      virtual lire_etat() = 0;</strong>
   
   <strong>protected:</strong>
      void verser_eau();
      void sucre();
      void donner_gobelet();
      void donner_cuiller();
      
   private:
      ReservoirEau eau;
      ReservoirSucre sucre;
      ReservoirGobelets gobelets;
      ReservoirCuillers cuillers;
}
</pre>

<p>La syntaxe <code>virtual faire_le_cafe() = 0</code> permet de d&eacute;finir une <strong>fonction virtuelle pure</strong>: on se contente ici de dire au compilateur que les objets <code>Cafetiere</code> seront dot&eacute;s de cette fonction, mais nous lui dirons ult&eacute;rieurement ce que ces fonctions devront faire concr&egrave;tement. Le diagramme UML met ces fonctions <em>en italique</em>.</p>
<p>Le fait que la classe <code>Cafetiere</code> contienne dans sa d&eacute;finition <strong>au moins une fonction virtuelle pure</strong> entraine que cette classe est <em>abstraite</em>. D'o&ugrave; le nom de la classe en italiques dans le diagramme UML.</p>

<h2 id="concretes">...Classes concr&egrave;tes </h2>

<p>Notre cafeti&egrave;re peut se d&eacute;cliner en plusieurs mod&egrave;les:</p>

<ul>
   <li>Un mod&egrave;le &agrave; caf&eacute; soluble.</li>
   <li>Un mod&egrave;le &agrave; caf&eacute; en poudre.</li>
</ul>

<p>Nous savons comment faire le caf&eacute; pour du caf&eacute; soluble ou pour du caf&eacute; en poudre. Nous pouvons donc <em>red&eacute;finir</em> nos fonctions virtuelles, comme on le voit sur le diagramme et le code ci-dessous:</p>

<p class="uml"><img alt="cafetiere soluble en poudre en UML" src="heritage/cafetiere2.png" /></p>

<p>et le code suivant:</p>

<pre class="demo">
class <strong>CafetiereSoluble: public Cafetiere</strong> {

public:
  <strong>virtual int faire_le_cafe();
  virtual int lire_etat();
  void encaisser_monnaie();</strong>

protected:
  void verser_cafe();
  
private:
  ReservoirCafeSoluble cafe;
}

class <strong>CafetierePoudre: public Cafetiere</strong> {

public:
  <strong>virtual int faire_le_cafe();
  virtual int lire_etat();</strong>

protected:
  void verser_cafe_dans_filtre();
  
private:
  ReservoirCafePoudre cafe;
}
</pre>

<p>On a ainsi d&eacute;fini une <strong>relation d'h&eacute;ritage</strong> entre nos objets. On dit que <code>CafetierePoudre</code> <em>h&eacute;rite</em> de <code>Cafetiere</code>, ou encore que <code>Cafetiere</code> est une <em>super-classe</em> de <code>CafetierePoudre</code></p>

<p>On  dit que la  classe <code>CafetiereSoluble</code> est
<em>d&eacute;riv&eacute;e</em>            de            <code>Cafetiere</code>,
<code>Cafetiere</code>  &eacute;tant une <em>classe  de  base</em>   par  rapport  &agrave;  <code>CafetiereSoluble</code>. et <code>CafetierePoudre</code>. <code>CafetiereSoluble</code> et <code>CafetierePoudre</code> sont en  quelque  sorte  des "sous-types"  de
<code>Cafetiere</code>,  de sorte que les variables     de    type
<code>CafetiereSoluble</code>  sont <em>aussi</em>  des  variables de  type
<code>Cafetiere</code>.   Les <code>CafetiereSoluble</code>  et <code>CafetierePoudre</code> sont donc des <em>sortes de</em>  Cafetiere, ils constituent une <em>extension</em> de <code>Cafetiere</code></p>

<h3 id="prot">Acc&egrave;s aux donn&eacute;es: la section protected</h3>

<p>Puisque <code>CafetiereSoluble</code> et <code>CafetierePoudre</code> &eacute;tendent le type <code>Cafetiere</code>, ils encapsulent des objets tels que <code>eau</code>, qui repr&eacute;sente le r&eacute;servoir d'eau, etc. Mais parce que ces objets sont d&eacute;clar&eacute;s dans la section <code>private</code> de <code>Cafetiere</code>, <code>CafetiereSoluble</code> ni <code>CafetierePoudre</code> n'auront acc&egrave;s &agrave; ces variables.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
 On  peut &ecirc;tre  surpris,  &agrave;  premi&egrave;re vue,  que  les classes  d&eacute;riv&eacute;es n'aient pas  acc&egrave;s &agrave; la section <code>private</code>  de leurs classes de bases...  et pourtant, c'est la moindre des choses:</p>

<ul>
  <li>Cela serait trop simple de "casser" le m&eacute;canisme d'encapsulation
      simplement en faisant une classe qui d&eacute;rive d'une autre... les
      sections  <code>private</code> n'auraient  d&egrave;s lors  plus aucune
      raison d'&ecirc;tre.</li>
  <li>Le plus souvent, <em>l'utilisateur d'une biblioth&egrave;que d'objets</em> 
      va d&eacute;river de nouveaux objets d'un objet de la
      biblioth&egrave;que. Or, il serait tr&egrave;s imprudent pour celui-ci
      d'utiliser des donn&eacute;es de la section <code>private</code>: en
      effet, celles-ci peuvent changer du jour au lendemain; seul
      l'interface est "garanti" par le concepteur de la biblioth&egrave;que.</li>
</ul>
</div>

<p>L'id&eacute;al   pour  une  classe  d&eacute;riv&eacute;e   est  donc  de
n'utiliser que  les fonctions-membres publiques de la  classe de base,
au  m&ecirc;me  titre  que  n'importe  quelle  autre  fonction.   Cependant,
certaines  fonctionnalit&eacute;s  ou  certaines  donn&eacute;es n'ont  pas  &agrave;  &ecirc;tre utilis&eacute;es par tout le monde,  mais seulement par les classes d&eacute;riv&eacute;es: ainsi  dans notre  cafeti&egrave;re, tous  les mod&egrave;les  de  cafeti&egrave;re doivent avoir acc&egrave;s  au r&eacute;servoir d'eau, mais les  <em>utilisateurs</em> de la
machine &agrave;  caf&eacute; n'ont pas  de raison, eux,  d'y avoir acc&egrave;s.   D'o&ugrave; la n&eacute;cessit&eacute; de cr&eacute;er  une nouvelle section: <code>protected</code>; tout ce qui sera d&eacute;clar&eacute; dans cette section sera utilisable par les classes d&eacute;riv&eacute;es,  <em>et  uniquement   par  elles</em>.   Ainsi,  dans  notre exemple, on  mettra dans <code>protected</code>  des fonctions d'acc&egrave;s aux &eacute;l&eacute;ments    constitutifs    de     la    machine     &agrave;    caf&eacute; (<code>verser_eau()</code>). On   consid&egrave;re   qu'une   bonne
conception doit respecter les r&egrave;gles suivantes:</p>

<div class="regle"><img alt="REGLE  D'OR"  src="diam.gif" />
<ul>
  <li>Dans la section <code>private</code>, se trouvent les donn&eacute;es
      encapsul&eacute;es par l'objet, ainsi que quelques fonctions membres correspondant au conctionnement interne de l'objet.</li>
  <li>Dans la section <code>protected</code>, ne se trouvent
      <b>que</b> des fonctions-membres. </li>
  <li>Dans la fonction <code>public</code>, ne se trouvent
      <b>que</b> des fonctions-membres</li>
</ul>
</div>

<p>Ainsi, il   est <em>toujours</em> possible de d&eacute;river une classe &agrave; partir d'une autre. La classe  d&eacute;riv&eacute;e aura toujours  acc&egrave;s aux fonctions publiques  de sa classe de base.  Mais  il est souhaitable  de   <em>pr&eacute;voir</em>  la   d&eacute;rivation,  en   d&eacute;finissant une  section <code>protected</code> "r&eacute;serv&eacute;e" aux classes d&eacute;riv&eacute;es.</p>


<h3 id="const">Constructeurs...</h3>

<p>En reprenant les classes d&eacute;finies ci-dessus, que se passe-t-il lorsqu'on &eacute;crit:</p>

<pre class="demo">
CafetiereSoluble ma_cafetiere;
</pre>

<p>Il se passe les choses suivantes:</p>

<ol>
  <li>Allocation de m&eacute;moire.<br />
  Autant d'octets que n&eacute;cessaire compte-tenu des champs de <code>CafetiereSoluble</code>
  <em>et</em> de a (ou ses) classes de base.</li>
  <li>Appel du <em>constructeur par d&eacute;faut</em> de <code>Cafetiere</code></li>
  <li>Appel du <em>constructeur par d&eacute;faut</em> de <code>CafetiereSoluble</code></li>
</ol>

<p>Autrement dit, tant qu'on travaille avec les constructeurs par d&eacute;faut, tout se passe bien: le syst&egrave;me se charge d'appeler les constructeur par d&eacute;faut des classes de base, dans le bon ordre.</p> 

<h3 id="copie"> Constructeur de copie: </h3>

<p>Mais lorsqu'on &eacute;crit:</p>

<pre class="demo">
CafetiereSoluble ta_machine = ma_machine;
</pre>

<p>il se passe:</p>

<ol>
  <li>Allocation de m&eacute;moire</li>
  <li>Appel du <em>constructeur par d&eacute;faut</em> de <code>Cafetiere</code></li>
  <li>Appel du <em>constructeur de copie</em> de <code>CafetiereSoluble</code></li>
</ol>

<p>ce qui est probablement un bogue: en effet, il aurait
&eacute;t&eacute;    pr&eacute;f&eacute;rable   d'appeler    le   constructeur    <em>de    copie</em>   de <code>Cafetiere</code> <em>Or, Le
compilateur   n'appellera  de   lui-m&ecirc;me  que   le   constructeur  par
d&eacute;faut</em>,  aussi  faut-il   lui  dire  <em>explicitement</em>  quel
constructeur   appeler.    Cela   peut   se  faire   dans   la   liste
d'initialisation de <code>CafetiereSoluble</code>:</p>

<pre class="demo">
class CafetiereSoluble: public Cafetiere {
public:
   <b>CafetiereSoluble(const CafetiereSoluble&amp; m) : Cafetiere(m) {...};</b>
...
}
</pre>

<p>L'expression <code>Cafetiere(m)</code> est correcte puisque  <code>m</code>   &eacute;tant   une CafetiereSoluble, <code>m</code> est <em>aussi</em> une <code>Cafetiere</code>.</p>


<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Si on utilise les contructeurs de copie par d&eacute;faut (c'est le cas, sauf lorsque l'on ne peut faire autrement), tout se passe bien: le probl&egrave;me arrive lorsqu'on <em>red&eacute;finit</em> un constructeur ce copie.</p></div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
En fait, cela fonctionne <em>parce que </em> le param&egrave;tre <code>m</code> est pass&eacute; par r&eacute;f&eacute;rence au constructeur de copie <a href="#virt-dest"><img alt="apres" src="apres.gif" /></a>. </p></div>

<h3 id="autres-const">Autres constructeurs</h3>

<p>rien n'emp&ecirc;che de d&eacute;finir sur <code>Cafetiere</code> un constructeur &agrave; qui on passe des param&egrave;tres, par exemple les quantit&eacute;s initiales d'eau, de sucre, ainsi que le nombre de gobelets et de cuillers:</p>

<pre class="demo">
class Cafetiere {
public:
   <b>Cafetiere(float e, int g, int c,float s) : eau(e), gobelets(g),<br /> cuillers(c), sucre() {};</b>
...
}
</pre>

<p>De m&ecirc;me, rien n'emp&ecirc;che de d&eacute;finir un constructeur pour <code>CafetiereSoluble</code>, &agrave; qui on donnera <em>en plus</em> la quantit&eacute; de caf&eacute; soluble &agrave; incorporer dans le r&eacute;servoir adhoc. L&agrave; encore, le syst&egrave;me ne <em>peut pas savoir</em> quel constructeur de la classe de base doit &ecirc;tre appel&eacute;: c'est donc <em>de la responsabilit&eacute; du constructeur de la classe d&eacute;riv&eacute;e d'appeler le constructeur de sa classe de base</em>, en utilisant la liste d'initialisation:</p>

<pre class="demo">
class CafetiereSoluble: public Cafetiere {
public:
   <b>CafetiereSoluble(float e, int g, int c,float s, float f) : 
   Cafetiere(e,g,c,s), cafe(c) {};</b>
...
}
class CafetierePoudre: public Cafetiere {
public:
   <b>CafetierePoudre(float e, int g, int c,float s, float f) : 
   Cafetiere(e,g,c,s), cafe(c) {};</b>
...
}</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
On ne peut pas initialiser directement les membres de la classe de base dans la classe d&eacute;riv&eacute;e: le code suivant: 
<pre class="demo"> 
CafetierePoudre(float e, int g, int c, float s, float f) : 
eau(e),gobelets(g),cuillers(c),sucre(s),
cafe(f){};
</pre> 
ne compilera pas, car <code>eau</code>, <code>gobelets</code>, <code>cuillers</code>, <code>sucre</code> sont des membres de la classe <code>Cafetiere</code>, <em>
pas </em> de <code>CafetierePoudre</code>. Il faut obligatoirement passer par un constructeur de <code>Cafetiere</code>.</p></div>

.<h3 id="dest">...et destructeurs</h3>

<p>Lorsqu'un objet de type <code>CafetiereSoluble</code> est d&eacute;truit, il
se passe la s&eacute;quence suivante:</p>

<ol>
  <li>Le destructeur de <code>CafetiereSoluble</code> est appel&eacute;</li>
  <li>Le destructeur de <code>Cafetiere</code> est appel&eacute;</li>
  <li>La m&eacute;moire est rendue au syst&egrave;me</li>
</ol>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
  Si   on  utilise  avec  des   pointeurs  ou  des
r&eacute;f&eacute;rences, on peut avoir quelques surprises, qui n&eacute;cessitent l'utilisation de destructeurs virtuels. <a href="#virt-dest"><img alt="apres" src="apres.gif" /></a>
</p></div>

<h3 id="poly">Le polymorphisme</h3>

<p>Observons le code ci-dessous, dans lequel on g&egrave;re
trois machines &agrave; caf&eacute;, de deux types diff&eacute;rents, par l'interm&eacute;diaire d'un tableau de pointeurs:</p>

<pre class="demo">
Cafetiere* machines[3];
machines[0] = new CafetiereSoluble(1.5,500,500,2,0.5);
machines[1] = new CafetiereSoluble(1.5,500,500,2,0.5);
machines[2] = new CafetierePoudre(1.5,500,500,2,0.9);

for (int i=0; i&lt;3; ++i) {
    if (machines[i]-&gt;lire_etat() == 1) {
       machines[i]-&gt;faire_le_cafe();
       encaisser_monnaie();
    };
};
</pre>

<p>Le code ci-dessus d&eacute;clare un tableau de trois objets de type pointeur sur <code>Cafetiere</code>, puis remplit le tableau avec deux machines &agrave; caf&eacute; soluble et une en poudre. Souvenez-vous que les fonctions <code>lire_etat</code> et <code>faire_le_cafe</code> ont &eacute;t&eacute; d&eacute;lar&eacute;es avec le mot-cl&eacute; <code><b>virtual</b></code>: ce mot signifie que le compilateur ne cherche pas &agrave; savoir exactement quelle fonction <code>lire_etat</code> sera appel&eacute;e, ni quelle fonction <code>faire_le_cafe()</code> sera appel&eacute;e, puisque l'allocation m&eacute;moire se fait de maniËre dynamique: il retient donc simplement qu'il devra appeler la version de la fonction <code>faire_le_cafe</code> <em>qui va bien</em>, en fonction du type d'objet qui sera appel&eacute; &agrave; l'ex&eacute;cution du programme. Le mot <em>polymorphisme</em> d&eacute;crit la propri&eacute;t&eacute; de ces deux fonctions d'adopter "plusieurs formes", suivant le contexte du programme. On parle aussi d'&eacute;dition de liens dynamique. Remarquons qu'une fois  de plus,  on  retrouve une
mani&egrave;re  de  penser  parfaitement  naturelle:  si je  vous  passe  une
casserole (classe de base) en vous demandant de la laver (fonction qui
op&egrave;re sur le  type g&eacute;n&eacute;rique casserole), je vous  passe en r&eacute;alit&eacute; une casserole bien particuli&egrave;re, et pas  toujours la m&ecirc;me (hier c'&eacute;tait le vieux chaudron &agrave; confiture qui  me vient de ma grand-m&egrave;re, aujourd'hui c'est une  casserole en  aluminium, dans les  deux cas il  s'agit d'un type de casserole particulier). Dans les deux cas vous allez la laver... mais suivant le type de casserole, vous vous y prendrez diff&eacute;remment. Par contre, la fonction <code><b>encaisser_monnaie</b></code> fait l'objet d'une &eacute;dition de liens statiques (il n'y a pas le mot <code>virtual</code> devant, donc il n'y a pas  ici de polymorphisme).</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> 
Lorsque vous red&eacute;finissez une fonction virtuelle, <b>la nouvelle
d&eacute;finition doit avoir la m&ecirc;me valeur de retour</b> que la fonction
originale. Sinon, le compilateur refusera votre code. Bien entendu, elles devront avoir &eacute;galement les m&ecirc;mes signatures, sinon il s'agit de deux fonctions diff&eacute;rentes, et le m&eacute;canisme d'&eacute;dition de liens dynamiques ne s'applique pas.</p></div></p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> Pourquoi les fonctions ne sont-elles pas automatiquement virtuelles ? C'est le cas dans d'autres langages orient&eacute;s objets, java par exemple. Le probl&egrave;me avec les fonctions virtuelles, c'est qu'elles sont moins performantes que les fonctions classiques. C'est normal: le m&eacute;canisme d'&eacute;dition de liens dynamiques est tr&egrave;s puissant, mais il a un co&ucirc;t. Donc, il est recommand&eacute; de ne les utiliser <em>que lorsque c'est n&eacute;cessaire</em>, et pas lorsque la performance est r&eacute;dhibitoire.</p></div>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
Si vous surchargez une fonction virtuelle, la fonction surcharg&eacute;e ne sera pas virtuelle 
automatiquement: il vous faut le sp&eacute;cifier explicitement.
</p></div>


<h2 id="abc">Classes de bases abstraites</h2>

<p>Le code suivant ne sera jamais compil&eacute;:</p>

<pre class="demo">
  cafetiere C1;
</pre>

<p>En effet, la  pr&eacute;sence des fonctions virtuelles pures <code>faire_le_cafe</code>   et   <code>lire_etat</code>  emp&ecirc;che   le
compilateur de g&eacute;n&eacute;rer un objet de type cafetiere. En d'autres termes, <em>on ne  peut  pas</em>  dire  au  compilateur  "donne-moi  de  la  m&eacute;moire  et initialise cette  cafeti&egrave;re".  Il veut  savoir <em>pr&eacute;cis&eacute;ment</em> de quoi il s'agit.  La classe <code>cafetiere</code> est une <em>classe de base abstraite</em>,  (c'est-&agrave;-dire une classe  qui a <em>au  moins une </em> fonction virtuelle pure). En tant que telle, on peut la passer en param&egrave;tres  <em>(par  r&eacute;f&eacute;rence ou par pointeur),mais <b>pas</b> par valeur</em> &agrave;  une  fonction,  mais on ne  peut  pas d&eacute;clarer d'objet de cette classe.</p>

<p>Ainsi, le code suivant ne pose aucun probl&egrave;me:</p>

<pre class="demo">
  cafetiere* C1;
</pre>

<p>En effet, il est toujours possible de d&eacute;clarer un pointeur sur une
classe abstraite. Le type <em>r&eacute;el</em> de la classe est pr&eacute;cis&eacute; lorsque le pointeur sera initialis&eacute;, le plus souvent en utilisant l'op&eacute;rateur <code>new</code>.<a href="mem.html#new"><img alt="apres" src="apres.gif" /></a>.</p>

<p>Le code suivant est utilisable &eacute;galement:</p>

<pre class="demo">
   void une_fonction(Cafetiere&amp; c) {...};
   
   CafetiereSoluble cs(1.5,500,500,2,0.5);
   CafetierePoudre cp(1.5,500,500,2,0.9);
   
   une_fonction(cs);
   une_fonction(cp);
</pre>

<p>Parce qu'on passe la variable par <em>r&eacute;f&eacute;rence</em> et pas par valeur, il est possible d'utiliser le polymorphisme, de m&ecirc;me qu'avec des pointeurs.</p>

<h3 id="virt-const">Constructeurs virtuels...</h3>

<p><em>&ccedil;a n'existe  pas</em>: le principe d'une fonction
virtuelle   est  que   la  fonction   <em>r&eacute;ellement</em>   appel&eacute;e  &agrave;
l'ex&eacute;cution  est   la  fonction  correspondant  au   type  de  l'objet
existant. Encore faut-il  que l'objet soit existant, ce  qui n'est pas
le cas lors de l'appel d'un constructeur.</p>

<h3 id="virt-dest">...et destructeurs virtuels</h3>

<p>l&agrave;, &ccedil;a existe: et c'est m&ecirc;me fort utile. En effet, le code suivant
risque d'entra&icirc;ner des r&eacute;sultats catastrophiques:</p>

<pre class="demo">
for (int i=0; i&lt;10; i++) {
    delete machines[i];
</pre>

<p>Le probl&egrave;me ici  est que <em>seul</em> le destructeur
de la  classe de  base a &eacute;t&eacute;  appel&eacute;. Si  le destructeur de  la classe
<code>modele_poudre</code> devait  faire quelque chose  de particulier
(rendre        la         m&eacute;moire        allou&eacute;e        pour        le
<code>reservoir_cafe_en_poudre</code>,  par exemple),  c'est  rat&eacute;. Le
destructeur n'a  pas &eacute;t&eacute;  appel&eacute;, et il  y a  un r&eacute;servoir &agrave;  caf&eacute; qui
tra&icirc;ne au  fond de la m&eacute;moire...   Il est donc  toujours pr&eacute;f&eacute;rable de
d&eacute;clarer   pour  la   classe  <code>cafetiere</code>   un  destructeur
virtuel... quitte &agrave; ce que celui-ci ne fasse rien:</p>

<pre class="demo">
class cafetiere {
  virtual ~cafetiere() {};
};
</pre>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
On pourrait
bien   s&ucirc;r  consid&eacute;rer   que  tous   les  destructeurs   doivent  &ecirc;tre
virtuels. Malheureusement,  d&eacute;clarer une fonction  virtuelle prend des
ressources... c'est  d'ailleurs pour cela que toutes  les fonctions ne
sont  pas  virtuelles.   G&eacute;n&eacute;ralement,   on  peut  consid&eacute;rer  que  la
d&eacute;claration de  la <em>premi&egrave;re</em> fonction virtuelle  prend pas mal
de  ressources,  les fonctions  suivantes  nettement  moins.  D'o&ugrave;  la
recommandation  suivante: <em>toute  classe abstraite,  ainsi  que les
classes qui  en d&eacute;rivent,  doivent avoir un  destructeur virtuel.</em>
Une  classe non  abstraite  ayant  peu ou  pas de  classes d&eacute;riv&eacute;es  le
destructeur   virtuel  a  moins   de  chances   d'&ecirc;tre  indispensable
</p></div>

<h3 id="virt-fct-const-dest">Appel de fonctions virtuelles depuis
le constructeur ou le destructeur</h3>

<p>L'exemple ci-dessous peut poser un probl&egrave;me:</p>

<pre class="demo">
class modele_poudre: public cafetiere {
public:
  modele_poudre() { ... lire_etat();};
}
    
class modele_grain: public modele_poudre {
public:
  modele_grain() { ...lire_etat();};
};

main() {
   modele_grain G;
}
</pre>

<p>En  effet, lors  de  la  construction  de la  classe
<code>modele_grain</code>,     c'est     le    <em>constructeur     de
<code>cafetiere</code>,  puis  celui de  <code>modele_grain</code></em>
qui  sont  appel&eacute;s  d'abord.   Or,  ce  dernier  appelle  la  fonction
virtuelle  <code>lire_etat()</code>.   Est-ce donc  la  version de  la
classe  d&eacute;riv&eacute;e   <code>modele_grain</code>  qui  sera  appel&eacute;e&nbsp;?
Surtout    pas:    lors   de    l'ex&eacute;cution    du   constructeur    de
<code>modele_poudre</code>,   la  partie   de  l'objet   sp&eacute;cifique  &agrave;
<code>modele_grain</code> n'est <em>pas encore</em> initialis&eacute;e...  on
risquerait donc d'avoir des  plantages ou autres erreurs inexpliqu&eacute;es.
D'o&ugrave; la  r&egrave;gle suivante:  c'est <em>la fonction  de la classe  de base
</em> (ici  la classe <code>modele_grain</code>) qui  sera appel&eacute;e par
le constructeur. Il en est de m&ecirc;me pour le destructeur.</p>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />Afin  de
clarifier le code (la r&egrave;gle ci-dessus est tout de m&ecirc;me assez subtile),
on  recommande   de  <em>qualifier  compl&egrave;tement</em>   les  fonctions
virtuelles  dans les  constructeurs ou  les destructeurs  en utilisant
l'op&eacute;rateur de port&eacute;e <code>::</code>. On &eacute;crirait donc :</p>

<pre class="demo">
class modele_grain: public modele_poudre {
public:
  modele_grain() {modele_grain::lire_etat();};
};
</pre></div>

<h3 id="affect">L'op&eacute;rateur d'affectation dans une classe de base</h3>

<p>Si         l'op&eacute;rateur         d'affectation
(<code>operator=()</code>)  d'une  classe  d&eacute;riv&eacute;e  doit  &ecirc;tre  d&eacute;fini
(c'est-&agrave;-dire si  l'op&eacute;rateur d'affectation fourni  par le compilateur
n'est  pas  suffisant),  celui-ci  <em>doit</em>  appeler  l'op&eacute;rateur
d'affectation  de sa  classe de  base: sinon,  <em>tous les  champs ne
seront pas copi&eacute;s  !!!</em>. Par contre, s'il n'est  pas n&eacute;cessaire de
d&eacute;finir  un  op&eacute;rateur   d'affectation  particulier  pour  une  classe
d&eacute;riv&eacute;e, le compilateur se chargera correctement d'appeler l'op&eacute;rateur
d'affectation de la classe de base.</p>

<pre class="demo">
class modele_grain: public modele_poudre {
public:
    modele_grain&amp;operator=(const modele_grain&amp;c) {
       modele_poudre::operator=(c);  // copie de la partie commune
       g = c.g;                      // copie du reservoir de caf&eacute; en grains
    };
}
</pre>

<h4 id="prot-affect">Prot&eacute;ger l'op&eacute;rateur d'affectation d'une
classe de base abstraite</h4>

<p>L'op&eacute;rateur d'affectation d'une classe de base
abstraite  doit  normalement &ecirc;tre  d&eacute;clar&eacute; <em>dans  une section
<code>protected</code></em>,  quitte &agrave;  d&eacute;clarer  un <code>operator=</code>
<em>uniquement   dans    ce   but</em>.    En    effet,   par   d&eacute;faut
l'<code>operator=</code> est  public. Mais pour  une classe abstraite,
cela risque  de conduire &agrave;  des catastrophes:</p>

<pre class="demo">
void f(cafetiere&amp;c1, const cafetiere&amp;c2) {
   c1 = c2;
};

main() {
  modele_capuccino P;
  modele_grain G;
  f (P,G);
}
</pre>

<p>Cela aboutit &agrave; &eacute;crire une &eacute;galit&eacute; entre une machine &agrave;
caf&eacute; en grains et une  machine &agrave; capuccino (caf&eacute; soluble+chocolat). Il
est  clair  que  cela  ne  peut pas  fonctionner...   et  pourtant  le
compilateur a b&ecirc;tement accept&eacute;. D'o&ugrave; le code suivant:</p>

<pre class="demo">
class cafetiere {
protected:
    void operator=(const cafetiere&amp;c);
}
</pre>

<p >L'op&eacute;rateur  =   &eacute;tant  d&eacute;clar&eacute;  dans  la  section
protected,  il peut  &ecirc;tre utilis&eacute;  par les  classes  d&eacute;riv&eacute;es, <em>mais il est inaccessible pour le reste du monde</em>. De sorte que
la fonction suivante:</p>

<pre class="demo">
void f(cafetiere&amp;c1, const cafetiere&amp;c2) {
   c1 = c2;
};
</pre>

<p>ne sera pas compil&eacute;e</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Lorsque
<code>op&eacute;rator=</code>   est  <code>protected</code>,  il   n'est  pas
n&eacute;cessaire  qu'il renvoie  quelque  chose, puisqu'il  ne sera  utilis&eacute;
<em>que</em>   indirectement  par   les  classes   d&eacute;riv&eacute;e.   D'o&ugrave;  le
<code>void</code> comme type de retour de la fonction.</p></div>

<p><a href="#">top</a></p><hr /> 

<h2 id="mult">L'h&eacute;ritage multiple</h2>

<p>Il est possible, bien que d'une utilisation d&eacute;licate, de d&eacute;clarer qu'une classe d&eacute;rive de plusieurs superclasses. L'utilisation la plus int&eacute;ressante de l'h&eacute;ritage multiple est la d&eacute;finition d'interfaces:</p>

<h3 class="obs">Impl&eacute;mentation du "pattern" observateur en utilisant l'h&eacute;ritage multiple</h3>

<p>Imaginons la situation suivante, extr&ecirc;mement courante:</p>

<ul>
  <li>Un objet de type <code>traitement</code> appelle la fonction-membre <code>run()</code>, qui dure plusieurs minutes.</li>
  <li>Cet objet fait partie d'une cha&icirc;ne d'h&eacute;ritage, c'est-&agrave;-dire qu'il h&eacute;rite d'un autre objet, ainsi qu'il a paru judicieux au concepteur de la cha&icirc;ne de traitement de concevoir la chose.</li>
  <li>Cet objet est utilis&eacute; tant&ocirc;t dans un contexte graphique, en gr&acirc;ce &agrave; tel ou tel "framework" graphique, ou encore dans un contexte "console": on souhaite que, quelque soit le contexte, il soit possible d'afficher r&eacute;guli&egrave;rement l'&eacute;tat d'avancement de la t&acirc;che, et ce sans introduire de d&eacute;pendances entre l'objet <code>traitement</code> et un framework particulier.</li>
</ul>

<p>Le pattern observateur permet de r&eacute;pondre &agrave; ce cahier des charges:</p>

<p class="UML"><img alt="diagramme UML" src="heritage/observateur.png"></p>
<pre class="demo">
<b>class Observateur</b> {
    public:
    virtual void update(float r) = 0;
};
<b>class Diffuseur</b> {
   public:
   void notifier(float r) {
        for(int i=0;i&lt;abonnes.length();i++) {
            abonnes[i]-&gt;update(r);
        };
   };
   void abonne(Observateur * o) {
       if (o!=NULL)
          abonnes.push_back(o);
   };
   private:
      vector&lt;Observateur*&gt;abonnes;
};

<b>class Traitement: public BaseTraitement, public Diffuseur</b> {
   public:
      void run() {
          while(...) {
               ...
               notifier(x);
          };
      };
}

<b>class ProgressionBar: public ProgressionBarWidget, public Observateur</b> {
    public:
        virtual void update(float r) {
           ...
        };
};
</pre>

<p>Une fois n'est pas coutune, vous pouvez <a href="heritage/pattern_observateur.tgz">t&eacute;l&eacute;charger ici</a> un petit programme que vous devriez pouvoir compiler. On voit que:</p>

<ul>
   <li>La classe <code>Diffuseur</code> comprend une fonction <code>abonne</code>, qui permettra &agrave; des objets d&eacute;rivant de la classe <code>Observateur</code> de s'abonner, afin d'&ecirc;tre notif&eacute;s d'un &eacute;v&eacute;nement quelconque.</li>
   <li>La classe <code>Traitement</code> d&eacute;rive de la classe <code>Diffuseur</code>, elle pourra donc appeler la fonction <code>notifier</code>. Celle-ci appelle <code>update</code> sur tous ses abonn&eacute;s. Comme seuls des objets d&eacute;rivant de <code>Observateur</code> peuvent s'abonner, elle est s&ucirc;re de trouver cette fonction impl&eacute;ment&eacute;e.</li>
   <li>La classe <code>Observateur</code> ne comprend qu'une seule fonction virtuelle pure (<code>void update(float)</code>), <em>c'est donc une classe interface</em>.</li>
   <li>La classe <code>ProgressionBar</code> d&eacute;rive de <code>Observateur</code>, elle devra donc imp&eacute;menter la fonction <code>update</code>, ce qui lui permettra d'&ecirc;tre notifi&eacute;e en temps utile.</li>
   <li><code>ProgressionBar</code> et <code>Traitement</code> d&eacute;rivent par ailleurs d'autres classes, suivant la mani&egrave;re dont l'application a &eacute;t&eacute; con&ccedil;ue: elles utilisent donc l'h&eacute;ritage multiple.</li>
</ul>


<h4><img alt="Les autres ?" src="dechirure.gif"  width="25" />
Autres langages objets...</h4>

<table class="tableau">
  <tr>
    <th> Langage </th>
    <th> H&eacute;ritage </th>
    <th> mot-cl&eacute; virtual </th>
    <th> Classe abstraite </th>
    <th> H&eacute;ritage multiple </th>
  </tr>
  <tr>
    <td><b>C++</b> </td>
    <td><b>OUI</b></td><td><b>OUI</b></td><td><b>OUI</b></td><td><b>OUI</b></td>
  </tr>
  <tr>
    <td><b>perl</b></td>
    <td><b>OUI<sup>(1)</sup></b></td><td>NON<sup>(3)</sup></td><td><b>Possible <sup>(6)</sup></b></td><td><b>OUI</b></td>
  </tr>
  <tr>
    <td><b>java</b></td>
    <td><b>OUI<sup>(2)</sup></b></td><td>NON<sup>(3)</sup></td><td><b>OUI <sup>(4)</sup></b></td><td>NON<sup>(5)</sup></td>
  </tr>
  <tr>
    <td><b>python</b></td>
    <td><b>OUI</b></td><td>NON<sup>(3)</sup></td><td><b>Possible <sup>(6)</sup></b></td><td>NON<sup>(5)</sup></td>
  </tr>
</table>

<ol>
  <li>Utilisation du tableau <code>@ISA</code> (Est une sorte de)</li>
  <li>Mot-cl&eacute; <code>extends</code> (&eacute;tendre les fonctionnalit&eacute;s de)</li>
  <li>En java, toutes les fonctions sont des fonctions virtuelles</li>
  <li>On d&eacute;finit une classe abstraite et on sp&eacute;cifie les fonctions qui doivent
  &ecirc;tre red&eacute;finies, par le mot-cl&eacute; <code>abstract</code></li>
  <li>Mais les mots-cl&eacute;s <code>interface</code> et
      <code>implementation</code> correspondent aux m&ecirc;mes
      fonctionnalit&eacute;s que l'h&eacute;ritage multiple.</li>
  <li>Pour d&eacute;finir une classe abstraite en perl ou en python, il
  suffit de s'arranger pour que certaines fonctions (les
  "fonctions membres virtuelles pures") g&eacute;n&egrave;rent une exception.</li>
</ol>



<p><a href="#">top</a></p><hr /> 
<address><a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>
<p>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>
</div></body> </html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
<meta http-equiv="Content-Language" content="fr" />
<title>Introduction au C++ et &agrave; la programmation objet</title>
<meta name="description" content="Initiation au C++ ; " />
<meta name="keywords" content="Cours, d&eacute;veloppement, programmation orient&eacute;e objets, C++, bioinformatique" />
<script type="text/javascript" src="cours.js"></script>
<!--<link rel="stylesheet" type="text/css" href="cours.css" />-->
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  //<![CDATA[
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  //]]>
  </script>
<style type="text/css" media="screen">
    @import url(cours.css);
</style>
<style type="text/css" media="print">
    @import url(coursprint.css);
</style>
</head>
<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<dl>  
 <dt><a href="index.html" onmouseover="javascript:montre('smenu1')" title="sommaire">Sommaire</a></dt>
 <dd id="smenu1" onmouseout="javascript:montre('smenu1',-1)">
 <ul>
    <li><strong><a onclick="javascript=cacher_menu()" href="#intro">Introduction</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#progobj">La programmation objet</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#types">Les types de base</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#surch">Surcharger fonctions et op&eacute;rateurs</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#heritage">H&eacute;ritage</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#modeles">Mod&egrave;les (&quot;templates&quot;)</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#excep">Exceptions</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#mem">Gestion de la m&eacute;moire</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#stdlib">La biblioth&egrave;que standard</a></strong></li>
    <li><strong><a onclick="javascript=cacher_menu()" href="#ref">R&eacute;f&eacute;rences et autres liens</a></strong></li> 
 <li><strong><a onclick="javascript=cacher_menu()" href="#exos">Exercices</a></strong></li> </ul>
    </dd>
</dl>
<dl>
 <dt><a onclick="javascript=cacher_menu()" href="exos.html" title="Les exercices">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>

</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1>Introduction au C++ et &agrave; la programmation objet </h1>

<p style="text-align: center;text-indent:0"><strong>Version 1.80</strong><br /><em>(Octobre 2006)</em></p>

<ul>
	<li id="intro"><strong><a href="intro.html">Introduction</a></strong>
	<ul>
		<li><a href="intro.html#copyleft">Avertissement</a></li>
		<li><a href="intro.html#symboles">Symboles et conventions</a></li> 
		<li><a href="intro.html#impasses">Impasses</a></li>
		<li><a href="intro.html#historique">Un peu d'histoire</a></li>
		<li><a href="intro.html#java">Et java dans tout &ccedil;a ?</a></li>
	</ul></li>
	<li id="progobj"><strong><a href="progobj.html">La programmation objet</a></strong> 
	<ul>
		<li><a href="progobj.html#probl">Poser un probl&egrave;me</a></li> 
		<li><a href="progobj.html#prog">La programmation objets expliqu&eacute;e aux programmeurs</a> 
		<ul>
			<li><a href="progobj.html#proc">L'approche proc&eacute;durale</a>
			<ul>
				<li><a href="progobj.html#fonct">Qu'est-ce qu'une fonction ?</a></li> 
				<li><a href="progobj.html#loca-glo">Variables locales ou globales</a></li> 
			</ul></li>
			<li><a href="progobj.html#modul">Approche modulaire:</a> 
			<ul>
				<li><a href="progobj.html#interf">Interface publique...</a></li> 
				<li><a href="progobj.html#impl">...Impl&eacute;mentation cach&eacute;e</a></li> 
				<li><a href="progobj.html#encaps">Encapsulation des donn&eacute;es</a></li> 
				<li><a href="progobj.html#proto">Prototypage</a></li>
			</ul></li>
			<li><a href="progobj.html#obj">Approche objets:</a> 
			<ul>
				<li><a href="progobj.html#obj-typ">Des
				objets int&eacute;gr&eacute;s au syst&egrave;me de typage</a></li> 
				<li><a href="progobj.html#class-obj">Classer les objets</a></li> 
				<li><a href="progobj.html#piles">D&eacute;finir des piles de n'importe quoi</a></li> 
				<li><a href="progobj.html#heritcor">Faire du neuf avec du vieux</a> </li>
				<li><a href="progobj.html#biblio">Des biblioth&egrave;ques d'objets</a></li> 
			</ul></li>
		</ul></li>
		<li><a href="progobj.html#normaux">La programmation objets expliqu&eacute;e aux gens normaux</a> 
		<ul>
			<li><a href="progobj.html#cafeteria">Une caf&eacute;t&eacute;ria informatis&eacute;e</a></li> 
			<li><a href="progobj.html#cafproc">Le caf&eacute; en programmation proc&eacute;durale</a></li>
			<li><a href="progobj.html#cafobj">Le caf&eacute; en programmation objet</a>
			<ul>
			    <li><a href="progobj.html#cafmodele">Mod&eacute;liser une cafeti&egrave;re</a></li>
			    <li><a href="progobj.html#cafecekoi">qu'est-ce qu'une cafeti&egrave;re&nbsp;?</a></li>
			    <li><a href="progobj.html#cafesortes">Une cafeti&egrave;re est une cafeti&egrave;re, mais il y en a plusieurs sortes</a></li>
			    <li><a href="progobj.html#boutons">boutons marche-arr&ecirc;t ou autres r&eacute;glages</a></li>
			    <li><a href="progobj.html#voyants">Voyants</a></li>
			    <li><a href="progobj.html#cafemain">Programme principal</a></li>
			    <li><a href="progobj.html#robusta">Des programmes plus robustes</a></li>
			</ul></li>
		</ul></li>
		<li><a href="progobj.html#obj-classes">Classes et objets</a>
		   <ul>
		      <li><a href="progobj.html#obj-etat">L'&eacute;tat d'un objet</a></li>
		      <li><a href="progobj.html#obj-comp">Le comportement d'un objet</a></li>
		      <li><a href="progobj.html#obj-id">L'identit&eacute; d'un objet</a></li>
		      <li><a href="progobj.html#obj-met">Des objets "m&eacute;tiers"</a></li>
		      <li><a href="progobj.html#obj-rel">Relations entre objets</a></li>
		   </ul></li>
	</ul></li>
	<li id="types"><strong><a href="types.html">Les types de base</a></strong> 
	<ul>
		<li><a href="types.html#type-base">D&eacute;clarations de variables</a></li> 
		<li><a href="types.html#type-predef">Les types pr&eacute;d&eacute;finis</a>
		<ul>
			<li><a href="types.html#bool">Le type <code>bool</code></a></li> 
			<li><a href="types.html#char-num">Les types <code>char</code> ou num&eacute;riques</a></li> 
			<li><a href="types.html#void">Le type <em>void</em></a></li> 
			<li><a href="types.html#struct">Les types <code>struct</code> et <code>union</code></a></li>
		</ul></li>
		<li><a href="types.html#ptr-ref-const">Pointeurs (*), r&eacute;f&eacute;rences (&amp;), descripteur const</a></li> 
		<li><a href="types.html#ptr-ana">Analogies avec le monde dit &quot;r&eacute;el&quot;</a>
		<ul>
		   <li><a href="types.html#clonage">Initialisation = Cl&ocirc;nage</a></li>
		   <li><a href="types.html#ptr-egal">Op&eacute;rateur= : Je me prends pour un autre</a></li>
		   <li><a href="types.html#ptr-surnom">R&eacute;f&eacute;rences = Surnoms</a></li>
		   <li><a href="types.html#ptr-ptr">Pointeurs = Attention, on vous montre du doigt</a></li>
		   <li><a href="types.html#ptr-prmval">Passage des param&egrave;tres par valeur</a></li>
		   <li><a href="types.html#ptr-prmref">Passage du client par r&eacute;f&eacute;rence</a></li>
		   <li><a href="types.html#ptr-prmconstref">Passage du coiffeur par const r&eacute;f&eacute;rence</a></li>
		   <li><a href="types.html#ptr-retval">Retour d'un param&egrave;tre par valeur</a></li>
		   <li><a href="types.html#ptr-retref">Retour d'un param&egrave;tre par r&eacute;f&eacute;rence</a></li>
		   <li><a href="types.html#ptr-retptr">Retour d'un param&egrave;tre par pointeur</a></li>
		</ul></li>
		<li><a href="types.html#ptr-virt">Retour au monde virtuel</a>
		<ul>
			<li><a href="types.html#ref">Le type r&eacute;f&eacute;rence</a></li> 
			<li><a href="types.html#ptr">Le type pointeur</a></li> 
			<li><a href="types.html#ref-pourquoi">Une r&eacute;f&eacute;rence, pour quoi faire ?</a></li> 
			<li><a href="types.html#desc-const">Le descripteur const</a></li> 
		</ul></li>
		<li><a href="types.html#class">Le type class</a> 
		<ul>
			<li><a href="types.html#priv-prot-pub">Sections priv&eacute;es, prot&eacute;g&eacute;es, publiques</a></li> 
			<li><a href="types.html#pub">Section public </a></li>
			<li><a href="types.html#prot">Section protected</a></li> 
			<li><a href="types.html#fct-memb">Fonctions membres </a></li>
			<li><a href="types.html#fct-amies">Fonctions amies</a></li> 
			<li><a href="types.html#acces-donn">Acc&egrave;s aux donn&eacute;es</a></li> 
			<li><a href="types.html#construct">Constructeurs</a></li>
			<li><a href="types.html#destruct">Destructeur</a></li>
			<li><a href="types.html#static">Le descripteur <code>static</code></a></li> 
			<li><a href="types.html#const">Le descripteur const</a></li> 
			<li><a href="types.html#this">Le pointeur *this</a></li> 
		</ul></li>
	</ul></li>
	<li id="surch"><strong><a href="surch.html">Surcharger fonctions et op&eacute;rateurs</a></strong> 
	<ul>
		<li><a href="surch.html#existant">Modifier une fonction sans remettre en cause l'existant</a> 
		<ul>
			<li><a href="surch.html#decl-def">D&eacute;claration et d&eacute;finition de fonctions</a></li> 
			<li><a href="surch.html#surch-fonc">Surcharge de fonctions</a></li> 
			<li><a href="surch.html#surch-construc">Le constructeur de copie</a></li> 
			<li><a href="surch.html#valdef">Valeurs par d&eacute;faut des arguments</a></li> 
			<li><a href="surch.html#valdef-construc">Valeurs par d&eacute;faut et constructeurs</a></li> 
		</ul></li>
		<li><a href="surch.html#surch-op">Surcharger les op&eacute;rateurs</a> 
		<ul>
			<li><a href="surch.html#ope-fonc">Op&eacute;rateurs et fonctions</a></li> 
			<li><a href="surch.html#ope-plus">Les quatre op&eacute;rations</a></li> 
			<li><a href="surch.html#ope-incr">Les op&eacute;rateurs d'incr&eacute;mentation ou d&eacute;cr&eacute;mentation</a></li>
			<li><a href="surch.html#ope-affec">L'op&eacute;rateur d'affectation</a></li> 
			<li><a href="surch.html#conv-ope">Conversions et op&eacute;rateurs</a></li> 
			<li><a href="surch.html#autres-ope">Autres op&eacute;rateurs</a></li> 
		</ul></li>
	</ul></li>
	<li id="heritage"><strong><a href="heritage.html">H&eacute;ritage</a></strong>	
	<ul>
		<li><a href="heritage.html#abstraites">Classes abstraites...</a></li> 
        <li><a href="heritage.html#concretes">...Classes concr&ecirc;tes</a> 
		<ul>
			<li><a href="heritage.html#prot">Acc&egrave;s aux donn&eacute;es: la section protected</a></li> 
			<li><a href="heritage.html#const">Constructeurs...</a></li>
			<li><a href="heritage.html#copie">Le constructeur de copie</a></li>
			<li><a href="heritage.html#autres-const">Autres constructeurs</a></li>
			<li><a href="heritage.html#dest">...et destructeurs</a></li> 
			<li><a href="heritage.html#poly">Le polymorphisme</a></li>
		</ul></li>
        <li><a href="heritage.html#abc">Classes de bases abstraites</a>
        <ul>
			<li><a href="heritage.html#virt-const">Constructeurs virtuels...</a></li> 
			<li><a href="heritage.html#virt-dest">...et destructeurs virtuels</a></li> 
			<li><a href="heritage.html#virt-fct-const-dest">Appel de fonctions virtuelles depuis le constructeur ou le destructeur</a></li>
			<li><a href="heritage.html#affect">L'op&eacute;rateur d'affectation dans une classe de base</a></li> 
		</ul></li>
        <li><a href="heritage.html#mult">L'h&eacute;ritage multiple</a>
        <ul>
        <li><a href="heritage.html#mult">Impl&eacute;mentation du "pattern" observateur en utilisant l'h&eacute;ritage multiple</a></li>
        </ul></li>
	</ul></li>
	<li id="modeles"><strong><a href="modeles.html">Mod&egrave;les (&quot;templates&quot;)</a></strong> 
	<ul>
		<li><a href="modeles.html#class-param">Classes param&eacute;tr&eacute;es</a> 
		<ul>
			<li><a href="modeles.html#def-class-param">D&eacute;finition</a></li>			
			<li><a href="modeles.html#instant">Instantiation</a></li>			
			<li><a href="modeles.html#param-util">Param&egrave;tres	utilisables</a></li> 
		</ul></li>
		<li><a href="modeles.html#modele-fct">Mod&egrave;les de fonctions</a></li> 
		<li><a href="modeles.html#modele-spe">Sp&eacute;cialisation</a></li>
		<li><a href="modeles.html#conseils">Quelques conseils</a></li> 
	</ul></li>
	<li id="excep"><strong><a href="excep.html">Exceptions</a></strong>	
	<ul>
		<li><a href="excep.html#erreur">Que faire en cas d'erreur ?</a></li> 
		<li><a href="excep.html#poste">Une analogie avec la vie courante</a></li> 
		<li><a href="excep.html#excep">Le syst&egrave;me d'exceptions</a> 
		<ul>
			<li><a href="excep.html#hier">Les hi&eacute;rarchies d'objets exceptions</a></li> 
			<li><a href="excep.html#decl">La d&eacute;claration de fonction</a></li> 
			<li><a href="excep.html#gene">La g&eacute;n&eacute;ration d'exception</a></li> 
			<li><a href="excep.html#capt">La capture des exceptions</a></li> 
			<li><a href="excep.html#noncapt">Exceptions non captur&eacute;es</a></li> 
		</ul></li>
		<li><a href="excep.html#excepet">Exceptions et ...</a> 
		<ul>
			<li><a href="excep.html#const">...constructeurs</a></li>			
			<li><a href="excep.html#dest">...destructeurs</a></li>
		</ul></li>
	</ul></li>
	<li id="mem"><strong><a href="mem.html">Gestion de la m&eacute;moire</a></strong> 
	<ul>
		<li><a href="mem.html#alloc-dynam">Qu'est-ce que l'allocation dynamique de m&eacute;moire? </a>
		<ul>
			<li><a href="mem.html#pile-tas">Pointeurs empil&eacute;s, objets entass&eacute;s</a></li> 
			<li><a href="mem.html#fuite-mem">Objets perdus et fuites de m&eacute;moire</a></li> 
			<li><a href="mem.html#dangling">Les pointeurs qui pendouillent</a></li> 
			<li><a href="mem.html#proprio">Propri&eacute;taires et r&eacute;f&eacute;rents</a></li> 
		</ul></li>
		<li><a href="mem.html#oper">Op&eacute;rateurs et fonctions</a> 
		<ul>
			<li><a href="mem.html#new">Les op&eacute;rateurs <code>new</code> et <code>delete</code></a></li>
			<li><a href="mem.html#new-tab">Les op&eacute;rateurs <code>new[]</code> et <code>delete[]</code></a></li>
			<li><a href="mem.html#malloc">Fonctions malloc, free, realloc</a></li> 
		</ul></li>
		<li><a href="mem.html#obj">Objets utilis&eacute;s pour la gestion de la m&eacute;moire</a> 
		<ul>
			<li><a href="mem.html#auto_ptr">L'objet <code>auto_ptr</code></a></li> 
			<li><a href="mem.html#gest">Objets gestionnaires de ressources</a></li> 
			<li><a href="mem.html#robuste">Produire du code robuste, malgr&eacute; les exceptions</a></li> 
			<li><a href="mem.html#compt">Les objets &agrave; comptage de r&eacute;f&eacute;rence</a></li> 
		</ul></li>
	</ul></li>
	<li id="stdlib"><strong><a href="stdlib.html">La biblioth&egrave;que standard</a></strong> 
	<ul>
		<li><a href="stdlib.html#compl">Compl&eacute;ments sur le langage</a> 
		<ul>
			<li><a href="stdlib.html#namespace">Les espaces de noms</a></li> 
			<li><a href="stdlib.html#localtype">Les types locaux</a></li> 
			<li><a href="stdlib.html#typename">L'instruction <code>typename</code></a></li> 
		</ul></li>
	<li><a href="stdlib.html#conteneurs">Les conteneurs</a> 
		<ul>
			<li><a href="stdlib.html#contobjptr">Conteneurs	d'objets ou conteneurs de pointeurs ?</a></li> 
			<li><a href="stdlib.html#contseqass">Conteneurs s&eacute;quentiels et conteneurs associatifs (ordonn&eacute;s)</a></li> 
			<li><a href="stdlib.html#constd">Les conteneurs de la biblioth&egrave;que standard</a></li> 
			<li><a href="stdlib.html#typecont">Types d&eacute;finis sur les conteneurs</a></li> 
			<li><a href="stdlib.html#fctopcont">Quelques fonctions-membres ou op&eacute;rateurs</a></li> 
			<li><a href="stdlib.html#string">string: les cha&icirc;nes de caract&egrave;res</a></li>
		</ul></li>
	<li><a href="stdlib.html#iterateurs">Les it&eacute;rateurs</a>
	<ul>
	   <li><a href="stdlib.html#it-val">It&eacute;rateurs valides et invalides</a></li>
	   <li><a href="stdlib.html#it-cat">Les diff&eacute;rentes cat&eacute;gories d'it&eacute;rateurs</a></li>
	   <li><a href="stdlib.html#it-int">Sp&eacute;cifier un intervalle &agrave; l'aide de deux it&eacute;rateurs</a></li>
	</ul></li>
        <li><a href="stdlib.html#kikoi">Qui fait quoi ?</a></li> 
        <li><a href="stdlib.html#algo">Algorithmes</a></li>
        <li>
           <ul><li><a onclick="javascript=cacher_menu()" href="stdlib.html#tri">Trier un conteneur</a></li>
           <li><a onclick="javascript=cacher_menu()" href="stdlib.html#listes">Manipuler des listes</a></li>
           </ul></li>
	<li><a href="stdlib.html#stream">Les entr&eacute;es-sorties</a>
	<ul>
	   <li><a href="stdlib.html#io-stream">Les objets de type ostream ou istream</a></li>
	   <li><a href="stdlib.html#io-bin">Lecture-&eacute;criture en binaire</a></li>
	   <li><a href="stdlib.html#io-get">Fonctions get, put, getline</a></li>
	   <li><a href="stdlib.html#stream-fmt">Entr&eacute;es-sorties formatt&eacute;es:  &lt;&lt; et &gt;&gt;</a></li>
	   <li><a href="stdlib.html#ctrl-fmt">Le contr&ocirc;le du format</a></li>
	   <li><a href="stdlib.html#io-sts">Ecrire... ou lire l'&eacute;tat du flot</a></li>
	   <li><a href="stdlib.html#sortie-surch">Surcharger l'op&eacute;rateur &lt;&lt;</a></li>
	   <li><a href="stdlib.html#entree-surch">Surcharger l'op&eacute;rateur &gt;&gt;</a></li>
	   <li><a href="stdlib.html#ite-stream">Les it&eacute;rateurs de flots</a></li>
	   <li><a href="stdlib.html#io-conten">Remplir un conteneur &agrave; partir d'un fichier</a></li>
	</ul></li>
	<li id="ref"><strong><a href="ref.html">R&eacute;f&eacute;rences et autres liens</a></strong></li> 
	<li id="exos"><strong><a href="exos.html">Exercices</a></strong></li> 
</ul></li></ul>
<hr />
<address>
<img alt="xhtml" src="xhtml.png" />
<a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle
&lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  //<![CDATA[
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  //]]>
  </script>
  <style type="text/css">
  #symboles dd {margin: 1em;}
  #symboles .mdemo {margin: 0 .3em;}
  #javadl dt { font-style:italic;}
  </style>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Introduction</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!-- <dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl> -->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
 <dd id="smenu1">
    <ul>
		<li><a onclick="javascript=cacher_menu()" href="intro.html#copyleft">Avertissement</a></li>
		<li><a onclick="javascript=cacher_menu()" href="intro.html#symboles">Symboles et conventions</a></li> 
		<li><a onclick="javascript=cacher_menu()" href="intro.html#impasses">Impasses</a></li>
		<li><a onclick="javascript=cacher_menu()" href="intro.html#historique">Un peu d'histoire</a></li>
		<li><a onclick="javascript=cacher_menu()" href="intro.html#java">Et java dans tout &ccedil;a ?</a></li>
    </ul>
 </dd>
</dl>
<dl>
 <dt><a href="exos.html#pointeurs" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">

<h1>Introduction</h1>
  <!--<p><i>Ce cours fait partie du cursus du <b><a href="http://www.adbt.com">D.E.S.S. de bioinformatique</a></b>
  de l'Universit&eacute; Paul Sabatier</i></p>-->

<h2><a id="copyleft">A propos de ce cours</a></h2>

<p> Vous pouvez <a href="ftp://ftp.toulouse.inra.fr/pub/c_plus_plus">t&eacute;l&eacute;charger</a>
l'ensemble des fichiers constituant ce cours. Vous pourrez alors l'installer sur votre machine personnelle et le lire avec tout navigateur. Il vous suffira d'ouvrir le fichier <code>index.html</code></p>

<p>Vous pouvez aussi installer ce cours sur votre serveur web, mais dans ce cas merci de commencer par lire le fichier
  <a href="LISEZ-MOI"> LISEZ-MOI</a>, et surtout de <i>ne rien modifier</i> sans mon accord.</p>

<p>Si vous trouvez des inexactitudes, ou si vous avez des id&eacute;es d'am&eacute;liorations, merci de me contacter.</p>
  
<h2><a id="symboles">Symboles et conventions utilis&eacute;s dans ce cours</a></h2>
 
<dl id="symboles">
<dt><span class="mdemo"><a href="exos.html">Exercices</a></span></dt>
<dd>Au boulot !!! Cliquez sur cette rubrique du menu et vous aurez quelques sujets d'exercices. Parmi eux, certains sont corrig&eacute;s. Dans ce cas, promis-jur&eacute;, j'ai r&eacute;ussi &agrave; compiler et &agrave; ex&eacute;cuter le programme, au moins avec gcc.</dd>

<dt><span class="mdemo"><a href="http://www.cplusplus.com/ref/">iostream</a></span></dt>
<dd>Les entr&eacute;es-sorties: elles seront d&eacute;crites au 
<a href="stdlib.html#stream">dernier chapitre</a> de ce cours, mais cette rubrique pointe sur une documentation de r&eacute;f&eacute;rence
(en Anglais).</dd>

<dt><span class="mdemo"><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></span></dt>
<dd>La biblioth&egrave;que standard contient plusieurs structures de donn&eacute;es extr&egrave;mement utiles. Ce pointeur envoie sur une documentation de r&eacute;f&egrave;rence de la STL (en Anglais)</dd>

<dt><span class="mdemo"><a href="http://www.boost.org/">BOOST</a></span></dt>
<dd>Avant de programmer, allez donc voir si le projet BOOST n'aurait pas un objet tout fait &agrave; vous proposer!</dd>
</dl>

<hr class="nofloat" />
<p> <img src="61.gif" alt="Pour les terriens"
  width="20" />Cliquez l&agrave;-dessus pour acc&eacute;der &agrave; une page
destin&eacute;e aux terriens normaux, qui vous donnera des explications plus
simples &agrave; comprendre, en particulier
gr&acirc;ce &agrave; des analogies avec le monde r&eacute;el.</p>

  <p>Il y a des exemples de code dans le cours. Je
ne garantis pas qu'ils fonctionnent, tout simplement parce qu'ils sont
pour la plupart incomplets, ou sont du "pseudo-code" plut&ocirc;t que du
code r&eacute;el. Regardez les exercices si vous voulez du code
qui fonctionne pour de vrai.</p>

  <p> Peut-&ecirc;tre voudrez-vous mettre en pratique les
notions expliqu&eacute;es, sans obligatoirement regarder le corrig&eacute; des
exercices. Dans ce cas, il vous faut savoir &eacute;crire un programme C++
minimum, par exemple celui qui &eacute;crit <code>hello world</code> sur
l'&eacute;cran. </p>

<pre class="demo">#include &lt;iostream&gt;
using namespace std;

main() {
    cout &lt;&lt; "Hello world" &lt;&lt; endl;
    cerr &lt;&lt; "Hello buggy world" &lt;&lt; endl;
};</pre>

  <p>Il s'agit d'instructions d'entr&eacute;es-sorties. La
premi&egrave;re &eacute;crit sur la sortie standard, la seconde sur l'erreur
standard. Les deux premi&egrave;res lignes vous permettent d'utiliser la
biblioth&egrave;que standard. Prenez-les pour l'instant comme des formules
magiques, ce n'est qu'&agrave; la fin du cours que vous comprendrez
r&eacute;ellement de quoi il retourne <a href="stdlib.html"><img class="noprint" alt="apres"
 src="apres.gif" /></a>
  </p>
  
  <div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Le C++ 
est un langage tr&egrave;s simple &agrave; apprendre (mais si...) mais il y a
tout-de-m&ecirc;me quelques difficult&eacute;s. Celles-ci sont indiqu&eacute;es comme ce
paragraphe-ci.</p></div>

<div class="regle"><p><img alt="REGLE     D'OR" src="diam.gif" />Certaines
r&egrave;gles, dites "r&egrave;gles d'or", sont plut&ocirc;t des
r&egrave;gles de bon usage que des r&egrave;gles impos&eacute;es par le
compilateur. Elles sont indiqu&eacute;es comme ceci.</p></div>

<div class="autres"><p><img alt="Les autres ?" src="dechirure.gif"
 width="20" />Et chez les autres, comment &ccedil;a se dit ?
Derri&egrave;re cette ic&ocirc;ne sont regroup&eacute;es quelques comparaisons avec
d'autres langages objets:
certaines notions se retrouvent (mais se disent diff&eacute;remment), alors
que d'autres notions sont absentes de certains langages.</p></div>

  <p><a class="noprint" href="#">top</a></p><hr />
  <h2><a id="impasses">Impasses...</a></h2>

  <p>J'ai volontairement fait l'impasse sur plusieurs aspects du langage:</p>

  <dl>
    <dt><b>Fichiers sources</b> </dt>
    <dd>Le d&eacute;coupage en fichiers <code>.h</code> et <code>.cpp</code>
n'est pas abord&eacute;. </dd>
    <dt><b>Fonctions <code>inline</code></b> </dt>
    <dd>Les fonctions peuvent &ecirc;tre d&eacute;clar&eacute;es <code>inline</code> pour
am&eacute;liroer la rapidit&eacute; d'ex&eacute;cution; ce point n'est pas abord&eacute; en d&eacute;tails. </dd>
    <dt><b>H&eacute;ritage priv&eacute; ou prot&eacute;g&eacute;</b> </dt>
    <dd>L'h&eacute;ritage priv&eacute; ou prot&eacute;g&eacute; n'est pas abord&eacute;. </dd>
    <dt><b>R.T.T.I.</b> </dt>
    <dd>Run Time Type Identification. Permet de d&eacute;terminer quel est le
type d'une variable. Dans de rares cas cela est indispensable, mais la
plupart du tempsdes m&eacute;canismes bas&eacute;s sur l'h&eacute;ritage seront pr&eacute;f&eacute;rables.
    </dd>
  </dl>
  <p><a class="noprint" href="#">top</a></p><hr />
  
  <h2><a id="historique">Un peu d'histoire.</a></h2>
    <p>Le C++ est apparu durant les ann&eacute;es 80; il s'agit
d'une cr&eacute;ation de Bjarne Stroustrup, un
informaticien qui travaillait chez ATT sur de gros projets
d'informatique distribu&eacute;e. Quelques dates:</p>
  <ul>
    <li>1965-1970 Le langage BCPL est largement utilis&eacute; pour la
programmation syst&egrave;me, en particulier chez ATT </li>
    <li>1969-1972 Naissance du langage B, une &eacute;volution de BCPL, puis
du langage C, lui-m&ecirc;me une &eacute;volution de B </li>
    <li>1978 The C Programming Language par Richie et Kernighan, ce
livre a tenu lieu de manuel de r&eacute;f&eacute;rence du langage pendant plusieurs
ann&eacute;es. </li>
    <li>1979 Bjorne Stroustrup commence &agrave; travailler sur un nouveau C
("C with Classes") </li>
    <li>1983 La premi&egrave;re version du C++ est utilis&eacute;e en interne chez
ATT </li>
    <li>1983 Mise en place de la commission de normalisation du C par
l'ANSI </li>
    <li>1985 Premi&egrave;re impl&eacute;mentation commerciale du C++ </li>
    <li>1985 Normalisation du C ("C Ansi") </li>
    <li>1989 Premiers travaux de normalisation du C++ </li>
    <li>Nov 1997 - Approbation du nouveau standard (Ansi C++) par le
comit&eacute; de normalisation </li>
  </ul>
  
  <p>La syntaxe &eacute;volue bien entendu d'un langage &agrave;
l'autre, mais comme ceux-ci sont fortement apparent&eacute;s entre eux, les
diff&eacute;rences de syntaxe sont au fond mineures. Par contre, la mani&egrave;re dont les donn&eacute;es sont trait&eacute;es va beaucoup &eacute;voluer au cours du temps;
BCPL et B sont des langages non typ&eacute;s: cela signifie que les donn&eacute;es seront toutes rassembl&eacute;es dans des tableaux de "mots", encore appel&eacute;s "cellules". La taille de chaque cellule est tout simplement la taille de cellule &eacute;l&eacute;mentaire utilis&eacute;e sur la machine (18 bits). Normal, au fond, pour un langage destin&eacute; &agrave; remplacer l'assembleur, tout en gardant ses principales caract&eacute;ristiques. Cela a cependant deux cons&eacute;quences importantes:</p>
  <ul>
    <li>La notion de pointeur ne pr&eacute;sente aucune difficult&eacute; &agrave; impl&eacute;menter </li>
    <li>La correspondance forte entre pointeurs et tableau est
    parfaitement naturelle.
    </li>
  </ul>
  <p> En 1970, un nouvel ordinateur (DEC pdp 11) est acquis par l'&eacute;quipe: d&egrave;s lors, la taille des mots n'est plus 18 bits, mais 16 bits, et l'adressage se fait par octets. Le langage B est rapidement recod&eacute; pour fonctionner sur la nouvelle machine, mais de gros probl&egrave;mes se posent alors:</p>
  <ul>
    <li>Les op&eacute;rateurs mettant en jeu des pointeurs, con&ccedil;us pour des machines sur 18 bits, deviennent tr&egrave;s inefficaces avec la nouvelle machine. </li>
    <li>Le pdp 11 &eacute;tant &eacute;quip&eacute; de coprocesseur flottant, comment en tirer parti avec un langage ne connaissant que des donn&eacute;es sur un mot, alors que 16 bits est insuffisant pour repr&eacute;senter un nombre r&eacute;el ??? (18 bits auraient &eacute;t&eacute; suffisants...)
    </li>
  </ul>
  <p> La seule mani&egrave;re de s'en sortir est alors de doter
le langage de variables de diff&eacute;rents <em>types</em>. Le nouveau
langage, appel&eacute; C, inclut donc la notion de types: <code>int, char,
float</code>, puis le type <code>struct</code> fait son apparition un
peu plus tard.</p>

  <h3>Langage proche de la machine ou abstraction de donn&eacute;es ?</h3>
  <p>On voit donc bien l'&eacute;volution, qui s'est poursuivie jusqu'au C++: on part d'une situation o&ugrave; le langage n'est au fond qu'un "super-assembleur", pour gagner petit &agrave; petit en abstraction, (type <code>struct</code> en particulier), ce qui permettra au langage d'&ecirc;tre utilis&eacute; pour un usage plus g&eacute;n&eacute;ral. Toutefois, on reste toujours "proche de la machine", de sorte que le C peut dans la plupart des cas remplacer totalement l'assembleur, m&ecirc;me pour d&eacute;velopper du code proche du hardware (pilotes de p&eacute;riph&eacute;riques, par exemple). 
Cette &eacute;volution a &eacute;t&eacute; poursuivie par Stroustrup lors de la conception du C++: le type   <code>class</code>, qui est l'aboutissement du type <code>struct</code>, permet d'impl&eacute;menter un tr&egrave;s haut niveau d'abstraction des donn&eacute;es; en m&ecirc;me temps, le C++ &eacute;tant un surensemble du C, il reste un langage de choix pour l'informatique syst&egrave;me.</p>

<h3 id="java">Et java dans tout &ccedil;a ?</h3>

<p>Le langage java est apparu en 1995: d'abord tr&egrave;s utilis&eacute; pour &eacute;crire des "applets", petites applications s'ex&eacute;cutant au sein d'un navigateur web, il s'est ensuite d&eacute;velopp&eacute;, jusqu'&agrave; &ecirc;tre aujourd'hui utilis&eacute; pour de tr&egrave;s grosses applications. Il s'agit d'un langage orient&eacute; objets, dont la syntaxe s'inspire largement du C++. Il a cependant des carat&eacute;ristiques particuli&egrave;res qui constituent sa marque de fabrique:</p>

<dl id="javadl" >
<dt>portabilit&eacute;:</dt>
<dd>il est bien plus simple d'&eacute;crire un programme portable en java qu'en C++.</dd>
<dt>interface utilisateur:</dt>
<dd>java est accompagn&eacute; de plusieurs bo&iacute;tes &agrave; outils permettant de r&eacute;aliser des applications graphiques. Il a donc la r&eacute;putation d'&ecirc;tre un langage bien adapt&eacute; &agrave; la programmation d'applications graphiques: certes... mais il existe aussi des bo&iacute;tes &agrave; outils permettant d'&eacute;crire des applications graphiques en C++. Citons ici les trois biblioth&egrave;ques les plus r&eacute;pandues:
<ul>
   <li><a href="http://www.wxwidgets.org/">wxwidgets</a></li>
   <li><a href="http://www.gtk.org/">gtk</a></li>
   <li><a href="http://www.qtfr.org/Qt">qt</a></li>
</ul></dd>
<dt>S&eacute;curit&eacute;</dt>
<dd>Jamais de ´†core dump†ª en java: en effet, java est dot&eacute; d'un syst&egrave;me de gestion de la m&eacute;moire qui rend toute allocation dynamique de m&eacute;moire transparente pour l'utilisateur... mais en C++, on pourra mieux contr&ocirc;ler le comportement du programme, puisqu'on doit  s'occuper soi-m&ecirc;me de la gestion m&eacute;moire.</dd>
<dt>Langage de haut niveau</dt>
<dd>java est un langage "de haut niveau", ce qui signifie qu'il "permet au programmeur de s'abstraire de dÈtails inh&eacute;rents au fonctionnement de la machine, ceux-ci &eacute;tant pris en compte lors de la compilation. Il permet de manipuler des concepts bien plus &eacute;labor&eacute;s, mais emp&ecirc;che la gestion de certains de ces d&eacute;tails" (WikipÈdia). C++, lui, peut &eacute;tre consid&eacute;r&eacute; comme un langage de haut niveau, au m&eacute;me titre que java, mais aussi comme un langage de bas niveau, de m&eacute;me que le langage C: c'est ce qui fait la richesse, mais aussi la complexit&eacute;, du C++.
</dd>
<dt>Relativement faible performance</dt>
<dd>Tous ces avantages ont un prix: java produit du code nettement performant que le C++. On pr&eacute;f&egrave;rera donc travailler en C++ dans tous les cas o&ugrave; l'on souhaite une bonne performance pour notre application.</dd>
</dl>

<p><a class="noprint" href="#">top</a></p><hr /> 
<address>
<img alt="xhtml" src="xhtml.png" />
<a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel
Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>

</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Gestion de la m&eacute;moire</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
 <dd id="smenu1">
	<ul>
		<li><a href="mem.html#alloc-dynam">Qu'est-ce que l'allocation dynamique de m&eacute;moire? </a>
		<ul>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#pile-tas">Pointeurs empil&eacute;s, objets entass&eacute;s</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#fuite-mem">Objets perdus et fuites de m&eacute;moire</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#dangling">Les pointeurs qui pendouillent</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#proprio">Propri&eacute;taires et r&eacute;f&eacute;rents</a></li> 
		</ul></li>
		<li><a onclick="javascript=cacher_menu()" href="mem.html#oper">Op&eacute;rateurs et fonctions</a> 
		<ul>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#new">Les op&eacute;rateurs <code>new</code> et <code>delete</code></a></li>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#new-tab">Les op&eacute;rateurs <code>new[]</code> et <code>delete[]</code></a></li>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#malloc">Fonctions malloc, free, realloc</a></li> 
		</ul></li>
		<li><a onclick="javascript=cacher_menu()" href="mem.html#obj">Objets utilis&eacute;s pour la gestion de la m&eacute;moire</a> 
		<ul>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#auto_ptr">L'objet <code>auto_ptr</code></a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#gest">Objets gestionnaires de ressources</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#robuste">Produire du code robuste, malgr&eacute; les exceptions</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#compt">Les objets &agrave; comptage de r&eacute;f&eacute;rence</a></li> 
		</ul></li>
	</ul>
 </dd>
</dl>
<dl>
 <dt><a href="exos.html#memoire" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1><a name="surch-fonc-op">Gestion de la m&eacute;moire</a></h1>

<p>Ce paragraphe  traite des  pointeurs,  des probl&egrave;mes
li&eacute;s &agrave; l'allocation  dynamique de m&eacute;moire, et des  moyens qui existent
de r&eacute;soudre ces probl&egrave;mes...   plut&ocirc;t d'&eacute;viter leur apparition, car en
ce domaine le pr&eacute;ventif est bien plus ais&eacute; que le curatif...</p>

<h2><a name="alloc-dynam">Qu'est-ce que l'allocation dynamique de m&eacute;moire ?</a></h2>

<p >Nous avons vu pr&eacute;c&eacute;demment  que la dur&eacute;e de vie d'une
variable     s'&eacute;tendait     durant      toute     la     port&eacute;e     <a
href="types.html#portee-nom"><img      alt="avant"     src="avant.gif" /></a>  de   son  nom.
   La   m&eacute;moire  est  allou&eacute;e,   et  le
constructeur de l'objet est appel&eacute;  en d&eacute;but de port&eacute;e; le destructeur
est appel&eacute; et la m&eacute;moire est rendue au syst&egrave;me &agrave; la fin de port&eacute;e. Les
objets utilis&eacute;s ainsi utilisent une  partie de la m&eacute;moire vive appel&eacute;e
<code>la pile</code>.  La structure  de pile est en effet parfaitement
adapt&eacute;e  &agrave;  la  gestion  des  r&egrave;gles  de  port&eacute;e.  Or,  il  peut  &ecirc;tre
int&eacute;ressant de stocker des donn&eacute;es &agrave; des endroits de la m&eacute;moire qui ne
seront  pas sujets soumis  aux r&egrave;gles  de port&eacute;e;  cela peut  se faire
gr&acirc;ce &agrave;:</p>

<ul>
  <li>d'une part  l'utilisation de pointeurs</li>
  <li>d'autre part &agrave; des op&eacute;rateurs permettant de g&eacute;rer explicitement
      l'allocation m&eacute;moire et sa lib&eacute;ration.</li>  
</ul>

<p >L'allocation-lib&eacute;ration de  m&eacute;moire &eacute;tant &agrave; la charge
du  programmeur, elle  peut se  faire  dans n'importe  quel ordre.  La
structure de pile n'est alors plus  adapt&eacute;e, et de fait la m&eacute;moire est
allou&eacute;e dans une autre z&ocirc;ne de la m&eacute;moire, appel&eacute;e <code>le tas</code>
(<code>heap</code>).</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> Le programmeur
doit <em>effectivement</em> g&eacute;rer la  lib&eacute;ration de m&eacute;moire... s'il ne
le fait pas, ou s'il le  fait mal, les pires cons&eacute;quences (&agrave; savoir un
plantage du programme) peuvent arriver.</p></div>

<h3><a name="pile-tas">Pointeurs empil&eacute;s, objets entass&eacute;s</a></h3>

<p >La  seule z&ocirc;ne de  m&eacute;moire que le  programme <em>peut
adresser directement</em>  est la  pile.  Les pointeurs  se trouveront
donc quelque  part dans  la pile, au  m&ecirc;me titre que  n'importe quelle
variable. Les <em>objets point&eacute;s</em>,  par contre, se trouveront dans
le tas. Il doit y avoir  <em>en permanence</em> un lien entre ces deux
z&ocirc;nes de m&eacute;moire.  Garder ce lien intact est la premi&egrave;re pr&eacute;occupation
d'une bonne gestion de la m&eacute;moire.</p>

<h3><a name="fuite-mem">Objets perdus et fuites de m&eacute;moire</a></h3>

<p  >Lorsqu'un  objet  est allou&eacute;  dynamiquement,  <em>au
moins un  pointeur</em> doit  pointer sur lui:  sinon, le  lien &eacute;voqu&eacute;
ci-dessus est bris&eacute;,  et l'objet est inutilisable. On  peut dire qu'il
est  perdu,  mais   surtout  <em>la  m&eacute;moire  correspondante</em>  est
perdue. Avant de briser le lien,  il aurait fallu rendre la m&eacute;moire au
syst&egrave;me. Suivant les  cas de figure, cela peut &ecirc;tre  grave ou pas. Par
exemple, si l'allocation  de m&eacute;moire a lieu dans  une boucle, &agrave; chaque
it&eacute;ration de la boucle on perd un peu de m&eacute;moire...  d'o&ucirc; l'expressoin
fuite de m&eacute;moire.  Si le nombre  d'it&eacute;rations est important, il y a un
moment o&ucirc; le  syst&egrave;me refusera de donner de  la m&eacute;moire suppl&eacute;mentaire
au programme, et celui-ci sera interrompu brutalement.</p>

<h3><a name="dangling">Les pointeurs qui pendouillent</a></h3>

<p  >Il  est   parfaitement  possible  de  faire  pointer
plusieurs pointeurs vers  le m&ecirc;me objet.  Mais dans  ce cas si l'objet
est d&eacute;truit (car le  programmeur a consciencieusement rendu la m&eacute;moire
au syst&egrave;me)  les autres pointeurs  pointeront sur une z&ocirc;ne  de m&eacute;moire
qui  ne  contient  plus  de  donn&eacute;es  valides...  soit  elle  contient
n'importe  quoi   ("du  jargon"  (<code>garbage</code>)),   soit  elle
contient  de  nouvelles  donn&eacute;es,  mais  qui  ne  sont  peut-&ecirc;tre  pas
structur&eacute;es de  la m&ecirc;me mani&egrave;re  que les pr&eacute;c&eacute;dentes.  Le  pointeur va
donc "pendouiller", et  si on cherche &agrave; l'utiliser,  il peut se passer
n'importe quoi, mais le pire est &agrave; craindre.</p>

<h3><a name="proprio">Propri&eacute;taires et r&eacute;f&eacute;rents</a></h3>

<p>Compte tenu de ce qui pr&eacute;c&egrave;de, on voit donc qu'on peut d&eacute;finir deux sortes de
pointeurs:</p>

<ul>
  <li>Un pointeur <em>propri&eacute;taire</em> de l'objet. Il a la responsabilit&eacute; de
      la destruction de cet objet. L'objet est le <em>r&eacute;f&eacute;rent</em>.</li>
  <li>Les autres pointeurs. Ils peuvent acc&eacute;der &agrave; l'objet tant que
      celui-ci existe, mais ils ne sont pas cens&eacute;s s'occuper de sa destruction.</li>
</ul>

<p>Bien  s&ucirc;r, la propri&eacute;t&eacute;  d'un objet peut  passer d'un
pointeur  &agrave;  l'autre. D'autre  part,  il  faut  bien avoir  pr&eacute;sent  &agrave;
l'esprit que ces notions, importantes  lors de la phase de conception,
<em>ne sont  pas pr&eacute;sentes  dans le langage  lui-m&ecirc;me</em>: le  C++ ne
comprend en effet aucune gestion  de la m&eacute;moire, celle-ci restant &agrave; la
charge du programmeur. Cependant, des objets (dont l'un d'entre eux se
trouve  d&eacute;clar&eacute;  dans  la  biblioth&egrave;que standard)  vont  pouvoir  nous
aider.</p>

<p><a href="#">top</a></p><hr />

<h2><a name="oper">Op&eacute;rateurs et fonctions</a></h2>

<h3><a name="new">Les op&eacute;rateurs <code>new</code> et <code>delete</code></a></h3>

<p>L'op&eacute;rateur <code>new</code> est utilis&eacute; pour allouer
de  la m&eacute;moire  pour un  objet, <code>delete</code>  est  utilis&eacute; pour
redonner  la m&eacute;moire  au  syst&egrave;me.  Le (ou  les)  param&egrave;tres pass&eacute;s  &agrave;
<code>new</code> seront pass&eacute;s au constructeur de l'objet:</p>

<pre class="demo">
main() {
   const complexe J(0,1);
   <b>complexe* C = new complexe(5,5);</b>
   *C = J;
   <b>delete C;</b>
};
</pre>

<h3><a name="new-tab">Les op&eacute;rateurs <code>new[]</code> et <code>delete[]</code></a></h3>

<p>Ils  servent  &agrave;   allouer  de  la  m&eacute;moire  pour  un
<em>tableau</em>  d'objets.  Ils  ne  peuvent etre  utilis&eacute;s  qu'&agrave;  la
condition qu'existe pour notre objet un constructeur par d&eacute;faut, &agrave; qui
on puisse ne  pas passer de param&egrave;tres. C'est le  cas pour notre objet
<code>complexe</code>, nous pouvons donc &eacute;crire:</p>

<pre class="demo">
main() {
   const complexe J(0,1);
   int taille=100;
   <b>complexe* C = new complexe[taille];</b>
   for (int i=0; i&lt;100; ++i) {
       C[i] = J;
   }
   <b>delete[] C;</b>
};
</pre>

<p>Un tableau de 100 complexes est dynamiquement allou&eacute;.
Les  complexes sont tous  initialis&eacute;s &agrave;  0 (constructeur  par d&eacute;faut),
puis  affect&eacute;s  &agrave; la  valeur  <code>J</code>.  Enfin,  le tableau  est
d&eacute;truit et la m&eacute;moire est rendue au syst&egrave;me.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />  On  ne  peut  allouer  un
tableau  d'objets  de cette  mani&egrave;re  <em>que</em>  si  les objets  en
question poss&egrave;dent  un constructeur par d&eacute;faut. Il  n'est pas possible
de passer des param&egrave;tres aux constructeurs des objets cr&eacute;&eacute;s.</p></div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />La taille peut parfaitement &ecirc;tre une variable, comme on le voit dans cet exemple.</p></div>

<h3><a name="malloc">Fonctions malloc, free, realloc</a></h3>

<p>Nous   avons   en  <code>C</code>   des   fonctions
d'allocation    dynamique   de    m&eacute;moire:    <code>malloc</code>   et
<code>free</code> pour allouer de la  m&eacute;moire et la rendre au syst&egrave;me,
<code>realloc</code>  pour refaire une  allocation m&eacute;moire  lorsque le
bloc   pr&eacute;c&eacute;demment  allou&eacute;   est  trop   juste. Tout   cela  est
r&eacute;utilisable, &agrave; condition de prendre quelques pr&eacute;cautions:</p>

<ul>
  <li><code>new</code> alloue la m&eacute;moire, <em>puis</em> appelle le
      constructeur. <code>malloc</code> <em>n'appelle pas le
      constructeur</em>. Attention, donc &agrave; l'initialisation correcte
      de l'objet.</li>
  <li><code>delete</code> appelle le destructeur <i>puis</i> rend la m&eacute;moire au syst&egrave;me. <code>free</code> <em>n'appelle pas le
      destructeur</em>. Attention donc au code qui ne sera pas ex&eacute;cut&eacute;</li>
  <li><code>realloc</code> <em>ne doit pas &ecirc;tre utilis&eacute;</em> dans le
      cas d'objets de type class: <code>realloc</code> va provoquer
      une copie de la m&eacute;moire bit &agrave; bit, ce qui risque de provoquer
      des catastrophes dans certains cas.</li>
  <li><em>Soyez coh&eacute;rent</em>: si vous avez utilis&eacute; <code>new</code>
      pour cr&eacute;er un objet, utilisez <code>delete</code> pour le
      d&eacute;truire. Si vous avez utilis&eacute; <code>alloc</code> pour cr&eacute;er un
      objet, utilisez <code>free</code> pour le d&eacute;truire.</li>
</ul>

<p>Conclusion: pour du code  C++, il n'y a aucune raison
de  ne  pas  utiliser  les  op&eacute;rateurs  du  C++,  <code>new</code>  et
<code>delete</code>.  Mais  il faut  savoir que le  code C  &eacute;crit avec
<code>malloc</code>  et  <code>free</code> (m&ecirc;me  <code>realloc</code>
dans le  cas de z&ocirc;nes d'entiers  ou de caract&egrave;res,  par exemple) reste
utilisable.</p>

<h3><a name="constr-destr">Allocation m&eacute;moire et constructeurs-destructeurs</a></h3>

<p>Le  constructeur d'un  objet est l'endroit  r&ecirc;v&eacute; pour
appeler <code>new</code>.  De m&ecirc;me, le  destructeur du m&ecirc;me  objet est
l'endroit r&ocirc;v&eacute; pour appeler <code>delete</code>.</p>

<h4>Constructeurs de copie</h4>

<p>Attention  au constructeur de copie;  &agrave; chaque copie,
il  faudra  prendre  une  d&eacute;cision;  il peut  en  effet  se  pr&eacute;senter
plusieurs cas de figure:</p>

<ol>
  <li>L'objet source est propri&eacute;taire d'un objet r&eacute;f&eacute;rent, l'objet
      copi&eacute; pointe vers le r&eacute;f&eacute;rent sans &ecirc;tre propri&eacute;taire.</li>
  <li>L'objet source est propri&eacute;taire d'un r&eacute;f&eacute;rent, &agrave; la suite de la
      copie l'objet copi&eacute; devient le nouveau propri&eacute;taire.</li>
  <li>Le r&eacute;f&eacute;rent de l'objet source est copi&eacute; dans une autre z&ocirc;ne
      m&eacute;moire, et l'objet copi&eacute; est propri&eacute;taire de la copie du r&eacute;f&eacute;rent.</li>
</ol>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
  Des  trois   solutions
ci-dessus, la  premi&egrave;re est  <em>tr&egrave;s dangereuse</em>: en  effet, elle
risque  fort  d'aboutir &agrave;  des  objets  "irresponsables" vis-&agrave;-vis  de
l'allocation m&eacute;moire. Cette  solution est toutefois acceptable lorsque
les   objets   r&eacute;f&eacute;rents   comptent   eux-m&ecirc;mes  les   r&eacute;f&eacute;rences   <a
href="#compt"><img  alt="apres"  src="apres.gif" /></a>.  La
seconde solution peut &ecirc;tre impl&eacute;ment&eacute;e par un <code>auto_ptr</code>.</p></div>

<p><a href="#">top</a></p><hr />

<h2><a name="obj">Objets  utilis&eacute;s pour la gestion de la m&eacute;moire</a></h2>

<h3><a name="auto_ptr">L'objet <code>auto_ptr</code></a></h3>

<p><code>auto_ptr</code> fait  partie de la biblioth&egrave;que  standard du C++
<a href="stdlib.html"><img alt="apres" src="apres.gif" /></a>
.  Il sert &agrave;  d&eacute;finir un  pointeur "intelligent"...  en tous  cas fort
sympathique, ayant les caract&eacute;ristiques suivantes:</p>

<ul>
  <li>Un <code>auto_ptr</code> est <em>toujours</em> propri&eacute;taire de
      l'objet sur lequel il pointe</li>
  <li>Lorsque l'<code>auto_ptr</code> est d&eacute;truit, l'objet sur lequel
      il pointe est d&eacute;truit &eacute;galement. On est donc assur&eacute; de ne pas
      avoir de pointeur pendouillant.</li>
  <li>Si l'on copie un <code>auto_ptr</code>, l'<code>auto_ptr</code>
      original perd l'objet point&eacute;, de sorte que s'il
      est d&eacute;truit, le r&eacute;f&eacute;rent ne sera pas d&eacute;truit. Par contre, si
      le <em>nouvel</em> <code>auto_ptr</code> est d&eacute;truit, le
      r&eacute;f&eacute;rent sera d&eacute;truit puisque la copie est le nouveau propri&eacute;taire.</li>
</ul>

<p>Le code  suivant,  qui utilise  des  objets de  type
<code>complexe</code>, illustre l'utilisation d'<code>auto_ptr</code>:</p>

<pre class="demo">
typedef auto_ptr&lt;complexe&gt; complexe_ptr;

void main() {
  <b>complexe_ptr c2(new complexe);</b>            // allocation d'un auto_ptr.
  {
    <b>complexe_ptr c1(new complexe(5,5));</b>	    // allocation d'un auto_ptr
    c2=c1;			            // c2 devient proprietaire du complexe
					    // son ancien referent est detruit
					    // c1 n'est plus le propri&eacute;taire, 
  };					    // il peut &ecirc;tre d&eacute;truit.
}
</pre>

<p>Un  objet de  type  <code>auto_ptr</code> peut  donc
avantageusement &ecirc;tre allou&eacute; dans le constructeur &agrave; la place d'un objet
ordinaire.  La  destruction du r&eacute;f&eacute;rent sera automatique  au moment de
la  destruction de  l'objet, sans  m&ecirc;me  qu'il soit  n&eacute;cessaire de  le
sp&eacute;cifier dans le destructeur. Dans le code ci-dessus, tous nos ennuis
viennent  en  effet   uniquement  de  <code>c3</code>,  d&eacute;clar&eacute;  comme
<code>complexe*</code>.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
En fait,  l'important n'est pas l&agrave;:  apr&egrave;s tout, vous  &ecirc;tes bien assez
malin  pour ne pas  oublier d'&eacute;crire  les quelques  lignes de  code du
destructeur           correspondant          aux          instructions
<code>delete</code>. L'important, c'est qu'il est fort possible que le
constructeur, <em>apr&egrave;s  avoir allou&eacute; un  ou plusieurs pointeurs</em>,
g&eacute;n&egrave;re une exception (fonctionnement normal pour un constructeur).  La
construction de  l'objet est alors interrompue,  et <em>le destructeur
n'est   pas   appel&eacute;</em>.     R&eacute;sultat:   une   fuite   de   m&eacute;moire.
L'<code>auto_ptr</code>  est donc  la solution  &eacute;l&eacute;gante,  car lorsque
l'auto_ptr  sera   d&eacute;truit,  le  r&eacute;f&eacute;rent  sera   lui  aussi  d&eacute;truit.
</p></div>

<h3><a name="gest">Objets gestionnaires de ressources</a></h3>

<p>Pour  &eacute;viter les  ennuis &eacute;voqu&eacute;s  ci-dessus, arrangez-vous  pour qu'un
objet <em>ne g&egrave;re qu'une seule ressource</em>. Eventuellement, si vous
devez g&eacute;rer  trois ressources, rien  ne vous emp&ecirc;che  d'utiliser trois
objets  diff&eacute;rents,  quitte  &agrave;   les  ins&eacute;rer  dans  un  autre  objet.</p>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
Les trois principes fondamentaux pour g&eacute;rer les ressources sont:</p>

<dl>
  <dt><b>Propri&eacute;t&eacute;</b></dt>
  <dd>A chaque ressource allou&eacute;e, correspond <em>un et un seul</em>
      objet gestionnaire, qui sera propri&eacute;taire de cette ressource.</dd>
  <dt><b>Responsabilit&eacute;</b></dt>
  <dd>L'objet gestionnaire est <em>responsable</em> de la ressource,
      et il est <em>le seul responsable</em></dd>
  <dt><b>Simplicit&eacute;</b></dt>
  <dd>L'objet gestionnaire ne fait <em>rien d'autre</em>.</dd>
</dl>
</div>

<p><code>auto_ptr</code> est un bon exemple d'objet dont l'unique raison
d'&ecirc;tre est la gestion d'une ressource (en l'occurrence la m&eacute;moire).</p>

<h3><a name="robuste">Produire du code robuste, malgr&eacute; les exceptions</a></h3>

<p>On l'a vu, les exceptions peuvent avoir pour cons&eacute;quence l'apparition
de fuites de m&eacute;moire ou de pointeurs pendouillants. Voici quelques
astuces permettant d'&eacute;viter ces d&eacute;sagr&eacute;ment.</p>

<h4>auto_ptr</h4>

<p>Utiliser <code>auto_ptr</code> le plus souvent possible.</p>

<h4>p=NULL</h4>

<p>Apr&egrave;s avoir  ex&eacute;cut&eacute; <code>delete p</code>, <em>on se
retrouve avec un pointeur pendouillant</em>. Donc, remettez les choses
en ordre <em>d&egrave;s  la ligne suivante</em> (&agrave; moins,  bien s&ucirc;r, qu'on ne
sorte de  la port&eacute;e). Par exemple avec  <code>p=NULL;</code> En effet,
s'il  arrive qu'un  second appel  <code>delete</code> soit  lanc&eacute; (par
exemple  &agrave;  partir   du  destructeur),  il  ne  se   passera  rien  si
<code>p</code>  vaut  <code>NULL</code>, alors  que  le r&eacute;sultat  sera
catastrophique si <code>p</code> pendouille.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Le code suivant est <em>dangereux</em>:</p>

<pre class="demo">
delete p ;
p = new toto();
</pre></div>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />Si <code>toto</code> envoie une exception, <code>p</code> continue &agrave;
pendouiller. Il vaut mieux faire:</p>

<pre class="demo">
delete p ;
p = NULL;
p = new toto();

</pre></div>

<h3><a name="compt">Les objets &agrave; comptage de r&eacute;f&eacute;rence</a></h3>

<p>Il   est  possible  d'impl&eacute;menter   des  objets  qui
<em>comptent</em>  le  nombre de  pointeurs  mis  sur  eux.  De  cette
mani&egrave;re, il est ais&eacute;, lorsque ce  nombre arrive &agrave; 0, de faire en sorte
que  ces  objets s'auto-d&eacute;truisent.   Cela  passe,  bien  s&ucirc;r, par  la
surcharge des op&eacute;rateurs <code>=, *, -&gt;</code>.</p>

<p><a href="#">top</a></p><hr />
<address><a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>
<p>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p></div></body> </html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Mod&egrave;les</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
    <dd id="smenu1">
    <ul>
      <li><a onclick="javascript=cacher_menu()" href="modeles.html#class-param">Classes param&eacute;tr&eacute;es</a>
        <ul>
          <li><a onclick="javascript=cacher_menu()" href="modeles.html#def-class-param">D&eacute;finition</a></li>
          <li><a onclick="javascript=cacher_menu()" href="modeles.html#instant">Instantiation</a></li>
          <li><a onclick="javascript=cacher_menu()" href="modeles.html#param-util">Param&egrave;tres utilisables</a></li>
        </ul>
      </li>
      <li><a onclick="javascript=cacher_menu()" href="modeles.html#modele-fct">Mod&egrave;les de fonctions</a></li>
      <li><a onclick="javascript=cacher_menu()" href="modeles.html#modele-spe">Sp&eacute;cialisation</a></li>
      <li><a onclick="javascript=cacher_menu()" href="modeles.html#conseils">Quelques conseils</a></li>
    </ul>
    </dd>
</dl>
<dl>
 <dt><a href="exos.html#modeles" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1 id="titre_page"><a name="modeles">Les mod&egrave;les </a></h1>

<p>Nous sommes maintenant capables d'exprimer plusieurs types de
relations entre objets:</p>

<ul>
  <li>Associations, agr&eacute;gation, composition:</li>
  <li>Est une sorte de</li>
</ul>

<p>Nous allons voir dans ce chapitre comment exprimer
la relation: <em>Est une liste de</em>, ou <em>Est
un tas de</em>,
etc.; nous avons d&eacute;fini au d&eacute;but du cours une
classe appel&eacute;e
<code>complexe</code>, qui comprend essentiellement deux
membres
priv&eacute;s, <code>r</code> et <code>i</code>.
Or, ces deux nombres &eacute;taient
d&eacute;finis comme des <code>float</code>, ce qui
peut para&icirc;tre un peu
restrictif... Ne faudrait-il pas plut&ocirc;t d&eacute;finir
les parties r&eacute;elle et
imaginaire des complexes comme des double, pour avoir une meilleure
pr&eacute;cision lors des calculs num&eacute;riques ? Nous ne
voulons pas avoir &agrave; choisir, en
tous cas <em>pas au moment d'&eacute;crire l'objet
<code>complexe</code></em>: les algorithmes
utilis&eacute;s seront les m&ecirc;mes, quelque soit le type
des champs utilis&eacute;s pour la
partie r&eacute;elle et pour la partie imaginaire. D'o&ugrave;
la notion de
<em>mod&egrave;les</em>.</p>

<p>Les mod&egrave;les sont tr&egrave;s
utilis&eacute;s pour cr&eacute;er des objets de type
conteneurs:
ce sont des objets qui vont en "contenir" d'autres. Nous en reparlerons
dans le chapitre sur la biblioth&egrave;que
standard <a href="stdlib.html"><img alt="apres" src="apres.gif" class="noprint" /></a></p>

<h2><a name="class-param">Classes
param&eacute;tr&eacute;es</a></h2>

<h3><a name="def-class-param">D&eacute;finition
d'une classe param&eacute;tr&eacute;e</a></h3>

<p>Voici la nouvelle d&eacute;finition de la classe <code>complexe</code>,
en
utilisant des mod&egrave;les:</p>

<pre class="demo"><b>template&lt;class NUM=float&gt;</b> class complexe {<br />public:<br /> complexe(<b>NUM</b> x=0, <b>NUM</b> y=0);<br /> complexe(const <b>complexe&lt;NUM&gt;</b> &amp; );<br /> ~complexe();<br /> operator <b>NUM</b>();<br /> <b>complexe&lt;NUM&gt;</b> &amp; operator=(const <b>complexe&lt;NUM&gt;</b> &amp;);<br /> <b>complexe&lt;NUM&gt;</b> &amp; operator+= (const <b>complexe&lt;NUM&gt;</b> &amp;);<br /> <b>NUM</b> get_r() const { return r;};<br /> <b>NUM</b> get_i() const { return i;};<br /> void set_r(<b>NUM</b> x) { r=x; m_flg=false;};<br /> void set_i(<b>NUM</b> x) { i=x; m_flg=false;};<br /> <b>NUM</b> get_m() const;<br /> static void set_debug() { debflg=true;};<br /> static void clr_debug() { debflg=false;};<br /><br />private:<br /> <b>NUM</b> r;<br /> <b>NUM</b> i;<br /> mutable bool m_flg;<br /> mutable <b>NUM</b> m;<br /> static bool debflg;<br /> void _calc_module() const {m=sqrt(r*r+i*i);};<br />};<br /></pre>

<p>Le nom de classe est pr&eacute;c&eacute;d&eacute;
par le mot-cl&eacute;
<code>template&lt;class NUM&gt;</code> (que l'on
traduit
par <em>mod&egrave;le</em>,ou <em>patron</em>),
ce qui
signifie qu'un certain <em>type</em> sera
utilis&eacute; lors de
l'instantiation de cette classe. D'autre part, d&egrave;s que le
nom
complexe est utilis&eacute; pour d&eacute;signer la classe qui
est en train d'&ecirc;tre
d&eacute;finie, on <em>doit</em> citer le
param&egrave;tre, d'o&ugrave; la notation un peu
lourde <code>complexe&lt;NUM&gt;</code> partout
dans la d&eacute;finition des
param&egrave;tres.</p>

<div class="attention">
<p><img alt="ATTENTION" src="attention.gif" />
Dans l'expression <code>class NUM</code>, le mot
<code>class</code> signifie <code>type</code>...
On peut utiliser
n'importe quel type, que ce soit un type d&eacute;fini en tant que
classe ou
que ce soit un type pr&eacute;d&eacute;fini. Une autre syntaxe
peut d'ailleurs &ecirc;tre utilis&eacute;e,
elle consiste &agrave; remplacer <code>class</code>
par <code>typename</code></p>

</div>

<div class="attention">
<p><img alt="ATTENTION" src="attention.gif" />Lorsqu'on
<em>d&eacute;clare</em> la classe elle-m&ecirc;me,
les param&egrave;tres ne doivent pas
&ecirc;tre sp&eacute;cifi&eacute;s &agrave; nouveau
derri&egrave;re le mot-cl&eacute; <code>class</code>.
De la
m&ecirc;me mani&egrave;re, le nom des constructeurs ou du
destructeur restent
inchang&eacute;s.</p>

</div>

<div class="attention">
<p><img alt="ATTENTION" src="attention.gif" />
Si vous
d&eacute;finissez une fonction <em>en-dehors de la
port&eacute;e de la
d&eacute;claration de classe</em>, vous devrez
r&eacute;p&eacute;ter
<code>template&lt;NUM&gt;</code>. Sinon, le
compilateur ne saura
comment interpr&eacute;ter <code>complexe&lt;NUM&gt;</code>.
Ainsi, dans l'exemple
ci-dessus, le destructeur
devra &ecirc;tre d&eacute;fini de la mani&egrave;re
suivante:</p>

<pre class="demo"><b>template &lt;class NUM&gt; complexe&lt;NUM&gt;</b>::~complexe()<br /></pre>

<p>Ce qui signifie:</p>

<ul>

  <li>Indiquer que <code>NUM</code> correspond
&agrave; un template en cours de d&eacute;finition</li>

  <li>Le nom de la classe est <code><b>complexe&lt;NUM&gt;</b></code></li>

  <li>Le nom de la fonction est <code>~complexe</code>
(destructeur, en l'occurrence)</li>

</ul>

</div>

<h3><a name="def-prm">Param&egrave;tres par
d&eacute;faut</a></h3>

<p>Dans le code ci-dessus, on remarque la structure
<code><b>class NUM=float</b></code>, qui
revient &agrave; donner &agrave; <code>NUM</code>
une valeur par d&eacute;faut (<code>int</code> en
l'occurrence, afin de
retrouver le m&ecirc;me fonctionnement que ci-dessus).</p>

<h3><a name="instant">Instantiation</a></h3>

<p>Le programme principal ressemblera &agrave; ce qui suit:</p>

<pre class="demo">typedef <b>complexe&lt;&gt;</b> complexe_float;<br />typedef <b>complexe&lt;double&gt;</b> complexe_double;<br /><br />main() {<br /> complexe_float F;<br /> complexe_double D;<br />}<br /></pre>

<p>Le <code>typedef</code> ne fait <em>rien
d'autre</em>
que de d&eacute;clarer un <em>synonyme</em>. Autrement
dit, il ne cr&eacute;e pas
un nouveau type. Son r&ocirc;le n'est pas indispensable, mais
simplement
<em>tr&egrave;s souhaitable</em> pour la
lisibilit&eacute; du code: en effet, la
syntaxe <code>complexe&lt;float&gt;</code> se
r&eacute;v&egrave;le difficilement
lisible.</p>

<p>Dans le cas des flottants, il suffit de d&eacute;clarer
<code>complexe&lt;&gt;</code>, le symbole <code>&lt;&gt;</code>
&eacute;tant
l&agrave; pour rappeler qu'il s'agit bien d'un mod&egrave;le.</p>

<h3><a name="param-util">Param&egrave;tres
utilisables</a></h3>

<p>On peut mettre plusieurs param&egrave;tres dans les
mod&egrave;les. Ces param&egrave;tres
peuvent &ecirc;tre de deux sortes:</p>

<ul>

  <li>Le mot-cl&eacute; <code>class</code> suivi
d'un nom de type existant (pr&eacute;d&eacute;fini ou non).</li>

  <li>Un type pr&eacute;d&eacute;fini
(g&eacute;n&eacute;ralement <code>int</code>)
suivi d'un nombre, pour exprimer par exemple une dimension.</li>

</ul>

<div class="attention">
<p><img alt="ATTENTION" src="attention.gif" />On
peut
aussi mettre en param&egrave;tre un param&egrave;tre de
mod&egrave;le d&eacute;j&agrave; d&eacute;fini au
pr&eacute;alable. Par exemple:</p>

<pre class="demo">template&lt;class T, T VALEUR&gt; class machin {<br /> ...<br />}<br /></pre>

<p>commence par d&eacute;finir <code>T</code>
comme un type (<code>int</code> ou
<code>float</code>, par exemple), puis VALEUR est un
param&egrave;tre de m&ecirc;me
type que T. On pourra alors instantier le mod&egrave;le par:</p>

<pre class="demo">machin&lt;int,6&gt; m1;<br />machin&lt;float,3.14&gt; m2; <br /></pre>

</div>

<h4>Exemple: La classe tableau</h4>

<p>Ainsi, la classe <code>tableau</code> <a href="types.html#const"><img alt="avant" src="avant.gif" class="noprint" /></a> d&eacute;finie ci-dessus
peut &ecirc;tre r&eacute;&eacute;crite en utilisant un
mod&egrave;le:</p>

<pre class="demo">template&lt;size_t BFRSZ&gt; class tableau {<br /> char buffer[BFRSZ];<br /> void copie(const tableau&lt;BFRSZ&gt; &amp;);<br />public:<br /> tableau(){};<br /> tableau(const tableau &amp;);<br /> tableau&lt;BFRSZ&gt; &amp; operator=(const tableau&lt;BFRSZ&gt; &amp;);<br /> ~tableau() {delete buffer;};<br />};<br /><br />template&lt;size_t BFRSZ&gt; tableau&lt;BFRSZ&gt;::tableau(const tableau &amp; b ) {<br /> copie(b);<br /> cout &lt;&lt; "copie effectuee par const de copie\n";<br />};<br /><br />template&lt;size_t BFRSZ&gt; void tableau&lt;BFRSZ&gt;::copie(const<br />tableau&lt;BFRSZ&gt; &amp; b) { <br /> memcpy(buffer,b.buffer,BFRSZ);<br />};<br /></pre>

<p>Cette impl&eacute;mentation est int&eacute;ressante,
parce qu'on n'a plus besoin d'utiliser l'op&eacute;rateur <code>new</code>
dans le constructeur. Du coup, on n'a plus besoin non plus du "trio infernal" <a href="surch.html#affect-trio"><img alt="avant" src="avant.gif" class="noprint" /></a> Par contre, on ne peut plus choisir la taille du buffer lors de l'ex&eacute;cution du code, celle-ci doit &ecirc;tre fix&eacute;e &agrave; la compilation.</p>

<hr />
<h2><a name="modele-fct">Mod&egrave;les de
fonctions</a></h2>

<p>Les fonctions peuvent, elles aussi, &ecirc;tre
d&eacute;clar&eacute;es
par l'interm&eacute;diaire d'un mod&egrave;le. Ainsi, une
fonction
<code>sort</code> qui impl&eacute;mente un algorithme
de tri sur un vecteur (objet jouant le r&ocirc;le
de tableau <a href="stdlib.html#constd"><img alt="apres" src="apres.gif" class="noprint" /></a>)
peut-elle &ecirc;tre d&eacute;clar&eacute;e de la
mani&egrave;re suivante:</p>

<pre class="demo">template&lt;class T&gt; void sort(vector&lt;T&gt; &amp;)<br /></pre>

<p>Dans ce cas, on trie un vecteur d'objets de types T. Ce que
sera le type T n'est pas connu &agrave; ce stade:
c'est lors de l'utilisation de la fonction que cela sera
pr&eacute;cis&eacute;, ainsi qu'on le voit ci-dessous:</p>

<pre class="demo">vector&lt;int&gt; V1;<br />vector&lt;string&gt; V2;<br />...<br /><b>sort(V1); // trie le vecteur d'entiers V1</b><br /><b>sort(V2); // trie le vecteur de cha&icirc;nes de caract&egrave;res V2</b>
</pre>

<h2><a name="modele-spe">Sp&eacute;cialisation</a></h2>

<p>Il n'est pas toujours possible de s'en tenir &agrave;
l'&eacute;criture du code g&eacute;n&eacute;ral, tel que le
mod&egrave;le l'impl&eacute;mente: ne
serait-ce que pour des raisons de performance, il est parfois
n&eacute;cessaire de r&eacute;&eacute;crire le code pour
certains types particuliers. Par
exemple, un tableau d'objets peut parfaitement &ecirc;tre
impl&eacute;ment&eacute; sous
forme de mod&egrave;le (et <em>est</em>
impl&eacute;ment&eacute; dans la biblioth&egrave;que
standard, d'ailleurs), mais on
con&ccedil;oit qu'un
tableau de bool&eacute;ens
devrait &ecirc;tre radicalement diff&eacute;rent, tout
simplement parce que des
bool&eacute;ens ne tiennent pas sur un ou plusieurs octets, mais
bien sur un
<code>bit</code>.</p>

<h2><a name="conseils">Quelques conseils...</a></h2>

<p>Les mod&egrave;les permettent de d&eacute;finir des
objets de
mani&egrave;re extr&ecirc;mement
g&eacute;n&eacute;rale, en ce sens ils constituent un outil
tr&egrave;s
puissant. Mais, chaque m&eacute;daille ayant son revers, ils sont
d'une
utilisation assez d&eacute;licate. Il semble d'ailleurs que, encore
actuellement, tous les compilateurs n'impl&eacute;mentent pas les
mod&egrave;les de
mani&egrave;re compl&egrave;tement identique, ce qui n'est pas
pour faciliter les
choses...</p>

<p>Il est important de conna&icirc;tre la syntaxe des
mod&egrave;les, car elle est employ&eacute;e en permanence dans
la biblioth&egrave;que
standard: cela est tout-&agrave;-fait compr&eacute;hensible,
dans la mesure o&ugrave; une
bonne partie de la biblioth&egrave;que standard est
constitu&eacute;e de
"conteneurs" et d'algorithmes associ&eacute;es,
c'est-&agrave;-dire d'objets
encapsulant des structures de donn&eacute;es: seuls les
mod&egrave;les permettent de
les d&eacute;crire de mani&egrave;re
g&eacute;n&eacute;rale </p>

<p>Quelques conseils, pour ne pas se noyer dans les
mod&egrave;les:</p>

<ul>

  <li><em>toujours</em> utiliser des <code>typedef</code>,
afin de n'entrer qu'une seule fois le mod&egrave;le
lui-m&ecirc;me avec toute sa complexit&eacute;.</li>

  <li>Lors de <em>l'&eacute;criture</em> de
nouveaux mod&egrave;les, il convient de d&eacute;marrer d'abord
avec des types ordinaires (<code>int</code>, par exemple)
ou des constantes litt&eacute;rales. Mettez au point votre code, <em>alors
seulement</em> remplacez vos types et vos constantes par des
param&egrave;tres, afin de gagner en
g&eacute;n&eacute;ralit&eacute;. Cette approche progressive
permettra d'isoler les probl&egrave;mes li&eacute;s
&agrave; l'utilisation des mod&egrave;les, et les
probl&egrave;mes plus classiques li&eacute;s &agrave; tout
programme en cours d'&eacute;criture.</li>

</ul>

<hr />
<div class="autres langages"><img alt="DECHIRURE" src="dechirure.gif" />
<table class="tableau">
    <tr>
      <th> Langage </th>
      <th> Mod&egrave;les </th>
    </tr>
    <tr>
      <td><b>C++</b> </td>
      <td><b>OUI</b></td>
    </tr>
    <tr>
      <td><b>perl</b></td>
      <td>NON</td>
    </tr>
    <tr>
      <td><b>java</b></td>
      <td>NON</td>
    </tr>
    <tr>
      <td><b>python</b></td>
      <td>NON</td>
    </tr>
</table>
</div>

<hr />
<address><a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel
Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>

<p> <a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <title>La programmation objets</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  //<![CDATA[
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  //]]>
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
 <dd id="smenu1" style="height:20em;overflow: scroll;">
    <ul>
    	<li><a onclick="javascript=cacher_menu()"href="progobj.html#probl">Poser un probl&egrave;me</a></li> 
        <li><a onclick="javascript=cacher_menu()"href="progobj.html#prog">La programmation objets expliqu&eacute;e aux programmeurs</a> 
        <ul>
	       <li><a onclick="javascript=cacher_menu()"href="progobj.html#proc">L'approche proc&eacute;durale</a>
	       <ul>
	    	   <li><a onclick="javascript=cacher_menu()"href="progobj.html#fonct">Qu'est-ce qu'une fonction ?</a></li> 
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#loca-glo">Variables locales ou globales</a></li> 
           </ul></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#modul">Approche modulaire:</a> 
           <ul>
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#interf">Interface publique...</a></li> 
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#impl">...Impl&eacute;mentation cach&eacute;e</a></li> 
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#encaps">Encapsulation des donn&eacute;es</a></li> 
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#proto">Prototypage</a></li>
	       </ul></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#obj">Approche objets:</a> 
           <ul>
	    	   <li><a onclick="javascript=cacher_menu()"href="progobj.html#obj-typ">Des objets int&eacute;gr&eacute;s au syst&egrave;me de typage</a></li> 
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#class-obj">Classer les objets</a></li> 
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#piles">D&eacute;finir des piles de n'importe quoi</a></li> 
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#heritcor">Faire du neuf avec du vieux</a> </li>
               <li><a onclick="javascript=cacher_menu()"href="progobj.html#biblio">Des biblioth&egrave;ques d'objets</a></li> 
	       </ul></li>
       </ul></li>
       <li><a onclick="javascript=cacher_menu()"href="progobj.html#normaux">La programmation objets expliqu&eacute;e aux gens normaux</a> 
	       <ul>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#cafeteria">Une caf&eacute;t&eacute;ria informatis&eacute;e</a></li> 
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#cafproc">Le caf&eacute; en programmation proc&eacute;durale</a></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#cafobj">Le caf&eacute; en programmation objet</a> 
           <ul>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#cafmodele">Mod&eacute;liser une cafeti&egrave;re</a></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#cafecekoi">qu'est-ce qu'une cafeti&egrave;re&nbsp;?</a></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#cafesortes">Une cafeti&egrave;re est une cafeti&egrave;re, mais il y en a plusieurs sortes</a></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#boutons">boutons marche-arr&ecirc;t ou autres r&eacute;glages</a></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#voyants">Voyants</a></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#cafemain">Programme principal</a></li>
           <li><a onclick="javascript=cacher_menu()"href="progobj.html#robusta">Des programmes plus robustes</a></li>
        </ul></li>
	 </ul></li>
     <li><a href="progobj.html#obj-classes">Classes et objets</a>
     <ul>
		<li><a onclick="javascript=cacher_menu()"href="progobj.html#obj-etat">L'&eacute;tat d'un objet</a></li>
		<li><a onclick="javascript=cacher_menu()"href="progobj.html#obj-comp">Le comportement d'un objet</a></li>
		<li><a onclick="javascript=cacher_menu()"href="progobj.html#obj-id">L'identit&eacute; d'un objet</a></li>
		<li><a onclick="javascript=cacher_menu()"href="progobj.html#obj-met">Des objets "m&eacute;tiers"</a></li>
		<li><a onclick="javascript=cacher_menu()"href="progobj.html#obj-rel">Relations entre objets</a></li>
	    </ul></li>
	</ul>
    </dd>
</dl>
<dl>
  <dt><a onclick="javascript=cacher_menu()"href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a onclick="javascript=cacher_menu()"href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a onclick="javascript=cacher_menu()"href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1>La programmation objet</h1>

<h2><a name="probl">Poser un probl&egrave;me</a></h2>

<p>Avant de se pr&eacute;cipiter sur son clavier pour
&eacute;crire un programme, il convient de r&eacute;fl&eacute;chir afin
de poser correctement le probl&egrave;me... Or, la
mani&egrave;re m&ecirc;me
dont le probl&egrave;me sera pos&eacute; influe sur l'&eacute;criture
du programme. D'o&ugrave; la
notion de "paradigme de programmation". Or, s'il est possible
d'impl&eacute;menter tous les paradigmes en utilisant n'importe quel
langage, cela sera plus ou moins facile selon le langage
utilis&eacute;. Ainsi, il est possible de
programmer en objet en utilisant le C... mais le C++, con&ccedil;u dans
cet
objectif, <strong>supporte</strong> la  programmation  objet, par  sa
syntaxe d'une  part, par les contr&ocirc;les  apport&eacute;s tant au  moment de la
compilation que lors de l'ex&eacute;cution d'autre part.</p>
<p><a href="#">top</a></p><hr />

<h2><a name="prog">La programmation objets expliqu&eacute;e aux
programmeurs</a></h2>

<p>Si  vous &ecirc;tes programmeur, mais  habitu&eacute; aux langages
de       programmation       "proc&eacute;duraux"       (<code>pascal</code>,
<code>fortran</code>,  <code>C</code>,  <code>perl</code>,  etc.),  ce
chapitre est pour  vous: il essaie d'expliquer comment  on peut passer
de  la programmation  proc&eacute;durale  &agrave; la  programmation  objet, via  la
programmation structur&eacute;e.</p>

<p><img src="61.gif" alt="Pour les terriens" width="20" />
Mais si vous &ecirc;tes d&eacute;butant en programmation, vous
&ecirc;tes encore des "gens normaux", dans ce cas vous pouvez passer
directement au chapitre suivant.<a href="#normaux"><img alt="apres" src="apres.gif" style="border: 0px solid ; width: 9px; height: 11px;" /></a>
</p>
<h2><a name="proc">L'approche proc&eacute;durale</a></h2>

<p>  Elle met l'accent  sur l'action repr&eacute;sent&eacute;e  par le
programme:  on  doit "faire  quelque  chose",  mais  cette chose  sera
ex&eacute;cut&eacute;e  par &eacute;tapes  successives.  Chaque  &eacute;tape elle-m&ecirc;me  peut &ecirc;tre
d&eacute;coup&eacute;e. On  arrive ainsi  &agrave; des d&eacute;coupages  de plus en  plus fins,
jusqu'&agrave; obtenir des fonctions &eacute;l&eacute;mentaires.  Certaines de ces
fonctions  peuvent  figurer  dans  des biblioth&egrave;ques,  cela
permettra de les r&eacute;utiliser plus tard pour d'autres projets.</p>

<h3><a name="fonct">Qu'est-ce qu'une fonction&nbsp;? </a></h3>

<p>Une fonction est un sous-programme caract&eacute;ris&eacute; par:</p>

<ul>
  <li>Son nom
  </li><li>Des donn&eacute;es en entr&eacute;e (les param&egrave;tres)
  </li><li>Une valeur de retour
  </li><li>Une action sur le syst&egrave;me, repr&eacute;sent&eacute;e par un algorithme
</li></ul>

<h3><a name="loca-glo">Variables locales ou globales</a></h3>

<p>Les  variables  peuvent  &ecirc;tre  locales,  mais  aussi
globales:  si <code>X</code>  est une  variable globale,  une fonction
<code>f1</code> peut  modifier la  valeur de <code>X</code>,  mais une
autre fonction  <code>f2</code> peut &eacute;galement  modifier cette valeur.
Un  programme  bien structur&eacute;  aura  le  moins  possible de  variables
globales... mais celles-ci ne pourront pas &ecirc;tre totalement &eacute;vit&eacute;es.</p>
<p><a href="#">top</a></p><hr /> 

<h2><a name="modul">L'approche modulaire</a></h2>

<p>Supposons que dans  notre programme,  deux fonctions
<code>f1</code>, <code>f2</code>  et <code>f3 </code>acc&egrave;dent toutes deux aux  variables
globales  <code>A</code>  et  <code>B</code>,  mais  <em>ce  sont  les
seules.</em>   Dans  ces   conditions,  peut-on   vraiment   dire  que
<code>A</code> et  <code>B</code> sont des  variables globales&nbsp;?<br />
Il est tentant  de regrouper ces fonctions et  ces variables: c'est la
notion  de  module.   Nous   pouvons  regrouper  les  trois  fonctions
<code>f1</code>,  <code>f2</code> et  <code>f3</code> d'une  part, les
deux variables <code>A</code> et  <code>B</code> d'autre part, dans un
module qui est constitu&eacute; de deux parties:</p>

<ul>
  <li>Une <em>interface</em> qui sp&eacute;cifie exactement les fonctions
      qui seront visibles depuis l'ext&eacute;rieur.
  </li><li>Une  <em>impl&eacute;mentation</em> qui  contient  des variables  d'une
      part, du code d'autre part. 
</li></ul>

<h3><a name="interf">Interface publique...</a></h3>

<p>Le module  comporte une  interface,  c'est-&agrave;-dire un
ensemble  de fonctions  (et &eacute;ventuellement  de variables),  qui seules
seront vues  par l'utilisateur du module.  Un  soin particulier
doit &ecirc;tre apport&eacute; &agrave; l'&eacute;criture de l'interface, puisque la modification
de  celui-ci  pourra avoir  des  cons&eacute;quences  sur  le  code
utilisateur du module. La seule modification de type d'une variable de
fonction, par exemple, peut entra&icirc;ner une impossibilit&eacute; de compilation
de l'application.</p>

<h3><a name="impl">...Impl&eacute;mentation cach&eacute;e</a></h3>

<p>Les algorithmes constituant  le corps  des fonctions
seront  cach&eacute;s, en  ce  sens qu'ils  ne  seront pas  visibles par  les
utilisateurs  du  module.  En  cons&eacute;quence,  il est  possible  de  les
modifier, par exemple pour am&eacute;liorer leur performance ou pour corriger
une erreur, sans que cela ait d'impact sur le reste du programme...  &agrave;
condition toutefois que l'interface  reste inchang&eacute;e (ou tout au moins
qu'il   y  ait   compatibilit&eacute;   entre  l'ancienne   et  la   nouvelle
interface). Il est m&ecirc;me possible de modifier le d&eacute;coupage en fonctions
du module, en  ajoutant ou en supprimant des  fonctions: tant qu'on ne
touche pas  aux fonctions d&eacute;clar&eacute;es dans l'interface,  pas de probl&egrave;me
par rapport &agrave; l'ext&eacute;rieur.</p>

<h3><a name="encaps">Encapsulation des donn&eacute;es</a></h3>

<p>Les variables  <code>A</code> et
<code>B</code> &eacute;tant  cach&eacute;es, on peut modifier leur type
tout en limitant l'impact  sur l'ensemble du programme.  D'autre part,
gr&acirc;ce &agrave; l'encapsulation, et en supposant que la fonction <code>f4</code> n'est
pas int&eacute;gr&eacute;e  &agrave; ce module, on  est s&ucirc;r d'&eacute;viter le  bogue suivant (pas
toujours tr&egrave;s simple &agrave; d&eacute;tecter):

</p>
<pre class="demo">
void f4 (){
   int A1;
   A=0; /* ERREUR, on voulait &eacute;crire A1=0 */
}</pre>

<p>Si <code>A</code> avait &eacute;t&eacute; une variable globale, la ligne
<code>A=0</code>, qui est une erreur du point-de-vue du programmeur,
n'aurait pas &eacute;t&eacute; signal&eacute;e par le compilateur,
puisque <code>A</code>
est   accessible.    Si   <code>A</code>  est   "cach&eacute;e"
(encapsul&eacute;e dans  un module), le compilateur d&eacute;tectera  une erreur: il sera alors ais&eacute; de la corriger.</p>

<h3><a name="proto">Prototypage</a></h3>

<p>Le  m&eacute;canisme d'encapsulation des  donn&eacute;es, lorsqu'il
est  support&eacute; par le  langage de  programmation, permet  de travailler
ais&eacute;ment en  &eacute;quipe sur  un m&ecirc;me projet:  chaque programmeur  &eacute;crit un
module diff&eacute;rent: il faut que tout le monde soit d'accord
sur l'interface de chaque module, mais le codage
lui-m&ecirc;me peut se faire par chacun de mani&egrave;re ind&eacute;pendante. <br /> Il est
&eacute;galement possible de  travailler par prototypes: lors de  la phase de
prototypage, l'interface  est &eacute;crit mais  le code est  incomplet. Cela
permet  toutefois  d'utiliser  l'interface  du  module  dans  d'autres
parties de l'application, et ainsi de tester la coh&eacute;rence du mod&egrave;le.</p>
<p><a href="#">top</a></p><hr /> 

<h2><a name="obj">L'approche objets</a></h2>

<p>Il est possible  de d&eacute;passer l'approche modulaire. Supposons que  l'on veuille,  dans un  programme,  d&eacute;finir une
structure de pile de caract&egrave;res.  On pourra &eacute;crire un module, avec les
deux fonctions interfaces suivantes:</p>

<pre class="demo">
char pop();
void push (char);
</pre>

<p>On peut dire  qu'un tel module est un  "arch&eacute;o-objet".  Mais nous aimerions   
r&eacute;pondre aux trois questions suivantes:</p>

<ol>
  <li>Comment faire si nous avons besoin de plusieurs piles dans notre
      programme&nbsp;?
  </li><li>Comment classer nos objets par "familles d'objets"&nbsp;?
  </li><li>Comment faire si nous avons besoin de piles d'entiers&nbsp;?
</li></ol>

<h3><a name="obj-typ">Des objets int&eacute;gr&eacute;s au syst&egrave;me de typage</a></h3>

<h4>Donner un num&eacute;ro d'identification aux piles:</h4>

<p>On ajoute   un   param&egrave;tre   aux   fonctions
<code>pop</code>   et   <code>push</code>   d&eacute;finies   ci-dessus,   en
l'occurence un  num&eacute;ro d'identification.  D&egrave;s lors,  
on peut g&eacute;rer autant  de piles que l'on veut. Les fonctions
interfaces deviennent:</p>

<pre class="demo">char pop(int Id);<br />void push(int Id, char c);</pre>

<h4>La solution du C++</h4>

<p>Le C++ apporte  une solution beaucoup plus puissante:
il permet au programmeur de d&eacute;finir  un <em>"un type de donn&eacute;es qui se
comporte</em> [presque] <em>de la  m&ecirc;me mani&egrave;re qu'un type pr&eacute;d&eacute;fini".
<a href="types.html#class"><img alt="apres" src="apres.gif" /></a></em>  Le module  devient
alors tout  simplement une  d&eacute;claration de type, on peut d&eacute;clarer des variables de ce type; 
Les fonctions sont "attach&eacute;es" &agrave; ces variables, de sorte qu'on &eacute;crira dans le code 
des lignes du style:</p>

<pre class="demo">
class stack {
   char pop();
   void push(char c);
}

stack A;
stack B;
stack C;

A.pop();
C.push(B.pop());
</pre>

<h4>Op&eacute;rations sur les objets</h4>

<p>La phrase "type de donn&eacute;es qui se comporte presque de
la  m&ecirc;me   mani&egrave;re  qu'un  type  pr&eacute;d&eacute;fini"   entra&icirc;ne  de  nombreuses
cons&eacute;quences. Par exemple, on pourra d&eacute;clarer un tableau d'objets
de type pile de la mani&egrave;re suivante:</p>

<pre class="demo">stack[10] Stacks;<br /></pre>

<p>Une variable pourra &ecirc;tre initialis&eacute;e:</p>

<pre class="demo">stack S1=10;<br /></pre>

<p>On pourra recopier une variable dans une autre gr&acirc;ce &agrave; l'op&eacute;rateur
d'affectation:</p>

<pre class="demo">stack A;<br />stack B;<br />...<br />B=A;<br /></pre>

<p>On pourra faire un transtypage (cast) d'un type dans un autre:</p>

<pre class="demo">stack A;<br />int B;<br />...<br />B = (int) A;<br /></pre>

<p>On  pourra   m&ecirc;me  additionner   deux   piles  avec
l'op&eacute;rateur <code>+</code>, les  comparer avec <code>&gt;</code>, etc.
Le  probl&egrave;me   est  bien  s&ucirc;r:  quelle  signification   donner  &agrave;  ces
op&eacute;rations&nbsp;?  Si  l'initialisation ne pose pas  trop de probl&egrave;me,
si l'affectation  semble &eacute;galement &eacute;vidente,  que signifie additionner
ou  comparer deux piles&nbsp;?   Ces op&eacute;rateurs  &eacute;tant d&eacute;finis  par la
personne qui  d&eacute;finit l'objet,  c'est &eacute;galement &agrave;  elle de  d&eacute;finir la
signification pr&eacute;cise des op&eacute;rateurs  du langage pour cet objet. C'est
ce qu'on  appelle la <em>surcharge  des op&eacute;rateurs</em>. Il  n'est pas
obligatoire   de  surcharger  les   op&eacute;rateurs:  si,   dans  l'exemple
pr&eacute;c&eacute;dent, l'op&eacute;rateur <code>+</code> n'est pas surcharg&eacute;, l'op&eacute;ration
<code>A&nbsp;+&nbsp;B</code> renverra tout  simplement une erreur &agrave; la
compilation.</p>

<p><a href="#">top</a></p><hr /> 

<h3><a name="class-obj">Classer les objets</a></h3>

<p>Nous  avons maintenant &agrave; notre  disposition autant de
types de  variables  que nous voulons.   Nous allons
avoir rapidement besoin de d&eacute;finir une classification.</p>

<h4>Un exemple tir&eacute; de la vie quotidienne</h4>

<p>En effet, si nous prenons une comparaison avec la vie
quotidienne,  nous   pouvons  dire  que  nous   avons  &agrave;  notre
disposition:  un couteau  de cuisine,  une Twingo,  un  tourne-vis, un
couteau  &agrave; beurre,  une 205,  un couteau  &agrave; pain...   et un  raton
laveur.  On sent bien que nous aimerions &eacute;crire que nous
avons  des  outils  et  des  voitures;  en  l'occurrence  un
tourne-vis  et plusieurs  sortes de  couteaux constituent  les outils,
alors que la 205 et la Twingo sont des voitures.</p>

<h4>Un objet de type "shape"</h4>

<p>Suposons que nous voulions d&eacute;finir une s&eacute;rie d'objets
permettant  de dessiner  des formes  &agrave; l'&eacute;cran  ("circle", "triangle",
"square"). Nous pouvons proc&eacute;der de plusieurs mani&egrave;res:</p>

<h5>La m&eacute;thode "tout &agrave; plat"</h5>

<p>C'est celle  correspondant aux  couteaux  de cuisine
ci-dessus:  il suffit  de  d&eacute;finir trois  objets  diff&eacute;rents, un  pour
chaque forme d&eacute;sir&eacute;e. On aura alors des d&eacute;clarations du style:</p>

<pre class="demo">class circle;<br />class triangle;<br />class square;<br /></pre>

<p>Si mettre tout sur  le m&ecirc;me plan est stupide dans la  vie quotidienne, ce  n'est pas  plus malin
dans  un  programme  informatique...   mais en  outre,  cette  m&eacute;thode
conduira &agrave;  r&eacute;&eacute;crire sans arr&ecirc;t la  m&ecirc;me chose... justement  ce que le
C++ voudrait &eacute;viter.</p>

<h5>La m&eacute;thode &eacute;tiquette</h5>

<p>D&eacute;j&agrave; un peu mieux... elle consiste &agrave; consid&eacute;rer qu'un
cercle, un  triangle, un carr&eacute; sont  des formes: nous  cr&eacute;ons donc une
classe appel&eacute;e <code>shape</code>, d&eacute;finie de la mani&egrave;re suivante:</p>

<pre class="demo">
enum kind {circle, triangle, square};
class shape {
   point center;
   color col;
   kind k;
public:
   point where() {return center};
   void draw();
};</pre>

<p>Du point-de-vue de la conception, cela revient &agrave; dire
qu'un  cercle est une  forme ayant  l'&eacute;tiquette "circle"...   pas mal,
mais pas fameux, car cela revient aussi &agrave; dire qu'il n'y a pas plus de
diff&eacute;rence entre un cercle rouge  et un cercle noir qu'entre un cercle
et un  carr&eacute;... m&ecirc;me sans  &ecirc;tre un as  en g&eacute;om&eacute;trie, on sent  bien que
cela ne correspond pas &agrave; la r&eacute;alit&eacute;...<br /> Du point-de-vue de
l'&eacute;criture du  code, la fonction <code>draw</code> va  tester le champ
<code>kind</code>,  et  suivant  les   cas  dessinera  un  cercle,  un
triangle,    un    carr&eacute;...    cela    pr&eacute;sente    quelques    s&eacute;rieux
inconv&eacute;nients:</p>

<ul>
  <li>Plus le nombre de formes sera grand, plus la fonction draw sera
      longue.
  </li><li>Si je rajoute une nouvelle forme (ellipse, par exemple), je vais
      devoir modifier la fonction draw... avec tous les risques
      d'ajout d'erreurs.&nbsp;<br />

</li></ul>

<p>Au fond,  pour reprendre l'exemple concret pr&eacute;c&eacute;dent,
tout se passe comme si les ing&eacute;nieurs de Renault, lorsqu'ils ont con&ccedil;u
la  Safrane, avaient  r&eacute;ouvert  le  dossier de  la  Twingo et  avaient
modifi&eacute; des dessins de celle-ci, en ajoutant des erreurs. R&eacute;sultat: le
jour de la sortie de la Safrane, les Twingo qui sortent de l'usine ont
trois roues...</p>

<p>En fait, ce qui manque ici, c'est de distinguer entre
propri&eacute;t&eacute;s g&eacute;n&eacute;riques,  communes &agrave; tous  les objets de type  shape, et
propri&eacute;t&eacute;s sp&eacute;cifiques &agrave; certaines formes.</p>

<h5>La m&eacute;thode par l'h&eacute;ritage</h5>

<p>L'h&eacute;ritage <a href="heritage.html"><img alt="apres" src="apres.gif" style="border: 0px solid ; width: 9px; height: 11px;" /></a> est pr&eacute;cis&eacute;ment  l'outil qui  va nous
permettre  d'impl&eacute;menter  cette   distinction:  cela  passera  par  la
d&eacute;finition de 4 classes.  Une classe "abstraite" comportant toutes les
propri&eacute;t&eacute;s  g&eacute;n&eacute;riques,  et trois  classes  comportant les  propri&eacute;t&eacute;s
sp&eacute;cifiques de chaque  forme particuli&egrave;re. Voici le code  de la classe
de base:</p>

<pre class="demo">
class shape {
   point center;
   color col;
public:
   point where() {
      return center;
   };
   virtual void draw()=0;
}</pre>

<h6>La classe de base</h6>

<p>La d&eacute;claration de fonction  <a href="heritage.html#fct-virt"><img alt="apres" src="apres.gif" /></a> 
<code>draw</code> signifie qu'une forme  doit pouvoir &ecirc;tre dessin&eacute;e, mais  on ne sait pas
encore, &agrave; ce stade, comment  elle sera dessin&eacute;e. Une cons&eacute;quence de la
pr&eacute;sence de cette  fonction est qu'il est impossible  d'&eacute;crire dans un
code quelque chose comme:</p>

<pre class="demo">shape forme1;<br /></pre>

<p>Le    compilateur   refusera   cela,    parce   que
<code>shape</code> est  une classe abstraite,  c'est-&agrave;-dire une classe
qui  contient au moins  une fonction  virtuelle. Il  ne sait  pas quoi
faire de cette  fonction.  En fait, cela est  assez compr&eacute;hensible: si
je vous dis, "dessine-moi une forme"...  et si vous &ecirc;tes un ordinateur
(donc  compl&egrave;tement d&eacute;pourvu  d'imagination) vous  ne saurez  pas quoi
dessiner comme forme.  De m&ecirc;me, si je dis "cette  variable est de type
forme", c'est  &agrave; peu pr&egrave;s  comme si je  disais "cette variable  est un
machin". Pas tr&egrave;s pr&eacute;cis... Par  contre, rien ne m'emp&ecirc;che de passer &agrave;
une fonction une variable de type <code>shape</code>:</p>

<pre class="demo">void arriere_plan (shape s);
</pre>

<p>Je ne  peux pas dire "Bien, aujourd'hui je  vais cr&eacute;er un machin", mais  n'importe qui a le droit de demander son machin &agrave; un ami...</p>

<h6>Les classes d&eacute;riv&eacute;es</h6>

<p>Un cercle, un triangle, un carr&eacute; sont des formes ayant chacune leur
particularit&eacute;. Nous &eacute;crirons cela de la mani&egrave;re suivante:</p>

<pre class="demo">
class circle: public shape {
   int radius;
   public:
   void draw();
};

class triangle: public shape {
   ...;
   public:
      void draw();            // dessine-moi un triangle
      coord getheight(1);     // renvoie la hauteur principale  du triangle
};

class square: public shape {
   int cote;<br />public:
   void draw();
};

</pre>

<p>Ainsi,  nos trois  classes  d&eacute;riv&eacute;es "h&eacute;ritent"  des
caract&eacute;ristiques g&eacute;n&eacute;riques de leur  classe de base, mais ajoutent des
caract&eacute;ristiques particuli&egrave;res  propres &agrave; chacune.  Du point-de-vue de
la mod&eacute;lisation, nous avons bien  trois objets, qui sont un cercle, un
triangle, un  carr&eacute;... mais ces  trois objets sont  <em>aussi</em> une
forme.  On a  donc r&eacute;ussi &agrave; introduire un  fort degr&eacute; d'abstraction de
donn&eacute;es... tout  en gardant, &agrave;  l'int&eacute;rieur des fonctions, du  code C,
donc "proche de la machine". <br />
Du point-de-vue de l'impl&eacute;mentation,  cela nous conduit &agrave; &eacute;crire trois
versions  diff&eacute;rentes de  la fonction  <code>draw</code>. Lorsque je devrai rajouter  une nouvelle forme, je n'aurai pas &agrave; revenir sur  les formes d&eacute;j&agrave;  d&eacute;finies, il y  a donc moins  de risques d'erreurs.</p>

<h3><a name="piles">D&eacute;finir des piles de n'importe quoi</a></h3>

<p>Revenons &agrave;  notre  histoire de  pile de  caract&egrave;res:
justement, c'est  d'une pile  d'entiers dont j'ai  besoin. Et  dans un
autre programme,  j'aurai besoin d'une  pile d'autre chose...   Ce cas
peut-il  se   traiter,  lui  aussi,   par  la  m&eacute;thode   d'h&eacute;ritage &nbsp;?
Certainement pas:  d'un point-de-vue conceptuel,  on ne peut  pas dire
qu'une pile d'entiers et une pile de r&eacute;els soient des cas particuliers
d'un objet  plus g&eacute;n&eacute;ral, comme  a pu le  faire avec les  cercles, les
triangles ou  les carr&eacute;s... par contre,  on peut dire  qu'une pile est
toujours une pile,  et que si on peut empiler des  caract&egrave;res il n'y a
aucune raison  pour qu'on  ne puisse pas  empiler autre chose  que des
caract&egrave;res, en r&eacute;utilisant les m&ecirc;mes algorithmes.  De m&ecirc;me dans la
plupart  des langages,  on peut  d&eacute;clarer des  tableaux  d'entiers, de
r&eacute;els,  de  structures... Le  C++
permettra  d'impl&eacute;menter ce concept par  des types  param&eacute;tr&eacute;s (encore appel&eacute;s
des <i>mod&egrave;les</i>. On  pourra par
exemple   d&eacute;finir    des   piles   de   formes    en   d&eacute;clarant:   <a href="modeles.html"><img alt="apres" src="apres.gif" /></a></p>

<pre class="demo">stack&lt;shape&gt; pile-de-formes;<br /></pre>

<h3><a name="heritcor">H&eacute;ritage correct: faire du neuf avec du vieux</a></h3>

<p>Une cons&eacute;quence de ce qui pr&eacute;c&egrave;de est que nous allons
&ecirc;tre capables de "faire du neuf avec du vieux": puisque je sais passer
&agrave; une fonction une variable de type <code>shape</code>, je peux d&egrave;s la
premi&egrave;re version du  programme &eacute;crire par exemple une  fonction qui me
tapisse mon &eacute;cran  avec toujours la m&ecirc;me forme. Lors  de l'appel de la
fonction, je devrai bien s&ucirc;r pr&eacute;ciser si je veux dessiner des cercles,
des carr&eacute;s  ou des triangles... mais  surtout, si dans dix  ans ils me
prend  la fantaisie  de vouloir  dessiner  des ballons  de rugby  (des
ellipses),   il    me   suffira   de    cr&eacute;er  un   objet    de   type
<code>ellipse</code>,  et de  recompiler  <em>le vieux  programme</em>
qui, lui,  restera inchang&eacute;. Le  m&eacute;canisme d'h&eacute;ritage et  de fonctions
virtuelles  me  garantit  que   cela  fonctionnera.  D'o&ugrave;  une  &eacute;norme
souplesse  pour  faire  &eacute;voluer  les  programmes. <br />
</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Cela fonctionnera  <em>uniquement</em> &agrave; 
condition que  les  relations  d'h&eacute;ritages  soient  "proprement"  d&eacute;finies.   En
particulier,  lorsqu'une  classe  h&eacute;rite  d'une autre,  les  fonctions
virtuelles  de  la  classe  d&eacute;riv&eacute;e  doivent  <em>faire au  moins
autant de choses</em> que celles  de la classe de base,  et elles ne <em>doivent
pas  avoir des  exigences sup&eacute;rieures  </em>. En  d'autres  termes, la
classe d&eacute;riv&eacute;e doit &ecirc;tre <em>une  extension</em> de sa classe de base,
<em>pas une restriction</em>.</p></div>

<p><a href="#">top</a></p><hr /> 

<h2><a name="biblio">Des biblioth&egrave;ques d'objets</a></h2>

<p>Il  est   possible  d'&eacute;crire   des  biblioth&egrave;ques
d'objets,  qui  utiliseront  soit  la g&eacute;n&eacute;ricit&eacute;  soit  les  relations
d'h&eacute;ritages.   Ces   biblioth&egrave;ques    seront   utilisables   par   les
programmeurs,  qui  pourront   &eacute;ventuellement  continuer  &agrave;  cr&eacute;er  de
nouveaux  objets qui h&eacute;riteront  des objets  de la  biblioth&egrave;que. Nous verrons ici la <code>stdlib</code></p>

<p><a href="#">top</a></p><hr /> 

<h2><a name="normaux">La programmation objets expliqu&eacute;e aux gens normaux</a></h2>

<p>Ce chapitre  s'adresse aux gens "normaux",  c'est-&agrave;-dire aux personnes
n'ayant   pas   d'exp&eacute;rience   de   programmation,  quelque  soit  le  langage utilis&eacute;.  Les  programmeurs
chevronn&eacute;s, eux, feraient mieux  de lire le chapitre pr&eacute;c&eacute;dent 
<a href="#prog"><img alt="avant" src="avant.gif" /></a></p>

<h3><a name="cafeteria">Une caf&eacute;t&eacute;ria informatis&eacute;e</a></h3>

<p>Imaginons que nous devons mod&eacute;liser une caf&eacute;t&eacute;ria  automatique, comme  on en
trouve souvent sur les aires  de repos des autoroutes, constitu&eacute;e d'un
certain nombre de cafeti&egrave;res en libre-service.</p>

<p>Pour corser la chose, il y a trois types
diff&eacute;rents de cafeti&egrave;res:
</p><ul>
  <li>Les machines &agrave; caf&eacute; utilisant du caf&eacute; en grain
  </li><li>Les machines &agrave; caf&eacute; utilisant du caf&eacute; moulu
  </li><li>Les machines &agrave; caf&eacute; utilisant du caf&eacute; soluble
</li></ul>

<p><a href="#">top</a></p><hr /> 

<h3><a name="cafproc">Le caf&eacute; en programmation proc&eacute;durale</a></h3>

<p>En  programmation   proc&eacute;durale,   on  s'int&eacute;ressera
essentiellement  &agrave;   ce  que   la  machine  doit   <em>faire</em>;  en
l'occurrence, on r&eacute;fl&eacute;chira &agrave; la mani&egrave;re de pr&eacute;parer le caf&eacute; lorsqu'un
utilisateur l'aura  demand&eacute;. Les <em>objets</em>  de l'application (en
l'occurrence  les  sp&eacute;cifications  des  diff&eacute;rentes machines  &agrave;  caf&eacute;)
n'occuperont pas une place centrale dans notre r&eacute;flexion.</p>

<p>Ainsi, dans notre exemple, on &eacute;crira trois
algorithmes diff&eacute;rents, correspondant aux trois mani&egrave;res de faire le
caf&eacute; suivant le type de machine. Cela pourra par exemple se traduire
par une fonction du type:</p>

<pre class="demo">int faire_le_cafe (int cafid, int caftyp, int cafforce);<br /></pre>

<p>o&ugrave; <code>cafid</code>  est  un "identificateur  de
cafeti&egrave;re" (il  faut bien  donner une adresse  ou un nom  diff&eacute;rents &agrave;
chaque cafeti&egrave;re  pour pouvoir les  diff&eacute;rentier), <code>caftyp</code>
est   le    type   correspondant   de   la    cafeti&egrave;re,   alors   que
<code>cafforce</code> est un nombre (de  1 pour du jus de chaussette &agrave;
10  pour  du caf&eacute;  italien)  donnant  une id&eacute;e  de  la  force du  caf&eacute;
d&eacute;sir&eacute;. La fonction <code>faire_le_cafe</code> cache sous un interface
commun plusieurs algorithmes diff&eacute;rents  (au moins un pour chaque type
de  cafeti&egrave;re);  il  peut  &ecirc;tre astucieux  d'ailleurs  d'&eacute;crire  trois
fonctions  diff&eacute;rents, d'o&ugrave;  la  structure suivante  pour la  fonction
<code>faire_le_cafe</code>:</p>

<pre class="demo">int faire_le_cafe(int cafid, int caftyp, int cafforce) {<br />    int rvl=0;<br />    switch (caftyp) {<br />       case CAFE_EN_GRAIN:<br />            rvl = faire_le_cafe_en_grain(cafid,cafforce);<br />            break;<br />       case CAFE_MOULU:<br />            rvl = faire_le_cafe_moulu(cafid,cafforce);<br />            break;<br />       case CAFE_SOLUBLE:<br />            rvl = faire_le_cafe_soluble(cafid,cafforce);<br />            break;<br />       default:<br />            rvl = 9;  /* Erreur, type inconnu */<br />    }<br />    return rvl;<br />}<br /></pre>

<p> Il faut conna&icirc;tre pour chaque machine quel est son
type, cela peut faire l'objet d'un tableau <code>caf_types</code>:</p>

<pre class="demo">int caf_types[15];<br /></pre>

<p>
Pour conna&icirc;tre le  type de la machine num&eacute;ro 10, il  suffit de lire la
valeur de <code>caf_types[10]</code>.</p>

<p> Par  ailleurs, on a besoin de conna&icirc;tre l'&eacute;tat
des  diff&eacute;rentes machines  &agrave; caf&eacute;;  par exemple,  un  client a-t-il
demand&eacute;  un  caf&eacute;&nbsp;?   On  peut  donc  imaginer une  fonction,  appel&eacute;e
<code>lire_etat</code>, qui ira lire l'&eacute;tat de la machine &agrave; caf&eacute;. Elle
renverra par exemple le code 0  pour dire "machine pr&ecirc;te", et le code 1
pour dire  "quelqu'un a demand&eacute; un  caf&eacute;".  On peut  bien s&ucirc;r imaginer
encore d'autres codes pour dire par exemple que le r&eacute;servoir d'eau est
vide, etc.</p>

<p>Un programme d&eacute;clenchant N machines afin qu'elles fassent toutes du caf&eacute; ressemblera en fin de 
compte &agrave; celui-ci:</p>

<pre class="demo">for (int i=0; i &lt; N; i++) {<br />    if (lire_etat(i)==1) {<br />       int rvl = faire_le_cafe(i,caf_types[i],cafforce);<br />       if (rvl == 0) {<br />          printf "le cafe est pret\n";<br />       } else {<br />          printf "Machine en panne\n";<br />       };<br />    }<br />}<br /></pre>

<p><a href="#">top</a></p><hr /> 

<h3><a name="cafobj">Le caf&eacute; en programmation objet</a></h3>

<p>Tout cela est bien beau, mais on voit d'embl&eacute;e que
cette mani&egrave;re de proc&eacute;der peut poser quelques probl&egrave;mes:</p>

<ul>

  <li>Ecrite de cette mani&egrave;re, la programmation n'a qu'un tr&egrave;s lointain
      rapport avec la mani&egrave;re dont nous pensons, de sorte qu'elle a un
      c&ocirc;t&eacute; artificiel, y compris lors de la conception du
      programme.</li>
  <li>Le programme risque de se r&eacute;v&eacute;ler fort peu robuste:
      en effet, si l'on d&eacute;sire le modifier afin
      d'ajouter un nouveau type de machine &agrave; caf&eacute;, on devra modifier
      la fonction <code>faire_le_cafe</code>, afin d'ajouter une
      condition &agrave; l'instruction <code>switch</code>. Pour peu que le
      programme soit complexe, il y aura un grand nombre de fonctions
      &eacute;crites sur le mod&egrave;le de <code>faire_le_cafe</code>. Il n'est
      pas &eacute;vident de les retouver toutes lorsqu'on doit ajouter un
      nouveau mod&egrave;le de cafeti&egrave;re. D'autant plus qu'elles seront
      probablement dispers&eacute;es un peu partout dans le code. Lors de
      cette modification, on risque d'ajouter des erreurs dans
      les lignes de code <i>correspondant aux cafeti&egrave;res existant
      d&eacute;j&agrave;</i>.</li>
</ul>

<h4><a name="cafmodele">Mod&eacute;liser une cafeti&egrave;re</a></h4>

<p>Il est bien  plus naturel  de raisonner  en termes
d'objets,  car c'est notre  mani&egrave;re quotidienne  de penser:  il s'agit
en effet de faire fonctionner un ensemble <em>d'objets</em>. Ceux-ci:</p>

<ul>
  <li>Ont un grand nombre de points en commun (il s'agit toujours de machines &agrave; caf&eacute;)
  </li><li>Sont cependant de plusieurs types
  </li><li>Ont une certaine structure (en fait, ils contiennent d'autres
      objets), ainsi qu'un comportement vis-&agrave;-vis du monde ext&eacute;rieur:
      <ul>
	<li>On peut leur "donner l'ordre" de faire le caf&eacute;.
	</li><li>On peut leur "demander" dans quel &eacute;tat ils sont. 
      </li></ul>
</li></ul>

<p>La   programmation   objets   va   permettre   de
<em>mod&eacute;liser</em>  cet   ensemble  d'objets et  ainsi d'&eacute;crire un  programme bien plus proche  de la
mani&egrave;re de  penser humaine.  D'autre  part, la structure  du programme
est telle que  la modification d'un objet ne devrait  pas avoir
d'impact  sur les  caract&eacute;ristiques d'un autre  objet, ou  sur les 
caract&eacute;ristiques g&eacute;n&eacute;rales  du programme; le programme  sera donc plus
robuste, et plus facile &agrave; maintenir.</p>

<h4><a name="cafecekoi">qu'est-ce qu'une cafeti&egrave;re&nbsp;?</a></h4>

<p>  Nous dirons qu'une cafeti&egrave;re est  un objet. Cet objet est un ensemble de composants:<br />
</p><ul><li>R&eacute;servoir d'eau
  </li><li>R&eacute;servoir de caf&eacute;
  </li><li>R&eacute;servoir de sucre
  </li><li>R&eacute;servoir de cuillers
  </li><li>R&eacute;servoir de gobelets
  </li><li>R&eacute;sistance chauffante
</li></ul>

<p> Lorsque nous  &eacute;crirons le programme, il nous suffira
de repr&eacute;senter  ces objets par  des <em>variables</em>, ainsi  il sera
possible d'&eacute;crire:</p>

<pre class="demo">
cafetiere A;
</pre>

<p>de la m&ecirc;me  mani&egrave;re qu'on &eacute;crit en C:</p>

<pre class="demo">
int B;
</pre>

<h4><a name="cafesortes">Une cafeti&egrave;re est une cafeti&egrave;re, mais il y en a plusieurs sortes</a></h4>

<p>Par  ailleurs, nous avons vu  qu'il pouvait exister
plusieurs types de cafeti&egrave;res: or, m&ecirc;me si une machine avec r&eacute;serve de
caf&eacute; en grain est de  conception diff&eacute;rente d'une machine avec r&eacute;serve
de  caf&eacute; en  poudre, nous  savons  parfaitement qu'il  s'agit dans les
deux cas de
cafeti&egrave;res,  c'est-&agrave;-dire  que  ces  deux objets
ont  un grand  nombre de caract&eacute;ristiques communes. Nous  allons
exprimer cette  relation dans notre programme objet,  en utilisant les
relations  d'<em>h&eacute;ritage</em>: nous  aurons donc  un nouveau  type de
variable    (<code>cafetiere_grain</code>),     diff&eacute;rent    du    type
<code>cafetiere</code>, mais  qui <em>h&eacute;rite</em> de ce  type un grand
nombre  de   caract&eacute;ristiques.   Simplement,  il   <em>ajoute</em>
de
nouvelles caract&eacute;ristiques &agrave; ce type. Ces
caract&eacute;ristiques nous
permettront de pr&eacute;ciser &agrave; la machine le
proc&eacute;d&eacute; exact pour faire le caf&eacute;, alors que les
caract&eacute;ristiques communes permettent
de dire &agrave; quelles conditions un objet peut l&eacute;gitimement
&ecirc;tre appel&eacute;
cafeti&egrave;re.</p>

<h4><a name="boutons">Boutons marche-arr&ecirc;t ou autres r&eacute;glages</a></h4>

<p>Lorsqu'on  se trouve &agrave; l'ext&eacute;rieur  de la cafeti&egrave;re, on n'a
pas acc&egrave;s  aux pi&egrave;ces composant la cafeti&egrave;re. De m&ecirc;me,
dans notre programme, un m&eacute;canisme permettra de <em>cacher</em> les
objets situ&eacute;s &agrave; l'int&eacute;rieur de l'objet <code>cafetiere</code>.<br />
  Par contre,  on a un moyen  de remplir  le r&eacute;servoir d'eau ou le
r&eacute;servoir de caf&eacute;, 
de savoir combien  d'eau il reste dans le  r&eacute;servoir, combien de sucre
dans la  r&eacute;serve de sucre,  etc.  De m&ecirc;me,  on a plusieurs  boutons de
r&eacute;glage (caf&eacute; fort, moyen, faible),  et on a un bouton pour d&eacute;clencher
la mise en  route du caf&eacute;.  Dans notre mod&egrave;le,  cela correspond &agrave; 
des <code>fonctions</code> que nous appellerons <em>m&eacute;thodes</em>,
ou  encore  <em>fonctions-membres</em>.   Les  fonctions-membres  sont
partie  prenante de  l'objet,  de la  m&ecirc;me  mani&egrave;re que  le bouton  de
marche-arr&ecirc;t de la  (vraie) cafeti&egrave;re est une partie  de la cafeti&egrave;re.
Mais il s'agit de la  partie "interface" avec le monde ext&eacute;rieur. Pour
faire  du  caf&eacute;  italien,   nous  pourrons  alors  &eacute;crire  dans  notre
programme:</p>

<pre class="demo">cafetiere_grain A;<br />A.force(10);<br />A.faire_le_cafe();<br /></pre>

<p>On   voit  que  le  style   de  programmation  est
consid&eacute;rablement diff&eacute;rent de ce  qui pr&eacute;c&egrave;de; alors que pr&eacute;c&eacute;demment,
le num&eacute;ro de  la cafeti&egrave;re, le type de  cafeti&egrave;re, et peut-&ecirc;tre encore
d'autres  informations  sont  pass&eacute;es  en  param&egrave;tre  &agrave;  une  fonction
<code>faire_le_cafe</code>,      cette      fois      la      fonction
<code>faire_le_cafe</code>  est  directement  int&eacute;gr&eacute;e &agrave;  la  variable
<code>A</code>, ce  qui est  bien plus proche  de la r&eacute;alit&eacute;:
c'est bien la  machine &agrave; caf&eacute;, qui int&egrave;gre  un m&eacute;canisme permettant de
faire  du  caf&eacute;;  de   la  m&ecirc;me  mani&egrave;re,  l'algorithme  expliquant  &agrave;
l'ordinateur comment  le caf&eacute;  devra &ecirc;tre fait  se trouve  "int&eacute;gr&eacute;" &agrave;
l'objet  de type <code>cafetiere</code>.<br />  Plus pr&eacute;cis&eacute;ment,  on va
pouvoir  dire  au programme  que  toute  cafetiere  doit avoir  <em>au
moins</em> une fonction <code>faire_le_cafe</code>, mais cette fonction sera  tr&egrave;s diff&eacute;rente suivant le type de
cafeti&egrave;re.  La  seule chose  de s&ucirc;re, c'est  que cette  fonction devra
exister.    <br />  Puisque   la   fonction  est   int&eacute;gr&eacute;e  &agrave;   l'objet
<code>cafetiere</code>, celui-ci  peut aller chercher  les informations dont
il a besoin <em>directement &agrave; l'int&eacute;rieur</em> de l'objet: c'est ainsi
que le param&egrave;tre <code>cafforce</code> de tout-&agrave;-l'heure a &eacute;t&eacute; retir&eacute;;
il n'est  plus n&eacute;cessaire,  car la force  du caf&eacute;  a &eacute;t&eacute; fix&eacute;e  par la
fonction <code>force()</code>, qui est elle aussi une m&eacute;thode de notre
objet.  A  l'inverse de la  fonction <code>faire_le_cafe()</code>, par
contre, on peut tr&egrave;s bien imaginer que pour certains types de machines
la fonction <code>force()</code> est inexistante (dans ce cas la force
du  caf&eacute; est  pr&eacute;d&eacute;finie et  ne peut  &ecirc;tre ajust&eacute;e  par l'utilisateur:
c'est moins confortable,  mais &ccedil;a fait tout-de-m&ecirc;me du  caf&eacute;). Donc la
fonction     <code>force()</code>      sera     une     m&eacute;thode     de
<code>cafetiere_grain</code>,              <em>pas</em>             de
<code>cafetiere</code>.</p>


<h4><a name="voyants">Voyants</a></h4>

<p>La fonction appel&eacute;e pr&eacute;c&eacute;demment <code>lire_etat</code> devient, elle
aussi, une fonction-membre: elle joue alors le r&ocirc;le d'un voyant.</p>

<h4><a name="cafemain">Programme principal</a></h4>

<p>Nous  pouvons maintenant r&eacute;&eacute;crire  l'&eacute;bauche de notre
programme: </p>

<pre class="demo">cafetiere C[100];<br /><br />... initialiser C[i] avec des objets de type cafetiere_grain,<br />cafetiere_poudre, cafetiere_soluble ...<br /><br />for (int i=0; i &lt; N; i++) {<br />    if (C[i].lire_etat()==1) {<br />       int rvl = C[i].faire_le_cafe();<br />       if (rvl == 0) {<br />          printf "le cafe est pret\n";<br />       } else {<br />          printf "Machine en panne\n";<br />       };<br />    }<br />}<br /></pre>

<h4><a name="robusta">Des programmes plus robustes</a></h4>

<p>Puisque  les objets de  type <code>cafetiere</code>
sont tout simplement des variables  comme les autres, il est possible,
par  exemple, de  les ranger  dans  un tableau.   Chaque &eacute;l&eacute;ment  d'un
tableau  sera  donc  une  <code>cafetiere</code>,  cependant  certains
&eacute;l&eacute;ments  peuvent &ecirc;tre un  objet de  type <code>cafetiere_grain</code>
alors    que    d'autres   peuvent    &ecirc;tre    un    objet   de    type
<code>cafetiere_soluble</code>.   De  sorte  que lorsque  la  fonction
<code>C[i].faire_le_cafe()</code>  est appel&eacute;e, rien  ne dit  qu'il se
passe en r&eacute;alit&eacute; la m&ecirc;me  chose &agrave; chaque it&eacute;ration du tableau. C'&eacute;tait
d&eacute;j&agrave; le cas en programmation fonctionnelle, la diff&eacute;rence ici est tout
simplement que la  structure <code>switch</code> pr&eacute;c&eacute;dente a disparu: 
elle est remplac&eacute;e par un m&eacute;canisme d'appel de fonctions int&eacute;gr&eacute; au
syst&egrave;me lui-m&ecirc;me. Cela conduit &agrave; une <em>totale s&eacute;paration</em>
entre les diff&eacute;rents 
types de  cafeti&egrave;re, donc  si je  rajoute dans un  ou deux  si&egrave;cles un
nouveau type de cafeti&egrave;re, je  ne risque plus d'ajouter des erreurs et
de faire planter les autres types. Le code est &agrave; la fois plus clair, parce que plus proche de la pens&eacute;e humaine,
<em>et</em> plus robuste, en  ce sens qu'une 
modification  quelque  part  risque  moins  d'introduire  des  erreurs
ailleurs. Ces deux caract&eacute;ristiques conduisent &agrave; un code plus simple &agrave;
maintenir.</p>

  <h2><a name="obj-classes">Classes et objets</a></h2>

  <p>Une <em>classe</em> est une mani&egrave;re de d&eacute;crire un type
d'objets: on peut le voir comme un moule, qui servira &agrave; la
fabrication des objets proprement dits. Une classe n'est donc pas un objet.
Un objet se caract&eacute;rise par trois choses:  </p>
  <ul>
    <li>Un &eacute;tat</li>
	<li>Un comportement</li>
    <li>Une identit&eacute;</li>
  </ul>
 
  <h4><a name="obj-etat">L'&eacute;tat d'un objet:</a></h4>
 <p>L'&eacute;tat d'un objet est la combinaison de ses
propri&eacute;t&eacute;s: celles-ci  peuvent elles-m&ecirc;mes 
&ecirc;tre des objets. Par exemple, l'&eacute;tat de la machine
&agrave; caf&eacute; sera:</p>
  <ul>
    <li>En fonctionnement</li>
    <li>Pr&ecirc;te &agrave; faire le caf&eacute;</li>
    <li>R&eacute;servoir &agrave; caf&eacute; plein ou vide</li>
    <li>etc.</li>
  </ul>
<p>L'&eacute;tat d'un objet d&eacute;pend de son histoire: si la machine
&agrave; caf&eacute; est plusieurs fois en fonctionnement, son
r&eacute;servoir finira par se vider.</p>

  <h4><a name="obj-comp">Le comportement d'un objet:  </a></h4>
 <p>Le comportement d'un objet est ce qu'il est capable de r&eacute;aliser, la mani&egrave;re dont il r&eacute;agira 
 &agrave; des messages ext&eacute;rieurs, ... le comportement correspond donc au code qui sera ins&eacute;r&eacute; &agrave;
 l'int&eacute;rieur de l'objet afin de la faire agir. Un changement d'&eacute;tat peut g&eacute;n&eacute;rer un 
 comportement particulier (le r&eacute;servoir &agrave; caf&eacute; se vide: l'objet t&eacute;l&eacute;phone &agrave;
 la maintenance), et r&eacute;ciproquement une action entra&icirc;nera un changement d'&eacute;tat.</p>

<h4><a name="obj-id">L'identit&eacute; d'un objet:</a></h4>
 <p>Si l'on veut que plusieurs objets cohabitent dans le programe, il faudra bien les diff&eacute;rentier d'une 
 mani&egrave;re ou d'une autre: l'identit&eacute; est l&agrave; pour cela. 
 Le programmeur n'a g&eacute;n&eacute;ralement pas &agrave; s'en pr&eacute;occuper, elle est directement g&eacute;r&eacute;e
 par le syst&egrave;me. L'identit&eacute; de l'objet en C++ est simplement l'adresse de l'objet dans la m&eacute;moire.</p>
 

<h4><a name="obj-met">Des objets "m&eacute;tiers"</a></h4>

<p> Les objets m&eacute;tiers sont des objets qui doivent &ecirc;tre compris par toute personne du domaine concern&eacute;:
 par exemple, l'objet cafeti&egrave;re devrait &ecirc;tre ais&eacute;ment compr&eacute;hensible par tous ceux qui 
 s'occupent r&eacute;ellement de la machine &agrave; caf&eacute;. Par contre, si on met les machines &agrave; caf&eacute;
 dans un tableau, qui lui-m&ecirc;me sera un objet, ce tableau n'est utile que pour le d&eacute;roulement du programme 
 lui-m&ecirc;me: les gens "du m&eacute;tier" n'ont aucune raison de s'y int&eacute;resser.</p>

<h4><a name="obj-rel">Relations entre objets</a></h4>

<p>Les objets vont communiquer entre eux en s'envoyant des <em>messages</em>: dans la r&eacute;alit&eacute;, 
ces messages sont tout simplement des appels de fonctions, comme on l'a vu. Les objets sont en relation entre eux 
(un objet en relation avec aucun autre objet ne servirait &agrave; rien). On distingue plusieurs types de relations:</p>

<dl>
	<dt><em>Association</em></dt>
	<dd>C'est la plus courante, aussi la moins forte: c'est la relation qui lie un enseignant et ses &eacute;tudiants, par exemple.</dd>
	<dt><em>Agr&eacute;gation</em></dt>
	<dd>C'est la relation qui lie un objet et ses composants: la cafeti&egrave;re et son r&eacute;servoir d'eau, de caf&eacute;,
	de gobelets, par exemple. Elle est plus forte que la relation d'association, toutefois une cafeti&egrave;re peut exister 
	sans son r&eacute;servoir &agrave; caf&eacute;.</dd>
	<dt><em>Composition</em></dt>
	<dd>La relation la plus forte (utilis&eacute;e rarement). Un immeuble de 10 &eacute;tages ne peut exister sans 
	tous ses &eacute;tages, et r&eacute;ciproquement: on exprimera donc dans le code le fait que si l'objet immeuble 
	est d&eacute;truit, tous les objets le composant seront d&eacute;truits &eacute;galement, et r&eacute;ciproquement.</dd>
	<dt><em>Une sorte de</em></dt>
	<dd>On pourra exprimer le fait qu'une machine &agrave; caf&eacute; particuli&egrave;re est "une sorte de" machine &agrave; caf&eacute;.</dd>
	<dt><em>Un tas de</em> </dt>
	<dd>Des objets particuliers (les conteneurs) nous permettront de mettre nos objets dans des structures de donn&eacute;es:
	on pourra donc avoir "un tableau de cafeti&egrave;res", "une pile de cafeti&egrave;re", 
	"une queue de cafeti&egrave;res", etc.</dd>
</dl>

<p>Les relations d'association, d'agr&eacute;gation et de composition s'expriment en ins&eacute;rant des variables 
membres dans une d&eacute;finition de classe 
(<a  href="types.html#class"><img alt="apres" src="apres.gif" /></a>). 
Dans le cas de la relation de composition, il convient de s'assurer que les objets sont construits ou d&eacute;truits 
ensemble. La relation "est une sorte de" s'exprime gr&acirc;ce &agrave; l'h&eacute;ritage (<a  href="heritage.html">
<img alt="apres" src="apres.gif" /></a>). Les autres relations s'expriment par les mod&egrave;les 
(<a  href="modeles.html"><img alt="apres" src="apres.gif" /></a>)</p>

<p><a href="#">top</a></p><hr /> 

<address><img alt="xhtml" src="xhtml.png" />
<a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>

</div>
</body>
</html><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Bibliographie</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
</dl>
<dl>
 <dt><a href="exos.html#pointeurs" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1>R&eacute;f&eacute;rences</h1>

<h3>Retour sur le langage C</h3>

<dl>
  <dt><b><a id="RICHIEC">[Richie-C]</a></b></dt>
  <dd><a href="http://cm.bell-labs.com/cm/cs/who/dmr/chist.html">http://cm.bell-labs.com/cm/cs/who/dmr/chist.html</a>
  The development of the C Language par Dennis M.Ritchie (1996)</dd>
</dl>
<hr />

<h3>Textes de Bjarne Stroustrup</h3>

<dl>
  <dt><b><a id="STROUSTRUP">[Stroustrup-home]</a></b></dt>
  <dd><a href="http://www.research.att.com/~bs">http://www.research.att.com/~bs</a> La page de Bjarne
      Stroustrup</dd>
  <dt><b><a id="STROUSTRUPFAQ">[Stroustrup-faq]</a></b></dt>
  <dd><a href="http://www.research.att.com/~bs/bs_faq.html">http://www.research.att.com/~bs/bs_faq.html</a>
  Les faqs de Stroustrup</dd>
  <dt><b><a id="STROUSTRUPCPP">[Stroustrup-c++]</a></b></dt>
  <dd><a href="http://www.research.att.com/~bs/C++.html">http://www.research.att.com/~bs/C++.html</a>
  pointeurs vers des ressources C++ </dd>
  <dt><b><a id="STROUSTRUPAPP">[Stroustrup-app]</a></b></dt>
  <dd><a href="http://www.research.att.com/~bs/learn.html">http://www.research.att.com/~bs/learn.html</a>
  learning C++ (quelques notes sur l'apprentissage du C++, et la diff&eacute;rence entre C et C++)</dd>
  <dt><b><a id="STROUSTRUPWOP">[Stroustrup-wop]</a></b></dt>
  <dd><a href="http://www.research.att.com/~bs/whatis.pdf">http://www.research.att.com/~bs/whatis.pdf</a>
  What is Object Programming ? (article au format pdf)</dd>
  <dt><b><a id="STROUSTRUPBIB">[Stroustrup-bib]</a></b></dt>
  <dd><a href="http://www.research.att.com/~bs/3rd_tour2.pdf">http://www.research.att.com/~bs/3rd_tour2.pdf</a>
      Description de la biblioth&egrave;que standard du C++</dd>
  <dt><b><a id="STROUSTRUPLANG">[Stroustrup-lang]</a></b></dt>
  <dd><a href="http://www.research.att.com/~bs/3rd.html">http://www.research.att.com/~bs/3rd.html</a>
  Le langage C++, 3&egrave;me &eacute;dition (Addison-Wesley)  (rassurez-vous c'est juste de la pub) <br />
      <em>Le texte de base n&deg;1</em></dd>
</dl>
<hr />

<h3>Autres pointeurs ou textes en Anglais</h3>

<dl>
  <dt><a href="http://www.accu.org/">http://www.accu.org</a>
  Association of C and C++ users</dt>
  <dd>Pas mal de pointeurs, en particulier une <a
      href="http://www.accu.org/bookreviews/public/index.htm">"book
      review"</a> tr&egrave;s compl&egrave;te [3000 r&eacute;f&eacute;rences...]</dd>
  <dt><b>C++ FAQS Second Edition, Addison Wesley (1999)</b>
      (Marshall Cline, Greg Lomow, Mike Girou)</dt>
  <dd>Tout ce que vous avez toujours voulu savoir...  <em><br />
      Le texte de base n&deg;2</em></dd>
  <dt><b><a href="http://www.ensta.fr/~diam/c++/online/c++-faq-lite/">http://www.ensta.fr/~diam/c++/online/c++-faq-lite</a>
  Les C++ FAQ LITE</b></dt>
  <dd><em>La version all&eacute;g&eacute;e, mais en ligne, du texte de base n&deg;2</em></dd>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">http://www.sgi.com/tech/stl/index.html</a></dt>
  <dd>La documentation de r&eacute;f&eacute;rence de l'impl&eacute;mentation de Sgi de la biblioth&egrave;que
  standard. Seulement la partie STL (il manque donc les entr&eacute;es-sorties).</dd>
  <dt><a href="http://www.cplusplus.com/ref">http://www.cplusplus.com/ref</a></dt>
  <dd>Un site malheureusement en perte de vitesse, mais int&eacute;ressant pour sa documentation 
  sur la biblioth&egrave;que d'entr&eacute;es-sorties.</dd>
</dl>
<hr />

<h3><a id="text-fran">Textes en fran&ccedil;ais</a></h3>

<dl>
  <dt><b>Programmer en langage C++, Eyrolles
      </b> (Claude Delannoy)</dt>
  <dd>Un tr&egrave;s bon livre, &eacute;crit en franÔøΩais, tr&egrave;s complet mais beaucoup
      plus accessible que le Stroustrup. La biblioth&egrave;que standard est abondamment
      pr&eacute;sent&eacute;e<br />
      <em>Le texte de base n&deg;3</em></dd> 
  <dt><b>STL, pr&eacute;cis et concis, O'Reilly</b> (Ray Lischner)</dt>
  <dd>Le meilleur livre que j'ai trouv&eacute; sur la biblioth&egrave;que standard du C++: cela tombe bien,
  il est court et pas cher&nbsp;!<br />
  <em>Le texte de base n&deg;4</em></dd>
</dl>
<hr />
<address><a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>
<p>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p></div></body> </html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>La biblioth&egrave;que standard</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
 <dd id="smenu1" style="height:20em;overflow: scroll;">
	<ul>
		<li><a href="stdlib.html#compl">Compl&eacute;ments sur le langage</a> 
		<ul>
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#namespace">Les espaces de noms</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#localtype">Les types locaux</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#typename">L'instruction <code>typename</code></a></li> 
		</ul></li>
	    <li><a onclick="javascript=cacher_menu()" href="stdlib.html#conteneurs">Les conteneurs</a> 
		<ul>
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#contobjptr">Conteneurs	d'objets ou conteneurs de pointeurs ?</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#contseqass">Conteneurs s&eacute;quentiels et conteneurs associatifs (ordonn&eacute;s)</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#constd">Les conteneurs de la biblioth&egrave;que standard</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#typecont">Types d&eacute;finis sur les conteneurs</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#fctopcont">Quelques fonctions-membres ou op&eacute;rateurs</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="stdlib.html#string">string: les cha&icirc;nes de caract&egrave;res</a></li>
		</ul></li>
	    <li><a onclick="javascript=cacher_menu()" href="stdlib.html#iterateurs">Les it&eacute;rateurs</a>
	<ul>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#it-val">It&eacute;rateurs valides et invalides</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#it-cat">Les diff&eacute;rentes cat&eacute;gories d'it&eacute;rateurs</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#it-int">Sp&eacute;cifier un intervalle &agrave; l'aide de deux it&eacute;rateurs</a></li>
	</ul></li>
        <li><a onclick="javascript=cacher_menu()" href="stdlib.html#kikoi">Qui fait quoi ?</a></li> 
        <li><a onclick="javascript=cacher_menu()" href="stdlib.html#algo">Algorithmes</a></li>
         <li>
         <ul><li><a onclick="javascript=cacher_menu()" href="stdlib.html#tri">Trier un conteneur</a></li>
         <li><a onclick="javascript=cacher_menu()" href="stdlib.html#listes">Manipuler des listes</a></li>
    </ul></li>
	<li><a onclick="javascript=cacher_menu()" href="stdlib.html#stream">Les entr&eacute;es-sorties</a>
	<ul>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#io-stream">Les objets de type ostream ou istream</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#io-bin">Lecture-&eacute;criture en binaire</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#io-get">Fonctions get, put, getline</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#stream-fmt">Entr&eacute;es-sorties formatt&eacute;es:  &lt;&lt; et &gt;&gt;</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#ctrl-fmt">Le contr&ocirc;le du format</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#io-sts">Ecrire... ou lire l'&eacute;tat du flot</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#sortie-surch">Surcharger l'op&eacute;rateur &lt;&lt;</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#entree-surch">Surcharger l'op&eacute;rateur &gt;&gt;</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#ite-stream">Les it&eacute;rateurs de flots</a></li>
	   <li><a onclick="javascript=cacher_menu()" href="stdlib.html#io-conten">Remplir un conteneur &agrave; partir d'un fichier</a></li>
	</ul></li>
	</ul>
 </dd>
</dl>
<dl>
 <dt><a href="exos.html#stdlib" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1>La biblioth&egrave;que standard </h1>

<p>La biblioth&egrave;que standard  est livr&eacute;e avec
le  compilateur,  &agrave; condition  que  celui-ci  soit  assez r&eacute;cent  pour
respecter la  norme ANSI de 1997  du C++: il est donc important 
d'utiliser toujours <em>la version la plus r&eacute;cente possible</em> de son compilateur. 
La biblioth&egrave;que comprend une multitude
d'objets et de fonctions  fort utiles, dont nous pr&eacute;sentons bri&egrave;vement
ici <em>les plus importants</em>.</p>

<h2><a name="compl">Compl&eacute;ments sur le langage</a></h2>

<p>Certaines  particularit&eacute;s  du  langage  n'ont  pas
encore &eacute;t&eacute;  abord&eacute;es: elles peuvent  en effet &ecirc;tre ignor&eacute;es,  dans une
premi&egrave;re  approche  du  C++.  Cependant,  il  est  n&eacute;cessaire  de  les
conna&icirc;tre,  ne serait-ce que  pour comprendre  la documentation  ou le
code de la biblioth&egrave;que standard.</p>

<h3><a name="namespace">Les espaces de noms</a></h3>

<p>Un probl&egrave;me se pose  d&egrave;s lors que l'on travaille avec
des biblioth&egrave;ques venant de plusieurs sources diff&eacute;rentes: les noms de
classes, de fonctions, de types, etc.  employ&eacute;s par les uns et par les
autres peuvent parfaitement entrer en conflit;   Une mani&egrave;re classique
de r&eacute;soudre le probl&egrave;me est  d'inciter les d&eacute;veloppeurs &agrave; utiliser des
noms ayant peu de chances  d'entrer en conflit, par exemple en mettant
devant chaque  nom un pr&eacute;fixe particulier.  Ainsi,  si la biblioth&egrave;que
<code>GenialeBibliotheque</code> utilise  le type <code>string</code>,
elle  l'appellera  <code>GenialeBibliotheque_string  </code>.   Si  la
biblioth&egrave;que  <code>SublimeBibliotheque</code> d&eacute;finit  elle  aussi un
type           <code>string</code>,          elle          l'appellera
<code>SublimeBiblitoheque_string</code>.   Cependant, le C++  offre un
m&eacute;canisme bien plus astucieux;</p>

<h4><a name="namedecl">La d&eacute;claration <code>namespace</code></a></h4>

<p>Chacune des deux biblioth&egrave;ques  encapsule toutes ses d&eacute;clarations dans
un bloc appel&eacute; <code>namespace</code>, comme on le voit ci-dessous:</p>

<pre class="demo">
namespace GenialeBibliotheque {
   class string {
      ...
   }
}
</pre>

<p>pour la premi&egrave;re biblioth&egrave;que et:</p>

<pre class="demo">
namespace SublimeBibliotheque {
   class string {
      ...
   }
}
</pre>

<p>pour  la seconde.</p>

<h4><a name="namealia">Les aliases d'espaces de noms</a></h4>

<p>On  conseille de  donner  des  noms  longs pour  les
espaces de noms: plus le long sera long plus le risque de conflit sera
faible. Par  contre, plus  le long sera  long plus la  souffrance sera
aig&ucirc;e   pour  l'utilisateur.   Mais,   heureusement,  nous   avons  la
possibilit&eacute; de d&eacute;finir des aliases d'espaces de noms comme suit:</p>

<pre class="demo">
namespace GB = GenialeBibliotheque;
namespace SB = SublimeBibliotheque;
</pre>

<h4><a name="nameutil">L'utilisation des espaces de noms</a></h4>

<p>A  partir de l&agrave;, comment le  code utilisateur va-t-il
pr&eacute;venir  le  compilateur qu'il  veut  utiliser  l'un  ou l'autre  des
espaces de noms ?  Trois solutions:</p>

<ul>
  <li>L'op&eacute;rateur de port&eacute;e</li>
  <li>Les d&eacute;clarations <code>using</code></li>
  <li>La directive <code>using</code></li>
</ul>

<p>
L'op&eacute;rateur de port&eacute;e permet de sp&eacute;cifier la totalit&eacute; du nom, comme
indiqu&eacute; ci-dessous:</p>

<pre class="demo">
GB::string S;
</pre>

<p>La notation est lourde, conduisant &agrave; un code peu lisible.</p>

<p  >Les     <i>d&eacute;clarations</i>    <code>using</code>    sont
int&eacute;ressantes, elles  permettent de d&eacute;clarer, objet par  objet, le nom
de l'espace de nom correspondant. L'op&eacute;rateur de port&eacute;e figure dans la
d&eacute;claration, mais ensuite il est sous-entendu. Par exemple:</p>

<pre class="demo">
using GB::string;
string S;
</pre>

<p>On   a  autant   de  contr&ocirc;le  qu'avec   la  m&eacute;thode
pr&eacute;c&eacute;dente, mais sans la lourdeur de la notation.</p>

<p>La <i>directive</i>  <code>using</code> est plus radicale:
elle  dit au  compilateur  que tous  les  objets de  l'espace de  noms
consid&eacute;r&eacute; doivent &ecirc;tre accessibles:</p>

<pre class="demo">
using namespace GB;
string S;
</pre>

<p>Sympathique,  car   la  notation  est  all&eacute;g&eacute;e  mais
attention: si un nouveau symbole appara&icirc;t lors de la prochaine version
de  la   biblioth&egrave;que  SublimeBibliotheque,  par   exemple  la  classe
<code>class1</code>, un nouveau conflit  peut &ecirc;tre g&eacute;n&eacute;r&eacute; dans le code
utilisateur...  il est toujours  tr&egrave;s d&eacute;sagr&eacute;able d'avoir de nouvelles
erreurs de compilation parce qu'on a chang&eacute; de version de biblioth&egrave;que.
La solution la meilleure semble  donc bien &ecirc;tre celle des d&eacute;clarations
<code>using</code>.</p>

<h4><a name="namestd">L'espace de noms de la biblioth&egrave;que standard</a></h4>

<p> Tous  les  symboles d&eacute;finis  par la  biblioth&egrave;que
standard se  trouvent dans l'espace de  noms <code>std</code>. D'autre
part, les en-t&eacute;tes  de la biblioth&egrave;que standard ne  comprennent pas le
traditionnel <code>.h</code>.  D'o&ugrave; les quelques  lignes suivantes que
l'on trouve en t&ecirc;te des programmes:</p>

<pre class="demo">
#include &lt;iostream&gt;
using namespace std;
</pre>

<div class="attention"><p><img          alt="ATTENTION"
src="attention.gif" />Certains  compilateurs  n&eacute;cessitent  l'utilisation
d'une option de compilation  pour utiliser la biblioth&egrave;que standard. A
v&eacute;rifier dans votre documentation.</p></div>

<h3><a name="typedef">L'instruction <code>typedef</code></a></h3>

<p>L'instruction <code>typedef</code> (issue
du <code>C</code>) ne d&eacute;finit pas, contrairement &agrave; ce que son nom
pourrait laisser croire, un nouveau type. Elle ne fait que donner un
autre nom (synonyme) <i> &agrave; un type existant</i>. Il est recommand&eacute; de
s'en servir, car l'utilisation syst&eacute;matique des mod&egrave;les dans la
biblioth&egrave;que standard rend le code difficilement compr&eacute;hensible si on
ne l'utilise pas.</p>

<h3><a name="localtype">Les types locaux</a></h3>

<p        >Nous          avons         vu          <a
href="types.html#priv-prot-pub"><img    alt="avant"    src="avant.gif" /></a>
 qu'il est possible  de d&eacute;finir des types &agrave; l'int&eacute;rieur
d'une classe: on parle alors de <em>types locaux</em>. La biblioth&egrave;que
standard fait largement appel &agrave; la notion de types locaux, par exemple
pour d&eacute;finir des &eacute;num&eacute;rations:</p>

<pre class="demo">
class semaine {
public:
   enum jour {lundi,mardi,mercredi,jeudi,
              vendredi,samedi,dimanche};
   jour j;
...
}

...
if (j == semaine::lundi) {
   ...
}
</pre>

<p>Remarquez  la notation <code>semaine::lundi</code>,
utilisant  l'op&eacute;rateur  de  port&eacute;e <code>::</code><br />
Les  it&eacute;rateurs  <a href="#iterateurs"><img  alt="apres"  src="apres.gif" /></a>
d&eacute;crits ci-dessous, apparaissent eux aussi comme des types locaux dans
les prototypes de  la biblioth&egrave;que standard. D'o&ugrave; la  syntaxe que nous
verrons ci-dessous:</p>

<pre class="demo">
typedef vector &lt;int&gt;::iterator i_int;
</pre>

<h3><a name="typename">L'instruction <code>typename</code></a></h3>

<p>Dans  certains  cas,  lors  de  la  d&eacute;finition  de
mod&egrave;les, il n'est pas simple  pour le compilateur de d&eacute;terminer si une
d&eacute;claration est une d&eacute;claration de type ou de variable: en fait, cette
d&eacute;termination n'est  possible que  lors de l'instantiation  du mod&egrave;le.
Or, suivant  qu'il s'agit d'un  type ou d'une  variable, l'utilisation
ult&eacute;rieure de la chose sera bien diff&eacute;rente. On doit donc pouvoir dire
au compilateur que tel objet est  soit une variable, soit un type.  La
r&egrave;gle est la suivante:</p>

<ul>
  <li>Soit rien n'est sp&eacute;cifi&eacute;, dans ce cas il s'agit d'une variable</li>
  <li>Si on veut forcer une d&eacute;finition de type, on emploie <code>typename</code></li> 
</ul>

<p><a href="#">top</a></p><hr />

<h2><a name="conteneurs">Les conteneurs</a></h2>

<p >Les   conteneurs  sont   des   objets  qui   <em>en
contiennent</em> d'autres: ce terme  g&eacute;n&eacute;ral inclue un grand nombre de
structures de donn&eacute;es: les tableaux, les listes, les queues, ...  mais
aussi les  tableaux associatifs.  Comme  on pouvait s'y  attendre, les
conteneurs   sont   impl&eacute;ment&eacute;s    gr&acirc;ce   aux   <em>mod&egrave;les</em>   <a
href="modeles.html"><img  alt="avant" src="avant.gif" /></a>:
on  devra donc sp&eacute;cifier  "ce que"  le conteneur  contient lors  de la
d&eacute;claration de la variable. Par rapport &agrave; un tableau classique "&agrave; la C", un conteneur offre un certain
nombre d'avantages:</p>

<ul>
  <li>Allocation dynamique et automatique de m&eacute;moire</li>
  <li>Possibilit&eacute; d'ins&eacute;rer ou supprimer les &eacute;l&eacute;ments, pour certains
      types de conteneurs</li>
  <li>Utilisation d'algorithmes pr&eacute;d&eacute;finis sur ces conteneurs</li>
</ul>

<div class="attention"><p><img  alt="ATTENTION"  src="attention.gif" />  <em>Ne  pas utiliser</em> de  tableaux "&agrave; la  C" en C++:  il est bien plus commode et aussi performant (&agrave; condition de prendre quelques pr&eacute;cautions) d'utiliser &agrave; la place un conteneur de type <code>vector</code> </p></div>

<p>La  surcharge des op&eacute;rateurs  permettra d'&eacute;crire du
code lisible (op&eacute;rateur <code>[]</code>  pour l'acc&egrave;s aux donn&eacute;es dans
un  vecteur  ou op&eacute;rateur  <code>++</code>  pour  les it&eacute;rateurs,  par
exemple).   Suivant les op&eacute;rations  que l'on  doit r&eacute;aliser,  on devra
utiliser tel  ou tel  type de conteneur,  afin d'obtenir  la meilleure
performance.   D'ailleurs,  certaines   op&eacute;rations   ne seront  pas
impl&eacute;ment&eacute;es sur <em>tous</em> les conteneurs, non pas parce que ce ne
serait   pas   possible,  mais   parce   que   ce  serait inefficace.</p>

<h3><a name="contobjptr">Conteneurs d'objets ou conteneurs de pointeurs ?</a></h3>

<p>Un conteneur  doit-il contenir des <em>objets</em> ou
des  <em>pointeurs  vers  des  objets</em>  ?  Le  probl&egrave;me  avec  les
conteneurs  est qu'on  est amen&eacute;,  lorsqu'on remplit  le  conteneur, &agrave;
<em>copier</em> les  objets. Si le  conteneur contient beaucoup d'objets, si  les objets
eux-m&ecirc;mes  sont   gros,  cela peut conduire &agrave; une utilisation excessive de la m&eacute;moire.  
Dans  ce cas, il peut &ecirc;tre int&eacute;ressant d'utiliser un conteneur de pointeurs.</p>

<div class="attention"><p><img  alt="ATTENTION"   src="attention.gif" />  On  a   d&eacute;j&agrave;  &eacute;voqu&eacute;  <a
href="mem.html#alloc-dynam"><img      alt="avant"      src="avant.gif" /></a> les probl&egrave;mes pos&eacute;s  par les pointeurs: les conteneurs
de  pointeurs  n'y  &eacute;chappent   pas,  bien  entendu.  En  particulier,
attention, si l'objet est  d&eacute;truit le pointeur correspondant doit &ecirc;tre
retir&eacute; du conteneur, faute de quoi il pendouillera.
</p></div>

<p>Une  possibilit&eacute;   offerte  par  les  conteneurs  de
pointeurs: mettre un m&ecirc;me objet "dans" plusieurs conteneurs. Attention
toutefois &agrave;  ce qui  pr&eacute;c&egrave;de: lors de  la destruction de  l'objet, il
faudra  supprimer   <em>plusieurs  pointeurs</em>  dans  <em>plusieurs
conteneurs</em> diff&eacute;rents.  Une  solution peut &ecirc;tre alors d'utiliser des
objets  qui  comptent  leurs  r&eacute;f&eacute;rences</p>

<div class="attention"><p><img        alt="ATTENTION"        src="attention.gif" />        L'objet <code>auto_ptr</code>  <a  href="mem.html#auto_ptr"><img  alt="avant" src="avant.gif" /></a> <em>n'est  pas</em> une bonne solution
dans  ce cas:  lors de  la copie  d'un  <code>auto_ptr</code>, l'objet
source est en effet d&eacute;truit.</p>
</div>

<h4>Conteneurs h&eacute;t&eacute;rog&egrave;nes ou homog&egrave;nes ?</h4>

<p >Reprenons  l'exemple  des   <code>shape</code>  <a
href="progobj.html#class-obj"><img    alt="avant"    src="avant.gif" /></a>: un conteneur h&eacute;t&eacute;rog&egrave;ne pourrait contenir des
<code>shape*</code>;  cela  permettrait de  mettre  dans  le  conteneur
n'importe  quelle forme;  le probl&egrave;me  est  au  moment  de r&eacute;cup&eacute;rer  l'objet:
qu'est-ce  que j'ai  bien pu  mettre l&agrave;  dedans ?   Les  conteneurs de
classes de bases sont les seuls conteneurs
h&eacute;t&eacute;rog&egrave;nes vraiment utiles: gr&acirc;ce &agrave; l'utilisation des relations d'h&eacute;ritage et des
 fonctions virtuelles, vous n'aurez pas &agrave;  vous poser  cette question.</p> 

<div class="regle">
<p><img alt="REGLE D'OR" src="diam.gif" /> La r&egrave;gle d'or:</p>
<ul> 
  <li>Utilisez  les <em>conteneurs  de   valeurs</em>,  sauf  si  vous
      ne  pouvez  faire autrement.</li>
  <li>Dans ce cas, utilisez les <em>conteneurs de pointeurs.</em></li>
  <li>Utilisez  les <em>conteneurs  homog&egrave;nes</em> autant  que possible.</li>
  <li>En  cas   de  besoin,  les  conteneurs   h&eacute;t&eacute;rog&egrave;nes  sont
      utilisables &eacute;galement. Ils seront impl&eacute;ment&eacute;s sous la forme de conteneurs
      de pointeurs vers une classe de base.</li>
  <li>En aucun cas, vous ne pourrez utiliser de <em>conteneurs de r&eacute;f&eacute;rences.</em></li>
</ul>
</div>

<h3><a name="contseqass">Conteneurs s&eacute;quentiels et conteneurs associatifs (ordonn&eacute;s).</a></h3>

<p>Les conteneurs de la biblioth&egrave;que standard se regroupent en deux familles principales:</p>

<ul>
   <li>Conteneurs s&eacute;quentiels</li>
   <li>Conteneurs ordonn&eacute;s, ou encore conteneurs associatifs</li>
</ul>

<p>Les conteneurs s&eacute;quentiels permettent au programmeur de contr&ocirc;ler l'ordre dans lequel 
les &eacute;l&eacute;ments sont ins&eacute;r&eacute;s.</p>
<p>Les conteneurs ordonn&eacute;s d&eacute;terminent eux-m&ecirc;mes l'ordre dans lequel les &eacute;l&eacute;ments sont 
rang&eacute;s: ils seront mis dans un ordre permettant de les rechercher tr&egrave;s rapidement. Un acc&egrave;s par cl&eacute; permet d'ailleurs 
cette recherche: il s'agit donc de conteneurs associatifs, qui fonctionnement de la m&ecirc;me mani&egrave;re qu'un
tableau associatif en perl, ou un dictionnaire en python.</p>

<div class="attention"><p><img  alt="ATTENTION"  src="attention.gif" />  Certains  conteneurs,  en
particulier  <code>map</code> et  <code>multimap</code>,  utilisent la
<code>struct</code>   mod&egrave;le  <code>pair</code>,  qui   comprend  deux
champs: <code>first</code> et <code>second</code>, ainsi qu'on peut le
voir ci-dessous:</p>

<pre class="demo">
typedef pair&lt;int,int&gt; p_i_i;
p_i_i p;
p.first=67;
p.second=54;
</pre>
</div>


<h3><a name="constd">Les conteneurs de la biblioth&egrave;que standard</a></h3>


<p>Les conteneurs  disponibles  dans la  biblioth&egrave;que
standard sont pr&eacute;sent&eacute;s rapidement ci-dessous:</p>

<h4>Conteneurs s&eacute;quentiels g&eacute;n&eacute;ralistes:</h4>
<dl>
  <dt><code><a href="http://www.sgi.com/tech/stl/Vector.html">vector</a></code></dt>
  <dd>Tableau &agrave; une dimension</dd>
  <dt><code><a href="http://www.sgi.com/tech/stl/List.html">list</a></code></dt>
  <dd>Liste doublement cha&icirc;n&eacute;e</dd>
  <dt><code><a href="http://www.sgi.com/tech/stl/Deque.html">deque</a></code></dt>
  <dd>Ressemble &agrave; un vecteur, sauf que l'insertion et la suppression en t&ecirc;te de liste 
  sont plus performantes.</dd>
  <dt><code><a href="http://www.sgi.com/tech/stl/queue.html">queue</a></code></dt> 
  <dd>File d'attente (premier entr&eacute;, premier sorti). <em>Une queue est un adaptateur de conteneur, qui  repose (par d&eacute;
  faut) sur un conteneur de type deque.</em></dd>
  <dt><code><a href="http://www.sgi.com/tech/stl/stack.html">stack</a></code></dt>
  <dd>Pile (dernier entr&eacute;, premier sorti). <em>C'est un adaptateur de conteneur.</em></dd>
</dl>

<h4>Conteneurs ordonn&eacute;s g&eacute;n&eacute;ralistes:</h4>

<dl>
  <dt><code><a
      href="http://www.sgi.com/tech/stl/Map.html">map</a></code>, <code><a href="http://www.sgi.com/tech/stl/Multimap.html">multimap</a></code></dt> 
  <dd>Tableau associatif, dans le cas de multimap plusieurs &eacute;l&eacute;ments peuvent avoir la m&ecirc;me cl&eacute; </dd>
  <dt><code><a
      href="http://www.sgi.com/tech/stl/set.html">set</a></code>, <code><a href="http://www.sgi.com/tech/stl/multiset.html">multiset</a></code></dt> 
  <dd>Ensemble (set), dans le cas de multiset on peut avoir plusieurs fois le
      m&ecirc;me &eacute;l&eacute;ment.</dd>
  <dt><code><a href="http://www.sgi.com/tech/stl/priority_queue.html">priority_queue</a></code> </dt>
  <dd>File d'attente. On acc&egrave;de uniquement &agrave; l'objet situ&eacute; en haut de la queue. De plus, le conteneur garantit que l'objet
  situÔøΩ en haut est le "plus grand". <em>Il s'agit d'un adaptateur de conteneur, qui repose sur
  un vecteur.</em></dd>
</dl>

<h4>Conteneurs sp&eacute;cialis&eacute;s:</h4>

<dl>
  <dt><code><a href="http://www.sgi.com/tech/stl/basic_string.html">string, wstring</a></code></dt>
  <dd>Cha&icirc;nes de caract&egrave;res</dd>
  <dt><code><a href="http://www.sgi.com/tech/stl/bitset.html">bitset</a></code></dt>
  <dd>Tableau de bool&eacute;ens.</dd>
</dl>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Les type <code>bitset</code>, <code>multimap</code>, <code>multiset</code>, <code>priority_queue</code>
ne seront pas abord&eacute;s plus avant dans ce cours.</p></div>

<h3><a name="typecont">Types d&eacute;finis sur les conteneurs</a></h3>

<p>Les  conteneurs d&eacute;finissent  des  <em>types</em> en  tant que  membres
publics dont les plus importants sont &eacute;crits ci-dessous. On supposera dans ce qui suit qu'on travaille 
avec l'un de ces deux objets:</p>

<ul>
  <li><code>seq&lt;objet&gt;</code> (un conteneur s&eacute;quentiel)</li>
  <li><code>ord&lt;cle,valeur&gt;</code> ou <code>ord&lt;cle&gt;</code> 
  (un conteneur ordonn&eacute; param&eacute;tr&eacute; 
  par un type de cl&eacute; et &eacute;ventuellement de valeur).</li>
</ul>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
M&ecirc;me si cela peut paraitre lourd &agrave; premi&egrave;re vue, il est important d'utiliser ces types,
pour g&eacute;n&eacute;rer du code portable: peut-&ecirc;tre que sur votre syst&egrave;me le type
<code>size_type</code> est &eacute;quivalent &agrave; <code>unsigned int</code>. Mais sur un autre syst&egrave;me,
<code>size_type</code> risque d'&ecirc;tre en fait &eacute;quivalent &agrave; <code>unsigned long</code>. D'o&ugrave;
de gros soucis de portabilit&eacute;.</p></div>

<dl>
  <dt><code><b>value_type</b></code></dt>
  <dd>Type d'&eacute;l&eacute;ment: <code>seq&lt;objet&gt;::value_type</code> n'est autre que <code>objet</code></dd>
  <dt><code><b>reference</b></code></dt>
  <dd><code><b>value_type&amp;</b></code> (ici <code><b>objet &amp;</b></code>)</dd>
  <dt><code><b>const_reference</b></code></dt>
  <dd><code><b>const value_type &amp; </b></code> (ici <code><b>const objet &amp; </b></code>)</dd>
  <dt><code><b>size_type</b></code></dt>
  <dd>Num&eacute;ros d'indices, nombre d'&eacute;l&eacute;ments, etc.</dd>
  <dt><code><b>iterator</b></code></dt>
  <dd><code><b>value_type*</b></code>, (ici <code><b>objet *</b></code>)
      permet de balayer le conteneur <a
href="#iterateurs"><img  alt="apres"  src="apres.gif" /></a></dd>
  <dt><code><b>const_iterator</b></code></dt>
  <dd>M&eacute;me chose, mais garantit que les objets r&eacute;cup&eacute;r&eacute;s ne seront pas
      modifi&eacute;s.</dd>
  <dt><code><b>reverse_iterator</b></code></dt>
  <dd>Pour balayer le conteneur &agrave; l'envers</dd>
  <dt><code><b>const_reverse_iterator</b></code></dt>
  <dd>no comment</dd>
  <dt><code><b>difference_type</b></code></dt>
  <dd>Diff&eacute;rence entre deux it&eacute;rateurs</dd>
</dl>

<h4>Cas des conteneurs associatifs</h4>

<p>Les conteneurs associatifs d&eacute;finissent &eacute;galement les types suivants:</p>

<dl>
  <dt><code><b>Key</b></code> ou <code><b>key_type</b></code></dt>
  <dd>Cl&eacute; d'acc&egrave;s aux &eacute;l&eacute;ments. (Ici, <code>cle</code>)</dd>
  <dt><code><b>T</b></code> ou <code><b>data_type</b></code></dt>
  <dd>Type d'&eacute;l&eacute;ments stock&eacute;s. (Ici, <code>valeur</code>)</dd>
  <dt><code><b>pair&lt;key,T&gt;</b></code></dt>
  <dd>Les objets stock&eacute;s dans un <code>map</code> (donc <code>value_type</code>).
  On acc&egrave;de &agrave; la cl&eacute; par le champ <code>first</code>, ‡ la valeur par le champ <code>second</code>.
  A noter que les paires sont rang&eacute;es par ordre croissant du champ <code>key</code>. Il est possible de 
  d&eacute;finir ce qu'est cet ordre (cf. la documentation de l'objet <a href="http://www.sgi.com/tech/stl/Map.html">
  <code>map</code></a>).</dd>
</dl>

<p><a href="#">top</a></p><hr />

<h3><a name="fctopcont">Quelques fonctions membres ou op&eacute;rateurs d&eacute;finis sur les conteneurs</a></h3>

<p>Ce paragraphe expose quelques fonctions-membres (les plus utiles) d&eacute;finies sur les conteneurs 
les plus souvent utilis&eacute;s: autant dire qu'il ne pr&eacute;tend en aucune 
fa&ccedil;on &agrave; l'exhaustivit&eacute;. Ne sont en effet consid&eacute;r&eacute;s ici que les conteneurs
suivants: <code>vector, list, deque, queue, stack, map, set</code>.</p>

<ul>
  <li><b>It&eacute;rateurs</b>
      <dl>
	<dt><code><b>iterator begin()</b></code>, <code><b>const_iterator begin()</b></code> <em class="red">(tous)</em></dt>
	<dd>Retourne un it&eacute;rateur qui pointe sur le premier &eacute;l&eacute;ment. 
	Permet donc de d&eacute;marrer une boucle pour faire
	d&eacute;filer tous les &eacute;l&eacute;ments du conteneur.</dd>
	<dt><code><b>iterator end()</b></code>,<code><b>const_iterator begin()</b></code> <em class="red">(tous)</em></dt>
	<dd>Retourne un it&eacute;rateur qui pointe <em>apr&egrave;s</em> le dernier &eacute;l&eacute;ment. Permet
	donc de donner une condition de fin &agrave; la boucle. Cet objet est aussi utilis&eacute; par de nombreuses fonctions
	(algorithmes <a href="#algo"><img  alt="apres"  src="apres.gif" /></a>), par exemple <code>find</code> pour signifier
	que l'objet recherch&eacute; n'a pas &eacute;t&eacute; trouv&eacute;.
<pre class="demo">
typedef conteneur&lt;int&gt;::const_iterator citr;
for (citr i=V1.begin(); i!=V1.end(); ++i) {
cout &lt;&lt; *i &lt;&lt; endl;
}
</pre></dd>
</dl>
</li>
  <li><b>Acc&egrave;s aux &eacute;l&eacute;ments</b>
      <dl>
	<dt><code><b>reference top() const</b></code>, <code><b>const_reference top() const</b></code> <em class="red">(stack)</em></dt>
	<dd>Renvoie l'&eacute;l&eacute;ment situ&eacute; en haut de la pile. Temps d'ex&eacute;cution constant.
	La pile ne doit pas &ecirc;tre vide.</dd>
	<dt><code><b>reference front() const</b></code>, <code><b>const_reference front() const</b></code> <em class="red">(vector,list,deque)</em></dt>
	<dd>Renvoie le premier &eacute;l&eacute;ment</dd>
	<dt><code><b>reference back() const</b></code>,<code><b>const_reference back() const</b></code> <em class="red">(vector,list,deque)</em></dt>
	<dd>Renvoie le dernier &eacute;l&eacute;ment
<pre class="demo">
vector&lt;int&gt; V1;
...
int f = V1.front();
int b = V1.back();

cout &lt;&lt; "Premier entier " &lt;&lt; f  &lt;&lt; endl;
cout &lt;&lt; "Dernier entier " &lt;&lt; b  &lt;&lt; endl;
</pre></dd>

	<dt><code><b>reference operator[](size_type n)</b></code>, <code><b>const_reference operator[](size_type n)</b></code> <em class="red">(vector,string,deque )</em></dt>
	<dd>Permet d'acc&eacute;der &agrave; un &eacute;l&eacute;ment indic&eacute;. Attention, il n'y
	a pas de contr&ocirc;le de d&eacute;bordement. Le premier &eacute;l&eacute;ment a l'indice 0.
<pre class="demo">
string s = "hello";
cout &lt;&lt; s[0]; // renvoie h
</pre></dd>
	<dt><code><b>data_type &amp; operator[](const key_type&amp; k)</b></code> <em class="red">(map)</em></dt>
	<dd>Permet d'acc&eacute;der &agrave; un &eacute;l&eacute;ment &agrave; partir de sa cl&eacute;. Si l'&eacute;l&eacute;ment
	n'existe pas, un nouvel enregistrement est cr&eacute;&eacute; et ins&eacute;r&eacute; dans le conteneur. En
	cons&eacute;quence, il n'existe pas de version <code>const</code> de cet op&eacute;rateur.

<pre class="demo">
map&lt;string,string&gt; couleurs;
...
couleurs["foreground_color"]="rouge";
couleurs["background_color"]="blanc";
</pre></dd>

	<dt><code><b>iterator find(const key_type &amp; k)</b></code>, 
	<code><b>const_iterator find(const key_type &amp; k)</b></code> <em class="red">(map,set)</em></dt>
	<dd>Renvoie un it&eacute;rateur pointant sur l'&eacute;l&eacute;ment de cl&eacute; <code>k</code>.
	S'il n'y a pas d'&eacute;l&eacute;ment de cl&eacute; k, renvoie <code>end()</code>
<pre class="demo">
map&lt;string,string&gt; couleurs;
...
map&lt;string,string&gt;::iterator i = couleurs.find("foreground_color");
if (i==couleurs.end()) {
   cout &lt;&lt; "Pas trouv&eacute;" &lt;&lt; endl;
} else {
   cout  &lt;&lt; "cl&eacute;=" &lt;&lt; i-&gt;first &lt;&lt; "valeur=" &lt;&lt; i-&gt;second &lt;&lt; endl;
</pre></dd>
</dl>
</li>	
  <li><b>Op&eacute;rations d'insertion et de suppression d'&eacute;l&eacute;ments.</b>
      <dl>
	<dt><code><b>void push(const value_type &amp; x)</b></code><em class="red">(stack,queue)</em></dt>
	<dd>Ins&egrave;re <code>x</code> en haut de la pile ou &agrave; la fin de la queue. Temps d'ex&eacute;cution constant.</dd>
	<dt><code><b>void pop()</b></code><em class="red">(stack,queue)</em></dt>
	<dd>Supprime l'&eacute;l&eacute;ment situ&eacute; en haut de la pile ou en t&ecirc;te de la queue. Temps d'ex&eacute;cution constant.
	La pile ou la queue ne doit pas &ecirc;tre vide.</dd>
	<dt><code><b>void push_front(const value_type &amp; x)</b></code>  
	<em class="red">(deque,list)</em></dt>
	<dd>Ins&egrave;re <code>x</code> au d&eacute;but.</dd>
	<dt><code><b>void pop_front()</b></code> 
	<em class="red">(deque,list)</em></dt>
	<dd>Supprime <code>x</code> du d&eacute;but. Ces fonctions ont un comportement ind&eacute;fini si le conteneur est vide:
	utiliser la fonction <code>empty()</code> auparavant.</dd>
	<dt><code><b>void push_back(const value_type &amp; x)</b></code>  
	<em class="red">(string, deque,list,vector)</em></dt>
	<dd>Ins&egrave;re <code>x</code> &agrave; la fin.</dd>
	<dt><code><b> void pop_back()</b></code> 
	<em class="red">(string, deque,list,vector)</em></dt>
	<dd>Supprime <code>x</code> &agrave; la fin. Ces fonctions ont un comportement ind&eacute;fini si le conteneur
	est vide: utiliser la fonction <code>empty()</code> auparavant.</dd>
	<dt><code><b>iterator insert(iterator p,const value_type &amp; x)</b></code> <em class="red">(vector,list,deque)</em></dt>
	<dd>Ins&egrave;re <code>x</code> avant <code>p</code> et retourne un it&eacute;rateur pointant sur 
	<code>x</code>.</dd>
	<dt><code><b>void insert(iterator p, In first, In last)</b></code>  <em class="red">(vector,list,deque)</em></dt>
	<dd>Ins&egrave;re les &eacute;l&eacute;ments de l'intervalle semi-ferm&eacute; <code>[first,last[</code> imm&eacute;diatement
	avant <code>p</code>. Le code suivant ins&egrave;re tout le vecteur <code>V1</code>, moins les trois premiers &eacute;l&eacute;ments,
	au d&eacute;but de la liste <code>L1</code>. Cette insertion est performante, puisque le conteneur de destination est une liste.
	Par ailleurs, on remarquera que la nature des conteneurs source et destination n'a aucune importance.
<pre class="demo">
vector&lt;int&gt; V1;
list&lt;int&gt; L1;
...
vector&lt;int&gt;::iterator i=V1.begin()+3;
L1.insert(L1.begin(),i, V1.end());
</pre></dd>
	
	<dt><code><b>iterator erase(iterator p)</b></code> <em class="red">(vector,deque,list)</em><br />
	<code><b>void erase(iterator p)</b></code> <em class="red">(map,set)</em></dt>
	<dd>Supprime l'&eacute;l&eacute;ment sur lequel pointe <code>p</code>. La performance d&eacute;pend du type
	de conteneur. Pour un conteneur s&eacute;quentiel, renvoie un itÔøΩrateur pointant sur le successeur 
	imm&eacute;diat de l'&eacute;l&eacute;ment d&eacute;truit, &eacute;ventuellement <code>end()</code>.</dd>
	<dt><code><b>iterator erase(iterator first, iterator last)</b></code> <em class="red">(vector,deque,list)</em><br />	
	<code><b>void erase(iterator first, iterator last)</b></code> <em class="red">(map,set)</em></dt>
	<dd>Supprime tous les &eacute;l&eacute;ments de l'intervalle semi-ouvert <code>[first,last[</code>.
	La performance d&eacute;pend du type de conteneur. Pour un conteneur s&eacute;quentiel, renvoie un 
	it&eacute;rateur pointant sur le successeur imm&eacute;diat du dernier &eacute;l&eacute;ment d&eacute;truit, &eacute;ventuellement <code>end()</code>.</dd>
	<dt><code><b>void remove(const value_type &amp; valeur)</b></code> <em class="red">(list)</em></dt>
	<dd>Supprime de la liste tous les &eacute;l&eacute;ments &eacute;gaux &agrave; <code>valeur</code></dd>
	<dt><code><b>void unique()</b></code> <em class="red">(list)</em></dt>
	<dd>Supprime de la liste tous les &eacute;l&eacute;ments con&eacute;cutifs &eacute;gaux 
	de la liste, sauf un.</dd>
	<dt><code><b>void clear()</b></code>  <em class="red">(tous sauf stack)</em></dt>
	<dd>Efface tous les &eacute;l&eacute;ments.</dd>
      </dl></li>
<li><b>Op&eacute;rations affectant l'ordre des &eacute;l&eacute;ments <em class="red">(uniquement list)</em></b>
      <dl>
	<dt><code><b>void reverse()</b></code></dt>
	<dd>Retourne l'ordre des &eacute;l&eacute;ments dans la liste.</dd>
	<dt><code><b>void sort()</b></code> </dt>
	<dd>Trie les &eacute;l&eacute;ments de la liste en utilisant <code>operator&lt;</code></dd>
     </dl>
</li><li><b>Op&eacute;rations diverses</b>
      <dl>
	<dt><code><b>size_type size() const</b></code> <em class="red">(tous)</em></dt>
	<dd>renvoie le nombre d'&eacute;l&eacute;ments dans le conteneur.</dd>
	<dt><code><b>bool empty() const</b></code> <em class="red">(tous)</em></dt>
	<dd>renvoie <code>true</code> si le conteneur est vide.</dd>
     </dl>
</li></ul>

<p><a href="#">top</a></p><hr />

<h3><a name="string">string: les cha&icirc;nes de caract&egrave;res</a></h3>

<p>Ce conteneur permet de  d&eacute;finir  un type cha&icirc;ne  de caract&egrave;res et de le manipuler
simplement et efficacement. Voici quelques-unes des fonctions-membres associ&eacute;es:</p>

<dl>
   <dt><em>Construction de cha&icirc;nes</em></dt>
   <dd>On peut utiliser un constructeur par d&eacute;faut, un constructeur permettant d'initialiser le 
   <code>string</code> &agrave; partir d'un <code>char *</code>, ainsi que beaucoup d'autres constructeurs.</dd>
   
   <dt><em>Concat&eacute;nation de cha&icirc;nes</em></dt>
   <dd>Surcharge de l'op&eacute;rateur <code><b>+</b></code>
   
<pre class="demo">
string A="hello";
string B="world";
string C = A + "   " + B;   // C contient hello world
...
</pre></dd>
   
   <dt><em>Tester l'&eacute;galit&eacute; entre deux cha&icirc;nes.</em></dt>
   <dd>Comme d'habitude, les op&eacute;teurs <code><b>==</b></code>, <code><b>!=</b></code>,
   <code><b>&lt;</b></code>, <code><b>&gt;</b></code> etc. sont l&agrave; pour cela.</dd>
   <dt><em>Conna&icirc;tre la longueur d'une cha&icirc;ne.</em></dt>
   <dd>Par la fonction-membre <code><b>length()</b></code>.</dd>
   <dt><em>Trouver un caract&egrave;re ou une sous-cha&icirc;ne dans une cha&icirc;ne</em></dt>
   <dd>La fonction-membre <code><b>find</b></code> renvoie un nombre de type <code><b>string::size_type</b></code>. Si le caract&egrave;re
   n'existe pas, elle renvoie le membre constant <code><b>string::npos</b></code>. Comme pour les autres conteneurs,
   le premier &eacute;l&eacute;ment a pour indice 0.

<pre class="demo">
...
string::size_type p1 = C.find('o');	  // renvoie 4
string::size_type p2 = C.find('o',p1+1);  // renvoie 9
string::size_type p3 = C.find('z');       // renvoie npos
if (p3 == string::npos) {
   cout &lt;&lt; "Pas de lettre z " &lt;&lt; endl;
...
</pre></dd>

   <dt><em>Touver  un caract&egrave;re diff&eacute;rent d'un caract&egrave;re donn&eacute;:</em></dt>
   <dd>La fonction-membre <code><b>find_first_not_of</b></code> est faite pour cela:

<pre class="demo">
...
string::size_type c1 = C.find(' ');	             // renvoie 5
string::size_type m2 = C.find_first_not_of(' ',c1);  // renvoie 8
...
</pre></dd>

   <dt><em>D&eacute;finir une sous-cha&icirc;ne</em></dt>
   <dd>Fonction-membre <code><b>substr</b></code>. Ses deux param&egrave;tres sont: la position &agrave; partir
   de laquelle d&eacute;marrer la sous-cha&icirc;ne, et la longueur de celle-ci.
   
<pre class="demo">
...
string milieu = C.substr(p1,p2-p1+1); // renvoie o   wo 
...
</pre></dd>

   <dt><em>Effacer une sous-cha&icirc;ne</em></dt>
   <dd>Fonction-membre <code><b>erase</b></code>. Ses deux param&egrave;tres sont: la position &agrave; partir
   de laquelle d&eacute;marrer la sous-cha&icirc;ne, et la longueur de celle-ci. Renvoie la cha&icirc;ne
   apr&egrave;s la suppression r&eacute;alis&eacute;e:
   
<pre class="demo">
...
C.erase(p1,p2-p1+1);   // C vaut maintenant hellrld
string milieu = C.substr(p1,p2-p1+1); // renvoie o   wo 
...
</pre></dd>

  <dt><em>Ins&eacute;rer une sous-cha&icirc;ne</em></dt>
  <dd>Fonction-membre <code><b>insert</b></code>. Ses deux param&egrave;tres sont: la position &agrave; partir
   de laquelle d&eacute;marrer l'insertion, et la cha&icirc;ne &agrave; ins&eacute;rer.

<pre class="demo">
...
C.insert(1,milieu);    // C vaut maintenant ho   woellrld 
...
</pre></dd>
   
  <dt><em>Ajouter des caract&egrave;res en fin de cha&icirc;ne</em></dt>
  <dd>La fonction-membre <code><b>push_back</b></code> est utilisable dans ce but.</dd>
  
  <dt><em>Travailler avec des <code>char *</code></em></dt>
  <dd>De nombreuses fonctions C utilisent non pas l'objet <code><b>string</b></code>, mais le type 
  <code><b>char *</b></code>. La fonction <code><b>c_str()</b></code> permet de passer d'une <code>string</code>
  vers un <code>char *</code>, alors que le constructeur de cha&icirc;ne permet de passer d'un <code>char *</code>
  vers une <code>string</code>, ainsi qu'on l'a vu au dÔøΩbut de ce chapitre.
  
<pre class="demo">
...
char * c = C.c_str();
...
</pre></dd>
</dl>

<p><a href="#">top</a></p><hr />

<h2><a name="iterateurs">Les it&eacute;rateurs</a></h2>

<p>Un it&eacute;rateur est un objet associ&eacute; &agrave; un conteneur, qui
va  permettre de  balayer l'ensemble  des objets  se trouvant  dans le
conteneur, et ceci  sans avoir aucune id&eacute;e de  la structure de donn&eacute;es
sous-jacente;  des   boucles  <code>for</code>  ou  <code>while</code>
permettront  de  balayer le  conteneur,  <em>exactement</em> comme  on
balaierait un tableau classique en C:</p>

<pre class="demo">
typedef vector &lt;int&gt; v_int;
typedef vector &lt;int&gt;::iterator v_int_it;

v_int V1;
V1.push_back(1);
V1.push_back(2);
V1.push_back(3);
...
V1.push_back(10);

<b>for (v_int_it i=V1.begin();i!=V1.end();++i) {
  cout &lt;&lt; *i &lt;&lt; endl;</b>
};
  ...
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />La 
ligne  <code>cout &lt;&lt;  *i &lt;&lt;  endl  </code> ne
signifie   pas   que  <code>i</code>   est   un  v&eacute;ritable   pointeur:
<code>i</code> est un <em>objet</em> qui impl&eacute;mente une <em>abstraction</em>  de la notion de pointeur:
l'op&eacute;rateur <code>*</code> est ici surcharg&eacute;.</p></div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
<code>V1.begin()</code> et <code>V1.end()</code>
sont tous deux des  it&eacute;rateurs, mais alors que <code>V1.begin()</code>
pointe    sur    le    <em>premier</em>    &eacute;l&eacute;ment    du    conteneur,
<code>V1.end()</code> pointe <em>apr&egrave;s</em>  le dernier &eacute;l&eacute;ment. De la
sorte, pour balayer l'ensemble du conteneur, il faut:</p>

<ul>
  <li>Initialiser l'it&eacute;rateur sur <code>V1.begin()</code></li>
  <li>Incr&eacute;menter (<code>++</code>) l'it&eacute;rateur &agrave; chaque it&eacute;ration, de pr&eacute;f&eacute;rence
  &agrave; l'aide de la version pr&eacute;fix&eacute;e <a  href="surch.html#ope-incr"><img alt="avant" src="avant.gif" /></a></li>
  <li>Sortir de la boucle d&egrave;s que l'it&eacute;rateur est &eacute;gal &agrave; <code>V1.end()</code></li>
</ul>
</div>

<h3><a name="it-val">It&eacute;rateurs valides et invalides</a></h3>

<p>Un it&eacute;rateur qui pointe sur un &eacute;l&eacute;ment est dit <em>valide</em>. Dans
ce cas, <code>*i</code> renvoie un &eacute;l&eacute;ment du conteneur. Un it&eacute;rateur
peut &ecirc;tre valide &agrave; un certain moment de l'ex&eacute;cution du programme, puis &ecirc;tre invalide
un peu plus tard. Un it&eacute;rateur peut &ecirc;tre <em>invalide</em> pour les raisons suivantes:</p>

<ul>
  <li>Il n'a pas &eacute;t&eacute; initialis&eacute;</li>
  <li>Le conteneur a &eacute;t&eacute; redimensionn&eacute; (par des insertions ou des
      suppressions, par exemple).</li>
  <li>Le conteneur a &eacute;t&eacute; d&eacute;truit</li>
  <li>L'it&eacute;rateur pointe sur la fin de la s&eacute;quence
      (<code>V1.end()</code> dans l'exemple ci-dessus).</li>
</ul>

<p>Les conteneurs se diff&eacute;rencient par la mani&egrave;re dont les it&eacute;rateurs 
deviennent invalides: par exemple, le code suivant a toutes les chances d'invalider <code>i</code>:</p>

<pre class="demo">
vector &lt;int&gt; V1;
i=V1.begin() + 4;      // pointe sur le 5 &egrave; &eacute;l&eacute;ment.
<b>V1.insert(i,100000,0); // ins&egrave;re plein de cases juste avant <code>i</code>
cout &lt;&lt; *i &lt;&lt;endl;     // plantage car i est devenu invalide</b>
</pre>

<p>En effet, lors de l'insertion de 100000 entiers, il y a fort &agrave; parier que le vecteur s'est trouv&eacute;
une autre z&ocirc;ne de m&eacute;moire, de sorte que l'int&eacute;rateur s'est mis &agrave; pendouiller
b&ecirc;tement. Par contre, le code suivant ne pr&eacute;sentera pas de probl&egrave;me:</p>

<pre class="demo">
<b>typedef list &lt;int&gt; l_int;</b>
typedef list &lt;int&gt;::iterator l_int_it;

l_int L1;
L1.push_back(1);
L1.push_back(2);
L1.push_back(3);
...
L1.push_back(10);

l_int_v1 i = L1.begin();
i++;i++;i++;i++;       // pointe sur le 5 &egrave; &eacute;l&eacute;ment.
<b>L1.insert(i,100000,0); // ins&egrave;re plein de cases juste avant <code>i</code>
cout &lt;&lt; *i &lt;&lt;endl;     // Pas de plantage</b>
</pre>

<p>En effet, l'objet de type <code>list</code> s'arrange pour que <code>i</code> reste toujours valide dans ce cas.</p>

<h3><a name="it-cat">Les diff&eacute;rentes cat&eacute;gories d'it&eacute;rateurs</a></h3>

<p>Les it&eacute;rateurs peuvent  &ecirc;tre class&eacute;s  en plusieurs
cat&eacute;gories; suivant les  cat&eacute;gories auxquelles ils appartiennent, nous
avons  plus ou  moins d'op&eacute;rations  &agrave; notre  disposition;</p>


<h4>Int&eacute;rateurs In (Input)</h4>

<p>On ne peut effectuer que 4 op&eacute;rations:</p>

<ol>
   <li><em>&eacute;galit&eacute;</em> <code><b>j = i </b></code></li>
   <li><em>Incr&eacute;mentation</em> <code><b>++i</b></code> ou <code><b>i++</b></code></li>
   <li><em>D&eacute;r&eacute;f&eacute;rencement, en lecture seule</em> <code><b>A = *i </b></code></li>
   <li><em>Test d'&eacute;galit&eacute;</em> <code><b>i == j </b></code></li>
</ol>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Il est impossible de faire
<code><b>*i = A </b></code> avec cet it&eacute;rateur.</p></div>
<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Il est impossible de d&eacute;r&eacute;f&eacute;rencer
plus d'une fois le m&ecirc;me &eacute;l&eacute;ment. Ainsi, le code <code><b>A = *i; B = *i</b></code> ne marche pas.</p></div>

<p>On doit penser &agrave; cet it&eacute;rateur comme &agrave; un objet permettant de lire un fichier.</p>

<h4>Int&eacute;rateurs Out (Output)</h4>

<p>On ne peut effectuer que 3 op&eacute;rations:</p>

<ol>
   <li><em>&eacute;galit&eacute;</em> <code><b>j = i </b></code></li>
   <li><em>Incr&eacute;mentation</em> <code><b>++i</b></code> ou <code><b>i++</b></code></li>
   <li><em>D&eacute;r&eacute;f&eacute;rencement, en &eacute;criture seule</em> <code><b>*i = A </b></code></li>
</ol>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Il est impossible de faire
<code><b>A = *i</b></code> avec cet it&eacute;rateur.</p></div>
<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Il est impossible de d&eacute;r&eacute;f&eacute;rencer
plus d'une fois le m&ecirc;me &eacute;l&eacute;ment. Ainsi, le code <code><b>*i = A; *i = B</b></code> ne marche pas.</p></div>

<p>On doit penser &agrave; cet it&eacute;rateur comme &agrave; un objet permettant d'&eacute;crire un fichier.</p>

<h4>Int&eacute;rateurs For (Forward)</h4>

<p>Permet de balayer une s&eacute;quence du d&eacute;but &agrave; la fin, mais sans retour en arri&egrave;re 
possible. Les op&eacute;rations support&eacute;es par les it&eacute;rateurs In <em>et</em> Out sont 
&eacute;galement disponibles avec cet it&eacute;rateur. On peut &eacute;galement d&eacute;r&eacute;f&eacute;rencer
l'it&eacute;rateur autant de fois qu'on veut. </p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Partout o&ugrave; un it&eacute;rateur <code>In</code> 
ou <code>Out</code> est requis, vous pourrez fournir un it&eacute;rateur <code>For</code>.</p></div>
  
<h4>Int&eacute;rateurs Bi (Bidirectionnels)</h4>

<p>Tout ce qui est permis par l'it&eacute;rateur <code>For</code>, avec en plus:</p>

<ol>
   <li><em>D&eacute;cr&eacute;mentation</em> <code><b>--i</b></code> ou <code><b>i--</b></code></li>
</ol>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Partout o&ugrave; un it&eacute;rateur <code>In</code> 
ou <code>In</code>, <code>Out</code> ou <code>For</code> est requis, vous pourrez fournir un it&eacute;rateur <code>Bi</code>.</p></div>

<h4>Int&eacute;rateurs Ran (Random)</h4>

<p>Tout ce qui est permis par l'it&eacute;rateur <code>Bi</code>, avec en plus:</p>

<ol>
   <li><em>Op&eacute;rateur d'indexation</em> <code><b>i[3]</b></code></li>
   <li><em>Ajout ou suppression d'entiers</em> <code><b>j=i+3; j=i-4; i +=2;</b></code></li>
   <li><em>Op&eacute;rateur <b>-</b>: la diff&eacute;rence entre deux it&eacute;rateurs random est un entier</em> <code><b>if (j-i==4)...</b></code></li>
</ol>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Partout o&ugrave; un it&eacute;rateur <code>In</code> 
ou <code>In</code>, <code>Out</code>, <code>For</code> ou <code>Bi</code> est requis, 
vous pourrez fournir un it&eacute;rateur <code>Bi</code>.</p></div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Un it&eacute;rateur random offre les m&ecirc;mes possibilit&eacute;s qu'un pointeur conventionnel.

</p></div>

<h4>Les it&eacute;rateurs <code>const</code></h4>

<p>La fonction suivante ne pourra pas &ecirc;tre compil&eacute;e:</p>

<pre class="demo">
typedef list&lt;int&gt; li;
typedef list&lt;int&gt;::iterator ili;

void  pl(const li &amp; L) {
  for(ili i=L.begin();i!=L.end();i++) {
    <b>cout &lt;&lt; *i &lt;&lt;  endl;</b>
  };
};
</pre>

<p>En   effet,  le  type   <code>ili</code>  ne  peut
s'appliquer  sur  un  objet  constant,  puisqu'il  est  susceptible  de
modifier   cet   objet.   Il    faut   dans   ce   cas   d&eacute;clarer   un
<code>const_iterator</code>, d'o&ugrave; le code ci-dessous:</p>

<pre class="demo">
typedef list&lt;int&gt; li;
<b>typedef list&lt;int&gt;::const_iterator cili;</b>

void  pl(const li &amp; L) {
  for(cili i=L.begin();i!=L.end();i++) {
    <b>cout &lt;&lt; *i &lt;&lt;  endl;</b>
  };
};
</pre>

<h4>Les it&eacute;rateurs <code>reverse</code></h4>

<p>Ils  permettent de  balayer  la  s&eacute;quence en  sens
inverse. Leur description sort toutefois du cadre de ce cours.</p>

<h3><a name="it-int">Sp&eacute;cifier un intervalle &agrave; l'aide de deux it&eacute;rateurs.</a></h3>

<p>Un grand nombre de fonctions membres, ou d'algorithmes, demandent deux it&eacute;rateurs en entr&eacute;e,
afin de sp&eacute;cifier un intervalle: <em>Dans tous les cas</em>, cet intervalle est semi-ouvert:</p>

<ul>
  <li>Ferm&eacute; sur la borne inf&eacute;rieure</li>
  <li>Ouvert sur la borne sup&eacute;rieure</li>
</ul>

<p>En effet, utiliser des intervalles de ce type pr&eacute;sente plusieurs int&eacute;r&ecirc;ts:</p>

<ul>
  <li>La borne sup&eacute;rieure de l'intervalle &eacute;tant en-dehors de celui-ci, on peut utiliser
  la fonction <code>end()</code>, pr&eacute;sente dans tous les conteneurs, pour signifier qu'on va jusqu'au
  bout de celui-ci. M&ecirc;me si le dernier &eacute;l&eacute;ment change au cours du temps,
  (lorsqu'on ajoute un &eacute;l&eacute;ment en bout de conteneur, par exemple) <code>end()</code> ne changera pas</li>
  <li>Dans le cas d'it&eacute;rateurs "Random", la diff&eacute;rence entre borne sup&eacute;rieure et 
  borne inf&eacute;rieure renverra toujours le nombre d'&eacute;l&eacute;ments se trouvant entre les deux bornes: pas
  besoin de se creuser la t&ecirc;te pour r&eacute;soudre des probl&egrave;mes tordus d'intervalles...</li>
</ul>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Lorsque vous sp&eacute;cifiez un intervalle par <code>[first,last[</code> <code>first</code> et <code>last</code>
doivent &ecirc;tre deux it&eacute;rateurs valides <em>du m&ecirc;me conteneur</em>. Le type de conteneur n'a par contre
aucune importance. </p></div>

<p><a href="#">top</a></p><hr />

<h3><a name="kikoi">Qui fait quoi ? </a></h3>

<p >Les  tableaux  ci-dessous   ne sont qu'un r&eacute;sum&eacute; des paragraphes ci-dessus.
En particulier, on a insit&eacute; ici sur les diff&eacute;rences de performances entre les diff&eacute;rents
conteneurs, suivant les fonctions membres.</p>

<ul>
  <li><code><b>o</b></code> Fonction-membre pr&eacute;sente</li>
  <li><code><b>const</b></code> Fonction-membre pr&eacute;sente,
      performance constante (quelque soit le nombre d'&eacute;l&eacute;ments dans le
      conteneur)</li>
  <li><code><b>O(n)</b></code> Fonction-membre pr&eacute;sente,
      dur&eacute;e proportionnelle au nombre d'&eacute;l&eacute;ments</li>
  <li><code><b>O(log(n))</b></code> Fonction-membre
      pr&eacute;sente, dur&eacute;e proportionnelle au logarithme du nombre d'&eacute;l&eacute;ments</li>
  <li><code><b>+</b></code> surco&ucirc;t &agrave; pr&eacute;voir de temps en
      temps (lors de demandes automatiques d'allocation m&eacute;moire, par exemple)</li>
</ul>

<table class="tableau">
  <caption> <em>Fonctions membres "non mutantes"</em></caption>
  <tr>
    <th> Conteneurs </th><th> It&eacute;rateurs </th><th colspan="5"> Fonctions
	membres </th>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><code>(r)begin()</code>,<br />
	<code>(r)end()</code></td>
    <td><code>front()</code>,<br /><code>back()</code></td>
    <td><code>[]</code></td>
    <td><code>find()</code></td>
    <td><code>size()</code></td>
  </tr>
  <tr>
    <td> <code><b>vector</b></code> </td>
    <td><b>Ran</b></td>
    <td><b>o</b></td>
    <td><b>o</b></td>
    <td><b>const</b></td>
    <td>&nbsp;</td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>list</b></code> </td>
    <td><b>Bi</b></td>
    <td><b>o</b></td>
    <td><b>o</b></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>deque</b></code> </td>
    <td><b>Ran</b></td>
    <td><b>o</b></td>
    <td><b>o</b></td>
    <td><b>const</b></td>
    <td>&nbsp;</td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>queue</b></code> </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>priority_queue</b></code> </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>stack</b></code> </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>map</b></code> </td>
    <td><b>Bi</b></td>
    <td><b>o</b></td>
    <td>&nbsp;</td>
    <td><b>O(log(n))</b></td>
    <td><b>O(log(n))</b></td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>set</b></code> </td>
    <td><b>Bi</b></td>
    <td><b>o</b></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>O(log(n))</b></td>
    <td><b>o</b></td>
  </tr>
</table>
<p>&nbsp;</p>
<table class="tableau">
<caption> <em>Fonctions membres "mutantes"</em></caption>  
  <tr>
    <th> Conteneurs </th><th colspan="7"> Fonctions membres </th>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><code>push_back</code>,<br /><code>pop_back</code></td>
    <td><code>push_front</code>,<br /><code>pop_front</code></td>
    <td><code>pop</code></td>
    <td><code>push</code></td>
    <td><code>top</code></td>
    <td><code>insert()<br />
	erase()</code></td>
    <td><code>clear()</code></td>
  </tr>
  <tr>
    <td> <code><b>vector</b></code> </td>
    <td><b>const+</b></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>O(n)+</b></td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>list</b></code> </td>
    <td><b>const</b></td>
    <td><b>const</b></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>const</b></td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>deque</b></code> </td>
    <td><b>const</b></td>
    <td><b>const</b></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>O(n)</b></td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td><code><b>queue</b></code> </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>const</b></td>
    <td><b>const+</b></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><code><b>priority_queue</b></code> </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>O(log(n))</b></td>
    <td><b>O(log(n))</b></td>
    <td><b>o</b></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td> <code><b>stack</b></code> </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>const</b></td>
    <td><b>const+</b></td>
    <td><b>o</b></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td> <code><b>map</b></code> </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>O(log(n))+</b></td>
    <td><b>o</b></td>
  </tr>
  <tr>
    <td> <code><b>set</b></code> </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><b>O(log(n))+</b></td>
    <td><b>o</b></td>
  </tr>
</table>

<p><a href="#">top</a></p><hr />

<h2><a name="algo">Algorithmes</a></h2>

<p>La  biblioth&egrave;que  standard fournit  &eacute;galement  des
algorithmes  (fonctions)  qui  permettent  de r&eacute;aliser  toutes  sortes
d'op&eacute;rations  sur  les  &eacute;l&eacute;ments  d'un  conteneur.   Il  sera  souvent
n&eacute;cessaire  de passer  un  objet fonction  en  param&egrave;tre; par  exemple
l'algorithme   <code><b>find_if</b></code>  qui   recherche   dans  un
conteneur  les  &eacute;l&eacute;ments qui  r&eacute;pondent  &agrave;  une  condition donn&eacute;e:  la
condition sera pass&eacute;e  sous forme d'un objet fonction  &agrave; un param&egrave;tre,
qui renverra  soit <code>true</code>, soit  <code>false</code> (un tel
objet  est   appel&eacute;  un  <em>pr&eacute;dicat</em>).    <br />  Les  principales
fonctionnalit&eacute;s sont les suivantes:</p>

<ul>
  <li>Appeler une fonction pour chaque objet d'un conteneur (<code>for_each</code>, &eacute;quivalente
  &agrave; la fonction pr&eacute;d&eacute;finie <code>map</code> du perl).</li>
  <li>Trouver un &eacute;l&eacute;ment, une paire d'&eacute;l&eacute;ments</li>
  <li>Trouver la premi&egrave;re occurrence, ou la derni&egrave;re occurrence d'une
      valeur dans une s&eacute;quence.</li>
  <li>Compter les occurrences d'une valeur dans une s&eacute;quence</li>
  <li>copie, remplace, copie si telle condition est r&eacute;alis&eacute;e,...</li>
  <li>retire un &eacute;l&eacute;ment, retire tous les &eacute;l&eacute;ments correspondant &agrave; une
      condition particuli&egrave;re,...</li>
  <li>Trie, effectue une recherche binaire (sur une s&eacute;quence tri&eacute;e)</li>
  <li>recherche le minimum ou le maximum</li>
  <li>etc.</li>
</ul>

<h3>Un exemple d'utilisation d'algorithmes</h3>

<p>L'extrait de code ci-dessous montre une mani&egrave;re amusante d'imprimer tous les &eacute;l&eacute;ments 
d'un conteneur (quelque soit le conteneur, d'ailleurs):</p>

<pre class="demo">
class sortie {
    public: 
    sortie (const string &amp; s): msg(s){;};
    void operator()(int i) {
	cout &lt;&lt; msg &lt;&lt; i &lt;&lt; "\n";
    };
    private:
    string msg;
};

...

vector&lt;int&gt; V1;
...

sortie s("coucou ");
for_each(V1.begin(), V1.end(),s);
</pre>

<p>La classe <code>sortie</code> permet de d&eacute;finir un objet-fonction, c'est-&agrave;-dire un objet
comportant <code>operator()</code>. Le constructeur de cet objet initialise un membre priv&eacute;. Par la suite,
on cr&eacute;e un objet de type <code>sortie</code>, et on appelle la fonction <code>for_each</code> en lui passant
deux it&eacute;rateurs (pour d&eacute;finir un intervalle) ainsi que l'objet-fonction pr&eacute;c&eacute;demment
cr&eacute;&eacute;. Pour plus de d&eacute;tails, aller voir la documentation de 
<code><a href="http://www.sgi.com/tech/stl/for_each.html">for_each</a></code>.</p>

<p><a href="#">top</a></p><hr />

<h3 id="tri">Trier un conteneur</h3>

<p>Seuls les conteneurs suivants peuvent &ecirc;tre tri&eacute;s:</p>

<ul>
   <li><code>vector</code></li>
   <li><code>deque</code></li>
   <li><code>list</code></li>
</ul>

<h4>Trier un <code>vector</code> ou un <code>deque</code></h4>

<p>Les vecteurs et les deque &eacute;tant munis d'un it&eacute;rateur &agrave; acc&egrave;s direct, ils peuvent &ecirc;tre tri&eacute;s en ordre croissant en utilisant l'algorithme <code>sort</code>, ainsi qu'on le voit ci-dessous:</p>

<pre class="demo">
vector&lt;int&gt; v1;
<b>sort(v1.begin(),v1.end());</b>          // trie le vecteur entier
<b>sort(v1.begin(),v1.begin()+10);</b>     // trie les 10 premiers &eacute;l&eacute;ments
</pre>

<p>Les objets du conteneur seront physiquement chang&eacute;s de place, ce qui n'est pas g&ecirc;nant pour des entiers, mais peut devenir p&eacute;nalisant dans le cas d'objets.</p>

<h4>Trier une <code>list</code></h4>

<p>L'algorithme <code>sort</code> n'est pas utilisable avec les listes, car il n'existe pas d'it&eacute;rateur &agrave; acc&egrave;s direct  pour ce type de conteneurs. Par contre, la structure chain&eacute;e d'une liste permet d'envisager des tris bien plus performants que dans le cas des vecteurs. On utilise donc la fonction-membre <code>sort</code>:</p>

<pre class="demo">
list&lt;int&gt; l1;
<b>l1.sort();</b>  // trie la liste en entier
</pre>

<p>Par contre, il n'est pas possible de trier partiellement une liste </p>

<h4>Contr&ocirc;ler l'ordre du tri</h4>

<p>Les exemples ci-dessus trient les conteneurs dans l'ordre croissant de leurs &eacute;l&eacute;ments. Encore faut-il que cet ordre soit d&eacute;fini, ce qui n'est a priori pas &eacute;vident lorsqu'il s'agit d'objets. On peut d&eacute;finir l'ordre de deux mani&egrave;res:</p>

<ul>
   <li>Par la surcharge de l'op&eacute;rateur &lt; (utilisation par d&eacute;faut de <code>sort</code>)</li>
   <li>Par la d&eacute;finiton d'une fonction de comparaison, et le passage de cette fonction &agrave; la fonction de tri:</li>
</ul>

<pre class="demo">
bool Comparaison(const objet& o1, const objet& o2) {
   if (o1 est inf&eacute;rieur &agrave; o2)
      return true;
   else
      return false;
}
list&lt;int&gt; l1;
<b>l1.sort(Comparaison);</b>

vector&lt;int&gt; v1;
<b>sort(v1.begin(),v1.end(),Comparaison);</b>
</pre>
   
<h3 id="listes">Manipuler des listes</h3>

<p>Il est ais&eacute; de manipuler des &eacute;l&eacute;ments de liste: on trouve ainsi de fonctions-membres permettant de:

<ul>
  <li>Supprimer un ou plusieurs objets (<code>remove</code>, <code>remove_if</code>)</li>
  <li>Faire une liste &agrave; partir de deux listes, tout en respectant l'ordre des &eacute;l&eacute;mets (<code>merge</code>)</li>
  <li>Vider une liste de tous ses &eacute;l&eacute;ments (ou seulement de quelques-uns) pour les mettre dans une autre: <code>splice</code></li>
</ul>

<p>Ci-dessous un exemple d'utilisation de <code>splice:</code></p>

<pre class = "demo" >
list&lt;int&gt;l1, l2,l3;
...
<b>l1.splice(l1.end(),l2); // (1)
l3.splice(l3.end(),l2.begin()); // (2)</b>

</pre>

<p>Dans l'exemple (1), on a "vid&eacute;" <code>l2</code> en mettant tous ses &eacute;l&eacute;ments &agrave; la fin de <code>l1</code>. Dans l'exemple (2), on a simplement mis le premier &eacute;l&eacute;ment de l2 &agrave; la fin de l3.</p>

<h2><a name="stream">Les entr&eacute;es-sorties</a></h2>

<p>Les entr&eacute;es-sorties  se font  &agrave;  travers plusieurs
objets  "flots"  dont la  hi&eacute;rarchie  se  trouve partiellement  r&eacute;sum&eacute;e
ci-dessous:</p>

<pre><em>
ios
   istream
       ifstream
       istringstream
       iostream -------
   ostream             |
       ofstream        iostream
       ostringstream   |    fstream
       iostream -------     stringstream
</em></pre>

<h3><a name="io-stream">Les objets de type ostream ou istream</a></h3>

<p>Pour ouvrir  un fichier,  il suffit  d'instancier un
objet de  type <code>ostream</code>  (ouverture en &eacute;criture),  de type
<code>istream</code>  (ouverture  en   lecture),  ou  encore  de  type
<code>iostream</code>    (ouverture   en    lecture-&eacute;criture)</p>   

<p>Pour fermer le fichier  ouvert, le plus simple est de
d&eacute;truire l'objet,  par exemple  d'attendre la fin  du bloc  afin qu'il
soit  automatiquement d&eacute;truit  (il n'est  alors pas  n&eacute;cessaire  de se
pr&eacute;occuper de la fermeture du fichier), ou dans le cas d'un objet cr&eacute;&eacute;
avec     l'op&eacute;rateur     <code>new</code>    d'appeler     l'op&eacute;rateur
<code>delete</code>.:</p>

<pre class="demo">
{                            // debut de bloc
   ofstream F1("toto");      // ouvre un fichier en sortie et l'appelle toto
   ...
}                           // fin de bloc = fermeture du fichier
</pre>

<h3><a name="io-bin">Lecture-&eacute;criture en binaire</a></h3>

<p>Pour   &eacute;crire  ou  lire  des   donn&eacute;es  en  binaire,
c'est-&egrave;-dire simplement &eacute;crire (lire)  une image d'un bloc de m&eacute;moire,
il  suffit  d'utiliser  les  fonctions-membres  <code>write</code>  ou
<code>read</code>.</p>

<pre class="demo">
char bfr[50000];
int size;
...
{
   ofstream OUT("toto-bin",ios::binary);  // ouvre un fichier en &eacute;criture
   OUT.write(bfr,size);                   // recopie le buffer
}                                         // ferme le fichier
...
{
   ifstream IN("toto-bin",ios::binary);  // ouvre un fichier en &eacute;criture
   IN.read(bfr,size);                    // recopie le buffer
}                                        // ferme le fichier
</pre>


<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Attention aux d&eacute;bordements de buffers en
utilisant ces fonctions !!! Rien ne garantit que
size n'est pas sup&eacute;rieur &agrave; 50000 dans l'exemple ci-dessus. 
</p></div>

<h3><a name="io-get">Fonctions get, put, getline</a></h3>

<p>La fonction <code>out.put(c)</code> o&ugrave;
<code>c</code> est un <code>char</code>, permet d'envoyer ce caract&egrave;re sur la
sortie. Elle est strictement &eacute;quivalente &agrave; <code>out &lt;&lt; c</code>.</p>

<p>La fonction <code>in.get(c)</code> o&ugrave; <code>c</code>
est un <code>char</code> est plus int&eacute;ressante, dans la mesure o&ugrave;,
contrairement &agrave; l'op&eacute;rateur <code>&gt;&gt;</code>, elle ne fait
<i>aucune</i> interpr&eacute;tation du caract&egrave;re lu. Elle permet par exemple
de lire les espaces ou les '\n', qui sont interpr&eacute;t&eacute;s par
<code>&gt;&gt;</code>.</p>
 
<p>La fonction-membre <code>getline</code> est bien
pratique pour lire un 
fichier ligne par ligne. Son prototype est le suivant:</p>

<pre class="demo">
getline(char* buffer, int taille, char delimiteur='\n')
</pre>

<p> Le
d&eacute;limiteur par d&eacute;faut est le caract&egrave;re de fin de ligne, tandis que la
possibilit&eacute; de fixer une taille permet de s'assurer que le buffer ne
d&eacute;borde pas. Juste apr&egrave;s un appel <code>getline</code>, la
fonction-membre <code>gcount()</code> permet de savoir quelle est la
longueur de la chaine de caract&egrave;res effectivement lue.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Il existe aussi une fonction <code>getline</code>
(qui <em>n'est pas</em> une fontion membre) permettant de lire une ligne
dans un objet de type <code>string</code>. On pourrait penser que
cette fonction est bien sympathique, puisqu'il n'y a plus &agrave; se
pr&eacute;occuper des d&eacute;bordements de tampons... mais attention, elle va
environ <i>quatre fois plus lentement</i> que la fonction-membre
<code>getline</code>... A utiliser avec parcimonie, donc.
</p></div>

<h3><a name="stream-fmt">Entr&eacute;es-sorties formatt&eacute;es:  &lt;&lt; et &gt;&gt;</a></h3>

<p> Les op&eacute;rateurs  <code>&lt;&lt;</code> et
<code>&gt;&gt;</code>  sont  surcharg&eacute;s  de  sorte  qu'ils  permettent
respectivement l'entr&eacute;e ou la sortie:</p>

<pre class="demo">
string A = "voici une chaine";
int B = 56;
objet O;                     // Objet dont le type a &eacute;t&eacute; d&eacute;fini plus haut
...

ofstream F1("toto");         // ouvre un fichier en sortie et l'appelle toto
F1 &lt;&lt; A &lt;&lt; " " &lt;&lt; B &lt;&lt; "\n"; // Ecrit A, puis B
F1 &lt;&lt; O &lt;&lt; "\n";             // Ecrit O
</pre>

<p> En  particulier,  tous les  types  de  base  du langage  peuvent  &ecirc;tre
utilis&eacute;s avec ces op&eacute;rateurs.  Mais par ailleurs, lorsque vous &eacute;crivez
la d&eacute;finition de la  classe <code>objet</code>, vous pouvez surcharger
cet  op&eacute;rateur, afin de  vous permettre par  la suite
d'&eacute;crire: <code>F1  &lt;&lt; O &lt;&lt;  "\n";</code> Nous verrons  plus tard
comment &eacute;crire un tel op&eacute;rateur.</p>

<h3><a name="ctrl-fmt">Le contr&ocirc;le du format</a></h3>
<p>Nous avons plusieurs outils &agrave; notre disposition pour contr&ocirc;ler le format d'&eacute;criture ou de lecture:</p>

<ul>
  <li> Les manipulateurs</li>
  <li> Les fonctions membres</li>
  <li> Les bits de contr&ocirc;le</li>
</ul>

<h4>Les manipulateurs</h4>

<p>Les manipulateurs  s'interposent  entre les  donn&eacute;es
imprim&eacute;es pour  agir sur  le fonctionnement du  flots. Particuli&egrave;rement
bien int&eacute;gr&eacute;s  au syst&eacute;me d'entr&eacute;es-sorties, ils sont  d'un usage tr&egrave;s
pratique.</p>

<h4>Les fonctions membres</h4>

<p>Un flots  &eacute;tant tout  simplement un  objet, plusieurs
fonctions membres sont d&eacute;finies afin de  fixer la valeur de tel ou tel
param&egrave;tre. Il existe  aussi des fonctions membres pour  lire la valeur
fix&eacute;e  actuellement.  Cela  permet,  par exemple,  de  sauvegarder  un
param&egrave;tre avant  de le modifier,  pour ensuite lui redonner  sa valeur
initiale.</p>

<h4>Les bits de contr&ocirc;le</h4>

<p>Plus classique:  certains param&egrave;tres sont accessibles
via   le   positionnement  de   bits   de   contr&ocirc;le.  Les   fonctions
<code>setf</code>  et  <code>unsetf</code>  permettent  respectivement
d'activer et d&eacute;sactiver  les bits de contr&ocirc;le, tout  en renvoyant leur
ancienne valeur pour sauvegarde &eacute;ventuelle.</p>

<h4>Pr&eacute;cision, largeur de champ, caract&egrave;re de remplissage</h4>

<table class="tableau">
  <tr>
    <th>Fonctions membres</th>
    <th>R&eacute;sultats</th>
  </tr>
  <tr>
  <td>
  <pre class="demo">
float x = 4.56782765;
int savprec=cout.precision();
cout.precision(3);
cout &lt;&lt; &quot;x = &quot;;
cout.width(7);
cout &lt;&lt; x &lt;&lt; &quot;cm\n&quot;;

cout &lt;&lt; &quot;x = &quot;;
cout.width(7);
cout.fill('#');
cout &lt;&lt; x &lt;&lt; &quot;cm\n&quot;;
   </pre>
   </td>
   <td>
<pre class="demo">





x =4.57cm




x = ###4.57cm
</pre>
   </td>
   </tr>
   <tr>
   <th> Manipulateurs </th>
   <th>R&eacute;sultats</th>
   </tr>
   <tr>
   <td>
<pre class="demo">
float x = 4.56782765;
cout &lt;&lt; setprecision(3) &lt;&lt; &quot;x = &quot; 
     &lt;&lt; setw(7) &lt;&lt; x &lt;&lt; &quot;cm\n&quot;;
cout &lt;&lt; setprecision(3) &lt;&lt; setfill('#') 
     &lt;&lt; &quot;x = &quot; &lt;&lt; setw(7) &lt;&lt; x &lt;&lt; &quot;cm\n&quot;;
</pre>
   </td>
   <td>
<pre class="demo">


x =    4.57cm

x = ###4.57cm
</pre></td></tr></table>

	
<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
La  fonction  <code>width</code>  ainsi  que  le
manipulateur  <code>setw</code> ne  pr&eacute;cisent la  largeur d'impression
<em>que</em> pour la  prochaine op&eacute;ration de sortie. Il  n'en est pas de
m&ecirc;me  pour  la plupart  des  autres  fonctions  ou manipulateurs,dont l'effet est permanent.
</p></div>

<h4>Alignement &agrave; gauche ou &agrave; droite</h4>

<table class="tableau">
  <tr>
    <th>champs de bits</th>
    <th>R&eacute;sultats</th>
  </tr>
  <tr><td>
<pre class="demo">
float x = -4.56782765;
cout.precision(3);
cout.fill('-');
cout.setf(ios::left,ios::adjustfield);
cout &lt;&lt; &quot;x = &quot;;
cout.width(7);
cout &lt;&lt; x &lt;&lt; &quot;cm\n&quot;;

cout.setf(ios::right,ios::adjustfield);
cout &lt;&lt; &quot;x = &quot;;
cout.width(7);
cout &lt;&lt; x &lt;&lt; &quot;cm\n&quot;;
</pre></td>
<td>
<pre class="demo">






x = -4.57  cm




x =   -4.57cm
</pre></td>
</tr></table>

<h4>Notation scientifique, fixe</h4>

<table class="tableau">
<tr>
<th>champs de bits</th>
<th>R&eacute;sultats</th>
</tr>
<tr><td>
<pre class="demo">
float x = 4567.82765;
cout.precision(3);
cout.setf(ios::fixed,ios::floatfield);
cout &lt;&lt; &quot;x = &quot;;
cout.width(10);
cout &lt;&lt; x &lt;&lt; &quot;cm\n&quot;;

cout.setf(ios::scientific,ios::floatfield);
cout.precision(3);
cout &lt;&lt; &quot;x = &quot;;
cout.width(10);
cout &lt;&lt; x &lt;&lt; &quot;cm\n&quot;;
</pre></td>
<td>
<pre class="demo">





x =   4567.828cm





x =  4.568e+03cm
</pre></td>
</tr></table>

<h4>Afficher en hexad&eacute;cimal ou en octal</h4>

<table class="tableau">
<tr>
<th>champs de bits</th>
<th>R&eacute;sultats</th>
</tr>
<tr><td>
<pre class="demo">
int i =987654;
cout.setf(ios::showbase);
cout &lt;&lt; &quot;x = &quot;;
cout.width(10);
cout &lt;&lt; i &lt;&lt; &quot;..\n&quot;;

cout.setf(ios::oct,ios::basefield);
cout &lt;&lt; &quot;x = &quot;;
cout.width(10);
cout &lt;&lt; i &lt;&lt; &quot;..\n&quot;;

cout.setf(ios::hex,ios::basefield);
cout.setf(ios::showbase);
cout &lt;&lt; &quot;x = &quot;;
cout.width(10);
cout &lt;&lt; i &lt;&lt; &quot;..\n&quot;;

cout.setf(ios::uppercase);
cout &lt;&lt; &quot;x = &quot;;
cout.width(10);
cout &lt;&lt; i &lt;&lt; &quot;..\n&quot;;
</pre></td>
<td>
<pre class="demo">




x =     987654..




x =   03611006..





x =    0xf1206..




x =    0XF1206..
</pre></td>
</tr>
<tr>
   <th>Manipulateurs</th>
   <th>R&eacute;sultats</th>
</tr>
<tr><td>
<pre class="demo">
cout.unsetf(ios::showbase);
cout &lt;&lt; &quot;x = &quot;&lt;&lt; dec &lt;&lt; i &lt;&lt; &quot;..\n&quot;;

cout &lt;&lt; &quot;x = &quot;&lt;&lt; oct &lt;&lt; i &lt;&lt; &quot;..\n&quot;;

cout &lt;&lt; &quot;x = &quot;&lt;&lt; hex &lt;&lt; i &lt;&lt; &quot;..\n&quot;;
</pre></td>
<td>
<pre class="demo">

x = 987654..

x = 3611006..

x = f1206..
</pre></td></tr></table>


<h4>Jouer avec les tampons</h4>

<table class="tableau">
  <tr>
    <th>champs de bits</th>
  </tr>
  <tr>
    <td><pre class="demo">
int i =987654;
cout.setf(ios::unitbuf);
cout &lt;&lt; &quot;x = &quot; &lt;&lt; i;
    </pre></td></tr>
    <tr><th>Manipulateurs</th></tr>
    <tr><td><pre class="demo">
cout &lt;&lt; &quot;x = &quot;&lt;&lt; i &lt;&lt; flush;
    </pre></td></tr></table>
    
<p><code>unitbuf</code> assure que toute op&eacute;ration de
sortie sera envoy&eacute;e imm&eacute;diatement (le tampon n'est pas utilis&eacute;); cela
peut &ecirc;tre important par exemple lorsqu'on &eacute;crit dans un pipe, pour
assurer une bonne syncrhonisation. Le manipulateur <code>flush</code>
vide le tampon imm&eacute;datement.</p>

<h3><a name="io-sts">Ecrire... ou lire l'&eacute;tat du flot</a></h3>

<p>L'op&eacute;rateur <code>()</code> est surcharg&eacute; de sorte
que l'on puisse &eacute;crire:</p>

<pre class="demo">
OUT &lt;&lt; ...;
if (OUT) {
    ...    // Pas de pb
    ..
};
</pre>

<p>De m&ecirc;me, l'op&eacute;rateur <code>!</code> est surcharg&eacute; de
sorte que l'on puisse &eacute;crire:</p>

<pre class="demo">
OUT &lt;&lt; ...;
if (!OUT) {
    ...    // BIG PB
    ..
};
</pre>

<p>Par ailleurs, plusieurs fonctions-membres permettent
de tester plus pr&eacute;cis&eacute;ment l'&eacute;tat du fichier. Parmi elles, la plus
utile est <code>eof()</code> permettant de d&eacute;tecter la fin de fichier.</p>

<h3><a name="sortie-surch">Surcharger l'op&eacute;rateur &lt;&lt;</a></h3>

<p>L'op&eacute;rateur <code><b>&lt;&lt;</b></code> peut &ecirc;tre
surcharg&eacute; lorsqu'on &eacute;crit une classe, ainsi qu'on le voit ci-dessous
avec notre classe complexe;<a   href="surch.html#ope-plus"><img   alt="avant"
src="avant.gif" /></a> Le mieux est de d&eacute;finir une fonction amie,
en utilisant un prototype analogue au prototype ci-dessous:</p>

<pre class="demo">
class complexe {
...
  friend ostream &amp; operator&lt;&lt;(ostream&amp; os, const complexe&amp; c) {
    os &lt;&lt; &quot;Partie reelle = &quot; &lt;&lt; c.r &lt;&lt; &quot; Partie imaginaire = &quot; &lt;&lt; c.i;
    os &lt;&lt; endl;
  }
}

...

complexe A;
cout &lt;&lt; A &lt;&lt; "\n";
</pre>

<p>La derni&egrave;re op&eacute;ration de sortie &eacute;crit:</p>

<pre class="demo">
Partie reelle = 0 Partie imaginaire = 0
</pre>

<h3><a name="entree-surch">Surcharger l'op&eacute;rateur &gt;&gt;</a></h3>

<p>L'op&eacute;rateur <code><b>&gt;&gt;</b></code> peut lui
aussi &ecirc;tre surcharg&eacute;. Attention, il est bon de s'assurer que les
donn&eacute;es fournies par l'utilisateur correspondent bien &agrave; ce que l'on
attend, et dans le cas contraire il faut agir sur l'&eacute;tat du flot, afin
que le programme principal sache que quelque chose d'anormal est arriv&eacute;.<br />
Le programme ci-dessous montre l'op&eacute;rateur <code>&gt;&gt;</code>
ainsi que le programme principal qui va avec; on voit qu'on utilise
l'op&eacute;rateur <code>!</code> sur le flot <code>cin</code> afin de
d&eacute;tecter les erreurs, et de boucler le cas &eacute;ch&eacute;ant. Tout cela ne peut
fonctionner que parceque <code><b>&gt;&gt;</b></code> positionne
correctement les bits d'&eacute;tat lorsqu'il rencontre un probl&egrave;me.</p>

<pre class="demo">
class complexe {
...
  friend istream&amp; operator&gt;&gt;(istream&amp; is, complexe&amp; c) {
    char sep;
    float r,i;
    is.clear();                           // remise a 0 du status
    is &gt;&gt; r &gt;&gt; sep;
    if (sep == ',') {
      is &gt;&gt; i;
      c.r = r;
      c.i = i;
    } else {
      string dump;
      getline(is,dump);                   // pour jeter la fin de ligne
      is.clear(ios::badbit|is.rdstate()); // pb en lecture
    };
    return is;
  }
};

main() {
  complexe C1;
  do {
    cout &lt;&lt;&quot;Entrer reel,imag:&quot;;
  } while(!(cin &gt;&gt; C1));
  cout&lt;&lt; &quot;Voici le complexe = &quot; &lt;&lt; C1 &lt;&lt; endl;
};
</pre>


<h3><a name="ite-stream">Les it&eacute;rateurs de flots</a></h3>

<p>Une autre mani&egrave;re  d'utiliser les flots est de faire
"comme si"  il s'agissait d'un conteneur, et  d'utiliser un it&eacute;rateur,
ainsi qu'on peut le voir ci-dessous pour l'entr&eacute;e:</p>

<pre class="demo">
<b>istream_iterator&lt;int&gt; input (cin);
istream_iterator&lt;int&gt; end_of_input;</b>
while(input != end_of_input) {
    int i = *input;
    ...
    ++input;
}
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
La premi&egrave;re ligne associe un it&eacute;rateur de flot &agrave; un flot existant
(ici <code>cin</code>). La seconde ligne construit un it&eacute;rateur de flot sans l'associer
&agrave; quoique ce soit: il s'agit par convention d'un signal de fin de fichier.</p></div>

<p>Et pour la sortie:</p>

<pre class="demo">
ostream_iterator&lt;int&gt; output(cout);
while(...) {
    *output = ...;
    ++output;
}
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
La ligne <code>*output = ... </code> utilisera en fait l'op&eacute;rateur <code>&lt;&lt;</code>
de l'objet situ&eacute; &agrave; droite du signe <code>=</code>.</p></div>

<h3><a name="io-conten">Remplir un conteneur &agrave; partir d'un fichier</a></h3>

<p>Le code ci-dessous utilise la fonction <code>back_insert_iterator</code> afin de g&eacute;n&eacute;rer
&agrave; partir d'un conteneur, un type particulier d'it&eacute;rateurs: un it&eacute;rateur d'insertion. Celui-ci
sert &agrave; ins&eacute;rer les objets dans le conteneur par la fin. Associ&eacute; aux it&eacute;rateurs de flots,
on remplit le conteneur avec une ligne de code... mais surtout, le fait qu'on lit depuis un fichier est totalement masqu&eacute;:
changez les it&eacute;rateurs <code>i</code> et <code>i_end</code> par des it&eacute;rateurs d&eacute;finissant
un intervalle, par exemple, le code sera exactement le m&ecirc;me. El&eacute;gant, n'est-il pas ?</p>

<pre class="demo">
vector&lt;int&gt; V1;

ifstream data("file.data");
istream_iterator&lt;int&gt; i(data);
istream_iterator&lt;int&gt; i_end;
back_insert_iterator&lt;vector&lt;int&gt; &gt; bii1 = back_inserter(V1);

<b>copy(i,i_end, bii1);</b>
</pre>

<hr />
<address><a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>
<p>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>
</div></body> </html>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Surcharger fonctions et op&eacute;rateurs</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
 <dd id="smenu1" style="height:20em;overflow: scroll;">
	<ul>
		<li><a href="surch.html#existant">Modifier une fonction sans remettre en cause l'existant</a> 
		<ul>
			<li><a href="surch.html#decl-def">D&eacute;claration et d&eacute;finition de fonctions</a></li> 
			<li><a href="surch.html#surch-fonc">Surcharge de fonctions</a></li> 
			<li><a href="surch.html#surch-construc">Le constructeur de copie</a></li> 
			<li><a href="surch.html#valdef">Valeurs par d&eacute;faut des arguments</a></li> 
			<li><a href="surch.html#valdef-construc">Valeurs par d&eacute;faut et constructeurs</a></li> 
		</ul></li>
		<li><a href="surch.html#surch-op">Surcharger les op&eacute;rateurs</a> 
		<ul>
			<li><a href="surch.html#ope-fonc">Op&eacute;rateurs et fonctions</a></li> 
			<li><a href="surch.html#ope-plus">Les quatre op&eacute;rations</a></li> 
			<li><a href="surch.html#ope-incr">Les op&eacute;rateurs d'incr&eacute;mentation ou d&eacute;cr&eacute;mentation</a></li>
			<li><a href="surch.html#ope-affec">L'op&eacute;rateur d'affectation</a></li> 
			<li><a href="surch.html#conv-ope">Conversions et op&eacute;rateurs</a></li> 
			<li><a href="surch.html#autres-ope">Autres op&eacute;rateurs</a></li> 
		</ul></li>
	</ul> </dd>
</dl>
<dl>
 <dt><a href="exos.html#surcharge" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="contenu">
<h1><a name="surch-fonc-op">Surcharger fonctions et op&eacute;rateurs </a></h1>

<h2><a name="existant">Modifier une fonction sans remettre en cause l'existant </a></h2>

<p>Il est fr&eacute;quent,  dans un processus de d&eacute;veloppement,
de se trouver confront&eacute;s au probl&egrave;me suivant: Lors du codage de
la  version initiale  du programme,  nous avons  utilis&eacute;  une fonction
<code>f(X)</code>, o&ugrave; <code>X</code> est un entier. Or, justement dans
la seconde  version du programme,  nous sommes capables  de travailler
non plus seulement avec des entiers, mais aussi avec des complexes. Il
nous faudra donc une fonction <code>f(X)</code>, o&ugrave; <code>X</code> est
un   nombre    complexe.    <a   href="#surch-fonc"><img   alt="apres"
src="apres.gif" /></a>    Autre    situation    fr&eacute;quente:
l'algorithme de  <code>f</code> s'est un peu  compliqu&eacute;, et maintenant
nous avons  besoin de passer  &agrave; <code>f</code> un  second param&egrave;tre...
<a  href="#valdef"><img  alt="apres"  src="apres.gif" /></a>
Comment  allons-nous faire  ? Deux  solutions si  nous  travaillons en
C:</p>

<ul>
  <li>Changer le prototype de la fonction... mais cela veut
      probablement dire r&eacute;&eacute;crire en partie le code qui <em>utilise</em>  cette
      fonction <code>f</code>. Qui dit r&eacute;&eacute;criture du code dit risque
      d'ajout d'erreurs.</li>
  <li>Cr&eacute;er une nouvelle fonction <code>f_compl</code>, qui prendra un
      nombre complexe comme param&egrave;tre... faisable, mais illogique,
      sachant que <code>f</code> et <code>f_compl</code> font
      exactement la m&ecirc;me chose: si deux fonctions font la m&ecirc;me chose,
      on a envie de leur donner le m&ecirc;me nom. Programmes plus simples &agrave;
      lire, donc &agrave; comprendre, donc &agrave; ma&icirc;triser.</li>
</ul>

<h3><a name="decl-def">D&eacute;claration et d&eacute;finition de fonctions </a></h3>

<p>Une <em>fonction</em> comprend une ou deux parties distinctes:</p>


<ul>
  <li><em>La d&eacute;claration</em> (optionnelle): Le nom de la fonction, les  param&egrave;tres
      dont elle a besoin, et ce qu'elle renverra.</li>
  <li><em>La d&eacute;finition</em>: la d&eacute;claration (redite au besoin),
      suivie de ce que fait la fonction (le code).</li>
</ul>

<h4><a name="decl">D&eacute;claration</a></h4>

<p>Une <em>d&eacute;claration de fonction</em> comprend trois parties:</p>

<ul>
  <li>Le type de retour (&eacute;ventuellement <code>void</code> si elle ne
      renvoie rien)</li>
  <li>Le nom de la fonction</li>
  <li>La liste des arguments avec leur type (voir toutefois ci-dessous)</li>
</ul>

<p>Il est possible,  mais pas indispensable de sp&eacute;cifier
le nom des arguments:  ceux-ci sont consid&eacute;r&eacute;s par le compilateur comme
des variables muettes, et sont ignor&eacute;s. Leur type, par contre, est une
information  importante et ne  doit pas  &ecirc;tre omis...   sauf exception
signal&eacute;e ci-dessous. Voici un exemple de d&eacute;claration:</p>

<pre class="demo">
int f1 (int,int,int);
</pre>

<h4><a name="def">D&eacute;finition</a></h4>

<p>Une <em>d&eacute;finition de fonction</em> comprend deux parties:</p>

<ul>
  <li>La <em>d&eacute;claration</em> de la fonction,  <em>avec cette fois le nom des
      param&egrave;tres</em></li>
  <li>Le <em>corps de la fonction</em>, sous la forme d'un bloc</li>
</ul>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
La d&eacute;claration
de   fonction   est    optionnelle,   seule   est   indispensable   sa
d&eacute;finition.<br />  <img   alt="attention"  src="attention.gif" />  Si  une
fonction  est  d&eacute;clar&eacute;e   avant  d'&ecirc;tre  d&eacute;finie,  <em>d&eacute;claration  et
d&eacute;finition   doivent  &ecirc;tre  identiques</em>   (m&ecirc;mes  nom,   types  de
param&egrave;tres,   type de valeur    de   retour):   l'ensemble    de   ces   trois
caract&eacute;ristiques  constituant la  <em>signature</em>  de la  fonction.
</p></div>

<h3><a name="surch-fonc">Surcharge de fonctions</a></h3>

<p>En C++, il est  possible  de d&eacute;clarer  et d&eacute;finir  plusieurs
fonctions  ayant m&ecirc;me  nom, <em>&agrave;  condition que  les listes  de leurs
arguments diff&egrave;rent</em>:  cela r&eacute;sout en partie le  probl&egrave;me que nous
avons &eacute;voqu&eacute; plus haut, comme on le voit ci-dessous:</p>

<pre class="demo">
<b>float fonction (float x)</b> {                   
   float y = 3 * x + 2;
   return y;
}

<b>complexe fonction (const complexe &amp; x)</b> {
   complexe y(0,0);
   y.set_r (3*x.get_r() + 2);
   y.set_i (3*y.get_i());
   return y;
}
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
 Il n'est  <em>pas possible</em> de surcharger une
fonction  par une autre  fonction qui  aurait m&ecirc;me  nom et  m&ecirc;me liste
d'arguments   <em>mais   une   valeur   de   retour   diff&eacute;rente</em>.
 </p> </div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
<em>Rien</em> ne garantit que les deux versions de
la  fonction  <code>f</code>  ci-dessus  font  la  m&ecirc;me  chose:  c'est au programmeur de s'en assurer,
afin que le code reste compr&eacute;hensible.</p> </div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Ce m&eacute;canisme  est extr&ecirc;mement puissant, en ce sens
qu'il va nous  permettre de donner un m&ecirc;me  nom &agrave; plusieurs fonctions,
travaillant  sur   des  param&egrave;tres   de  types  diff&eacute;rents. 
Mais comme souvent, ce
qui donne de  la simplicit&eacute; &agrave; l'homme est  source de complication pour
la machine...  il n'est  pas toujours &eacute;vident  pour le  compilateur de
d&eacute;cider quelle  version de la fonction  sera utilis&eacute;e. Il peut m&ecirc;me y
avoir parfois ambigu&iuml;t&eacute;. D'o&ugrave; l'existence de r&egrave;gles de surcharge, qui ne seront pas 
explicit&eacute;es ici.
</p></div>

<h3><a name="surch-construc">Surcharge et constructeurs: le
constructeur de copie</a></h3>

<p>Un  constructeur <a   href="types.html#construct"><img   alt="avant"
src="avant.gif" /></a> est   une  fonction
"presque" comme une  autre... donc, il n'y a pas  de raison pour qu'on
ne   puisse  pas   la  surcharger.    La surcharge du constructeur
permet de fournir plusieurs possibilit&eacute;s d'initialisation, &agrave; partir de
plusieurs types d'objets. </p>

<p>Un  de   ces  constructeurs  est  particuli&egrave;rement
important: il s'agit  du constructeur de copie, qui  va nous permettre
d'initialiser  un objet  &agrave;  partir  d'un autre  objet  <em>de la  m&ecirc;me
classe</em>.</p>

<pre class="demo">
class complexe {
public:
   <b>complexe(float x,float y)</b> : r(x), i(y) {};
   <b>complexe(const complexe&amp; c)</b> : r(c.r),i(c.i) {
       cout &lt;&lt; "ici constructeur de copie de complexe" &lt;&lt; endl};
private:
   float r;
   float i;
   ...
}

main() {
   const complexe j(0,1);
   complexe A=j;
}
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
 Attention au  prototype du constructeur de copie.
En particulier, le passage  <em>par r&eacute;f&eacute;rence</em> est indispensable: si l'on essaie de passer l'objet <em>par valeur</em>, on demande au compilateur de
faire  une copie  de  l'objet afin  de  la passer  au constructeur  de
copie. Comme le C++ est un langage r&eacute;cursif, le constructeur de copie va s'appeler lui-m&ecirc;me jusqu'&agrave; &eacute;puisement de la m&eacute;moire.</p></div>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
 De m&ecirc;me que
le  langage offre  un constructeur  par d&eacute;faut,  de m&ecirc;me  il  offre un
constructeur de  copie par d&eacute;faut.  Celui-ci fait  tout simplement une
copie  membre  &agrave;  membre.   Lorsque  le constructeur  par  d&eacute;faut  est
suffisant, <em>utilisez  celui-ci</em>.  Mais lorsque  le constructeur
doit aussi  faire autre chose  (comme dans l'exemple  ci-dessus), vous
devez fournir un constructeur de copie.</p></div>

<p><a href="#">top</a></p><hr />

<h3><a name="valdef">Valeurs par d&eacute;faut des arguments</a></h3>

<p >Dans  une d&eacute;finition de fonction, il  est possible de
sp&eacute;cifier  des valeurs  par d&eacute;faut  &agrave;  chaque argument.  Il s'agit  l&agrave;
encore d'un moyen tr&egrave;s puissant  pour modifier une fonction sans tout
remettre en cause; Soit par exemple le code suivant:</p>


<pre class="demo">
<b>float mult (float x)</b> {
    return 2 * x;
};

main() {
   ...
   int y = f (4.5);
};
</pre>

<p  >Supposons  qu'on d&eacute;sire modifier la fonction <code>mult</code> afin qu'elle soit capable de multiplier son argument par n'importe quel nombre entier, et pas seulement 2. L'ancienne version correspondrait toujours &agrave; une multiplication par deux. Nous donnons donc 2 comme valeur par d&eacute;faut au second param&egrave;tre, ce qui s'&eacute;crit: <code>float mult (float x, int m=2);</code>. 
A partir de l&agrave;, seront accept&eacute;s:</p>

<ul>
  <li>Les appels "&agrave; l'ancienne mode" type <code>mult&nbsp;(x)</code></li>
  <li>Les appels "&agrave; la nouvelle mode" type <code>mult&nbsp;(x,3)</code></li>
</ul>

<p>Voil&agrave; ce que cela donne dans notre exemple:</p>

<pre class="demo">
<b>float mult (float x, int m=2)</b> {
    return  m * x;
};

main() {
   ...
   int y = f(4.5);         // meme resultat que ci-dessus
   int z = f(4.5,3);       // cela etait impossible avec la version precedente
};
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> Les
arguments   ayant    des   valeurs   par    d&eacute;faut   <em>se   trouvent
obligatoirement</em> en  fin de liste: sinon,  le compilateur n'aurait
aucun moyen de savoir de quels arguments vous parlez (il n'y a pas, en
C++, de possibilit&eacute; de fournir  des arguments nomm&eacute;s, comme en perl ou
en fortran 90).</p> </div>

<h3><a name="valdef-construc">Valeurs par d&eacute;faut et constructeurs</a></h3>

<p>Nous      avons      eu     pr&eacute;c&eacute;demment      <a
href="types.html#construct-predef"><img   alt="avant"  src="avant.gif" /></a>
quelques ennuis  avec  le constructeur  de la  classe
<code>complexe</code>, tel qu'il &eacute;tait d&eacute;fini alors. La solution &agrave; nos
probl&egrave;mes  est toute  simple:  il suffit  d'utiliser  des valeurs  par
d&eacute;faut pour les param&egrave;tres pass&eacute;s au constructeur. Voici le code:</p>

<pre class="demo">
class complexe {
private:
  ...
public:
  <b>complexe(float x=0, float y=0)</b> {r=x;   i=y; _calc_module();};
  ...
};

main() {
  complexe C;        // sous-entendu initialiser a 0
  complexe C1(2);    // sous-entendu initialiser a (2,0) [reel]
  complexe C2(2,2);
}
</pre>

<h3><a name="facil">Une facilit&eacute; d'&eacute;criture</a></h3>

<p>Le code ci-dessus permet d'&eacute;crire:</p>

<pre class="demo">
main() {
   <b>complexe A(5);
   complexe B=5;
   complexe C;</b>
};
</pre>

<p>Les deux premi&egrave;res lignes ont exactement la m&ecirc;me signification,
simplement  <code>C=5</code> est plus  parlant.Tout le  monde comprend
que l'initialisation d'un complexe par  un r&eacute;el donne un complexe avec
une partie imaginaire nulle. D'autre part, la troisi&egrave;me ligne conduit &agrave; l'initialisation &agrave; 0 
d'un nombre complexe.</p>

<h4>Le mot-cl&eacute; explicit</h4>

<p >La facilit&eacute; d'un  jour devient handicap le lendemain:
en     effet,    revenons     sur    la     classe    tableau     (    <a
href="types.html#const"><img        alt="avant"        src="avant.gif" /></a>);
Puisque  le  constructeur  ne comporte  qu'un  seul
param&egrave;tre, nous pouvons &eacute;crire le code suivant:</p>

<pre class="demo">
main() {
   tableau B = 1024;
}
</pre>

<p >L&agrave;,  il n'est pas  du tout &eacute;vident, lorsqu'on  lit le
code   ci-dessus,   que   cela   signifie  "allouer   un   buffer   de
<em>taille</em> 1024 octets"...  Le
concepteur de  <code>tableau</code> devrait donc  inhiber cette &eacute;criture,
qui  se  r&eacute;v&egrave;le inad&eacute;quate.  Cela  se  fait  en utilisant  le  mot-cl&eacute;
<code>explicit</code> devant la d&eacute;finition du constructeur:</p>

<pre class="demo">
class tableau {
  ...
public:
  explicit tableau(int);
};
</pre>

<p>Maintenant, le  code <code>tableau  B  = 1024;</code>
provoquera   une  erreur   de  compilation,   tandis   que  <code>tableau
B(1024)</code> passera correctement.   Cette derni&egrave;re syntaxe est plus
claire que  la pr&eacute;c&eacute;dente, dans la  mesure o&ugrave; l'on comprend  qu'il y a
appel  de fonction  avec passage  de param&egrave;tres. On sait alors qu'il faut consulter
la documentation afin de savoir pr&eacute;cis&eacute;ment ce que fait cette fonction.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Les constructeurs jouent &eacute;galement le r&ocirc;le de convertisseurs de types <a href="#conv-ope">
<img      alt="apres"      src="apres.gif" /></a>: cela peut dans certains cas provoquer des probl&egrave;mes
 &agrave; la compilation, car le compilateur "se trompe" dans la conversion. Dans ce cas, le mot-cl&eacute; 
 <code>explicit</code> est indispensable pour inhiber la conversion ind&eacute;sirable.</p></div>

<p><a href="#">top</a></p><hr />

<h2><a name="surch-op">Surcharger les op&eacute;rateurs</a></h2>

<p>Lorsque nous &eacute;crivons le code suivant, en C:</p>

<pre class="demo">
int A=2;
int B=3;
int C;
double A1=2.1;
double B1=3.1,
double C1;
main() {
   C = A + B;
   C1= A1+B1;
}
</pre>

<p >Nous  utilisons la surcharge des  op&eacute;rateurs "sans le
savoir",  tel   M.Jourdain  faisant  de   la  prose.   En   effet,  du
point-de-vue  des  instructions  en  langage  machine,  l'op&eacute;rateur
<code>+</code> ne produira  pas le m&ecirc;me code dans  la premi&egrave;re et dans
la  seconde ligne.   Dans  le premier  cas,  on fait  une addition  en
arithm&eacute;tique  enti&egrave;re,  dans  le  second  cas on  fait  l'addition  en
arithm&eacute;tique  flottante.    <br />  Le  C++  permettra   de  donner  une
signification  &agrave;  l'op&eacute;rateur  <code>+</code>  (ainsi  qu'&agrave;  tous  les
op&eacute;rateurs du langage) sp&eacute;cifique pour <em>chaque classe d&eacute;finie</em>.</p>

<h3><a name="ope-fonc">Op&eacute;rateurs et fonctions</a></h3>

<p>L'expression: <code>C&nbsp;=&nbsp;A&nbsp;+&nbsp;B</code> peut &ecirc;tre vue
comme une mani&egrave;re diff&eacute;rente d'&eacute;crire  un appel de fonction. En effet,
on pourrait aussi &eacute;crire: <code>C&nbsp;=&nbsp;add(A,B)</code> Le r&eacute;sultat serait
le  m&ecirc;me que  l'expression  ci-dessus, mais  le  code nettement  moins
lisible. Le C++ respecte  tout simplement la
convention   suivante:    lorsqu'il   rencontre   une   instruction
<code>C&nbsp;=&nbsp;A&nbsp;+&nbsp;B</code>,  il ex&eacute;cute  en r&eacute;alit&eacute;
l'instruction     <code>C&nbsp;=&nbsp;operator+(A,C)</code>.</p>

<p>La fonction  <code>operator+</code>  doit accepter
deux param&egrave;tres de type  <code>complexe</code> en entr&eacute;e, et elle doit renvoyer &eacute;galement un complexe, d'o&ugrave; le prototype suivant:</p>

<pre class="demo">
complexe operator+(const complexe&amp;, const complexe&amp;);
</pre>

<p>L'addition de trois complexes peut s'&eacute;crire <code>D&nbsp;=&nbsp;A&nbsp;+&nbsp;B&nbsp;+&nbsp;C</code>
soit (l'op&eacute;rateur  + &eacute;tant associatif  &agrave; droite):
<code>D&nbsp;=&nbsp;A&nbsp;+&nbsp;(B&nbsp;+&nbsp;C)</code>,  ou  encore   <code>D&nbsp;=&nbsp;A&nbsp;+&nbsp;operator+(B,C)</code>
soit <code>D&nbsp;=&nbsp;operator+(A,operator+(B,C))</code> 
Il  va sans dire  que la premi&egrave;re  &eacute;criture est
bien  plus compr&eacute;hensible  que la  derni&egrave;re,  cependant il  est bon  de
l'avoir  pr&eacute;sente  &agrave; l'esprit,  en  particulier  lorsqu'on d&eacute;finit  le
prototype de la fonction.</p>

<p >La forme  utilisant un appel de fonction  et la forme
utilisant  les op&eacute;rateurs  <em>sont &eacute;quivalentes</em>.  Simplement, la
surcharge des op&eacute;rateurs va permettre &agrave; l'utilisateur de nos objets
d'&eacute;crire un programme plus &eacute;l&eacute;gant.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Il  ne s'agit  pas de <em>cr&eacute;er</em>  de nouveaux
op&eacute;rateurs,  il  s'agit  bien  de <em>surcharger</em>  les  op&eacute;rateurs
existants.   Ni  plus,   ni   moins.  Les   r&egrave;gles   de  priorit&eacute;   et
d'associativit&eacute; d&eacute;finies  pour les op&eacute;rateurs  du langage s'appliquent
&eacute;galement aux op&eacute;rateurs surcharg&eacute;s.</p></div>

<h4><a name="ope-surch">Op&eacute;rateurs: le bestiaire</a></h4>

<p>Les  tables ci-dessous  indiquent:</p>

<ul>
  <li>La liste (<i>non exhaustive</i>) des op&eacute;rateurs, leurs significations, et la possibilit&eacute; ou non de surcharge</li>
  <li>Les priorit&eacute;s et associativit&eacute;s des principaux op&eacute;rateurs</li>
</ul>

<table class="tableau">
  <caption>Principaux op&eacute;rateurs du C++</caption>
  <tr>
  <th> Op&eacute;rateurs</th>
  <th> signification </th>
  <th> Surcharge </th>
  <th> Int&eacute;r&ecirc;t de la surcharge </th>
</tr>
  <tr>
    <td> :: </td>
    <td> R&eacute;solution de port&eacute;e</td>
    <td> NON </td>
	<td>&nbsp;</td>
  </tr>
  <tr>
    <td> . </td>
    <td> S&eacute;lection de membre</td>
    <td> NON </td>
	<td>&nbsp;</td>
  </tr>
  <tr>
    <td> += <br />-= <br /> *= <br /> /= <br /> %= </td>
    <td> Op&eacute;rateurs unaires arithm&eacute;tiques.</td>
	<td>OUI</td>
	<td>Op&eacute;rations arithm&eacute;tiques unaires et performantes</td>
  </tr>
  <tr>
    <td> + <br />- <br /> * <br /> / <br /> % </td>
    <td> Op&eacute;rateurs binaires arithm&eacute;tiques.</td>
	<td>OUI</td>
	<td>Op&eacute;rations arithm&eacute;tiques binaires</td>
  </tr>
  <tr>
    <td> ++ <br />-- </td>
    <td> Incr&eacute;mentation, d&eacute;cr&eacute;mentation</td>
	<td>OUI</td>
	<td>It&eacute;rateurs</td>
  </tr>
  <tr>
    <td> =</td>
    <td> Op&eacute;rateur d'&eacute;galit&eacute;.</td>
	<td>OUI</td>
	<td>Cl&ocirc;nage entre deux objets.</td>
  </tr>
  <tr>
    <td> &gt;&gt;<br />&lt;&lt;</td>
    <td> D&eacute;calage &agrave; gauche ou &agrave; droite</td>
	<td>OUI</td>
	<td>entr&eacute;e<br />sortie.</td>
  </tr>
  <tr>
    <td> []</td>
    <td> Acc&egrave;s aux membres d'un tableau</td>
	<td>OUI</td>
	<td>Indi&ccedil;age g&eacute;n&eacute;ralis&eacute;</td>
  </tr>
  <tr>
    <td> ()</td>
    <td> Appel de fonction</td>
	<td>OUI</td>
	<td>Objets-fonctions </td>
  </tr>
  <tr>
     <td> !  </td>
    <td> Op&eacute;ration logique </td>
	<td>OUI</td>
	<td>Permet de comparer un objet &agrave; true/false</td>
  </tr>
  <tr>
    <td> ==<br />!=</td>
    <td> Egalit&eacute;, non &eacute;galit&eacute;</td>
	<td>OUI</td>
	<td>Egalit&eacute;, non &eacute;galit&eacute; entre deux objets</td>
  </tr>
  <tr>
    <td> &gt;<br />&lt;<br />&gt;=<br />&lt;=</td>
    <td> In&eacute;galit&eacute;s</td>
	<td>OUI</td>
	<td>In&eacute;galit&eacute;s </td>
  </tr>
  <tr>
    <td> -&gt; <br />-&gt;* <br /> .* </td>
    <td> S&eacute;lection de membre depuis un ou vers un pointeur.</td>
	<td>OUI</td>
	<td>Contr&ocirc;le de l'acc&egrave;s aux membres</td>
  </tr>
  <tr>
    <td>&amp; <br />* </td>
    <td> Pointeur, r&eacute;f&eacute;rence.</td>
	<td>OUI</td>
	<td>Objets &agrave; comptage de r&eacute;f&eacute;rence, it&eacute;rateurs</td>
  </tr>
  <tr>
    <td> int<br />long<br />short<br />float<br />double<br />etc. </td>
    <td> Conversion de types </td>
    <td> OUI</td>
	<td> Conversion vers un type pr&eacute;d&eacute;fini depuis un objet</td>
  </tr>
</table>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> Vous
pouvez mettre <em>n'importe quoi</em>  dans le code. Rien (sinon votre
bon  sens)  ne  vous  emp&ecirc;che  de mettre  une  multiplication  dans  un
op&eacute;rateur  <code>+</code>. Autrement  dit,  c'est un  jeu d'enfant  de
faire dire  &agrave; un programme C++:  <code>16&nbsp;=&nbsp;4&nbsp;+&nbsp;4</code>... Mais bien
s&ucirc;r ce n'est pas fait pour cela  ! Au contraire, le seul int&eacute;r&ecirc;t de la
surcharge  des op&eacute;rateurs  est  que les  <em>utilisateurs</em> de  vos
objets  pourront  &eacute;crire  des  programmes  plus  clairs.  Utilisez  la derni&egrave;re 
colonne du tableau ci-dessus afin de surcharger vos op&eacute;rateurs &agrave; bon essient.</p>
</div>

<table class="tableau">
  <caption>Priorit&eacute; et associativit&eacute; des op&eacute;rateurs</caption>
  <tr><th colspan="11"> Op&eacute;rateurs (par priorit&eacute; descendante)</th><th> Associativit&eacute;</th></tr>
  <tr>
    <td> () </td>
    <td> [] </td>
    <td> -&gt; </td>
    <td> . </td>
    <td colspan="7">&nbsp;</td>
    <td>--&gt;</td>
  </tr>
  
  <tr>
    <td> !</td>
    <td> ~</td>
    <td> ++</td>
    <td> --</td>
    <td> +</td>
    <td>-</td>
    <td> *</td>
    <td> &amp;</td>
    <td> (int)</td>
    <td> sizeof</td>
    <td> &nbsp;</td>
    <td>&lt;--</td>
  </tr>

  <tr>
    <td> *</td>
    <td> /</td>
    <td> %</td>
    <td colspan="8">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>

  <tr>
    <td> +</td>
    <td> -</td>
    <td colspan="9">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>
 
  <tr>
    <td> &lt;&lt;</td>
    <td> &gt;&gt;</td>
    <td colspan="9">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>

  <tr>
    <td> &lt;</td>
    <td> &lt;=</td>
    <td> &gt;</td>
    <td> &gt;=</td>
    <td colspan="7">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>
 
  <tr>
    <td> ==</td>
    <td> !=</td>
    <td colspan="9">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>
 
  <tr>
    <td> &amp;</td>
    <td colspan="10">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>
 
  <tr>
    <td> ^</td>
    <td colspan="10">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>
 
  <tr>
    <td> |</td>
    <td colspan="10">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>
 
  <tr>
    <td> &amp;&amp;</td>
    <td colspan="10">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>
 
  <tr>
    <td> ||</td>
    <td colspan="10">&nbsp;  </td>
    <td>--&gt;</td>
  </tr>
 
  <tr>
    <td> ?:</td>
    <td colspan="10">&nbsp;  </td>
    <td>&lt;--</td>
  </tr>
 
  <tr>
    <td> =</td>
    <td> +=</td>
    <td> -=</td>
    <td> *=</td>
    <td> /=</td>
    <td> %=</td>
    <td> &amp;=</td>
    <td> ^=</td>
    <td> |=</td>
    <td> &lt;&lt;=</td>
    <td> &gt;&gt;=</td>
    <td>&lt;--</td>
  </tr>

  <tr>
    <td> ,</td>
    <td colspan="10">&nbsp;</td>
    <td>--&gt;</td>
  </tr>
</table>

<h4><a name="ope-ami">Fonction membre ou fonction ordinaire ?</a></h4>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
Faut-il    sp&eacute;cifier    un    op&eacute;rateur    comme    une
fonction-membre ou comme  une fonction ordinaire (&eacute;ventuellement amie) ? La r&egrave;gle g&eacute;n&eacute;rale est la suivante:
</p>

<ul>
  <li>Op&eacute;rateur unaire (ex: <code>++</code>). Fonction membre</li>
  <li>Op&eacute;rateur binaire (ex: <code>+</code>). Fonction ordinaire</li>
</ul>

<p>En effet,  un  op&eacute;rateur unaire  modifie par  nature
l'objet   sur   lequel    il   op&egrave;re   (<code>a   +=3</code>   modifie
<code>a</code>).  Il est donc coh&eacute;rent d'en faire une fonction-membre.
Un op&eacute;rateur binaire, par  contre, op&egrave;re sur <em>deux</em> objets.  En
faire   une  fonction-membre  revient   &agrave;  "privil&eacute;gier"   de  mani&egrave;re
arbitraire l'un des  deux objets.  Au mieux c'est  incoh&eacute;rent, au pire
cela ne fonctionnera pas.</p></div>

<h3><a name="ope-plus">Les quatre op&eacute;rations</a></h3>

 <p >Le  code suivant montre  une  impl&eacute;mentation
de l'op&eacute;rateur  <code>+=</code>  sur  la  classe
<code>complexe</code>.   <code>+=</code> est impl&eacute;ment&eacute; en tant que fonction membre:</p>

<pre class="demo">
class complexe {
private:
  ...
public:
  ...
  <b>complexe&amp; operator+= (const complexe&amp;)</b>;
};

<b>complexe&amp; complexe::operator+=(const complexe&amp; c) {
  r += c.r;
  i += c.i;
  return *this;
};</b>
</pre>

<p >Le code suivant montre l'impl&eacute;mentation de l'op&eacute;rateur <code>+</code>, qui est simplement une fonction 
ordinaire, prenant deux complexes comme param&egrave;tres, et renvoyant un autre complexe:</p>

<pre class="demo">
complexe operator+(const complexe& a, const complexe& b) {
  complexe r=a;
  <b>r += b;</b>
  return r;
};
</pre>

<p >Nous avons d&eacute;fini <em>deux op&eacute;rateurs</em> (<code>+</code> et  <code>+=</code>),  mais seul  l'un  d'entre eux  (<code>+=</code>)
acc&egrave;de  aux donn&eacute;es  priv&eacute;es.   Cela signifie  que  si nous  modifions
l'impl&eacute;mentation  de <code>complexe</code>  (hypoth&egrave;se  r&eacute;aliste, nous
avons    d&eacute;j&agrave;     vu    trois    impl&eacute;mentations     diff&eacute;rentes)  nous   n'aurons  <em>qu'un  seul</em>   op&eacute;rateur  &agrave;
modifier: moins de travail, surtout moins de risque d'erreur.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Attention aux types  de retour des op&eacute;rateurs: en
effet,  <code>operator+=</code>  renvoie  un <code>complexe&</code>,
tandis    que    <code>operator+</code>    renvoie    simplement    un
<code>complexe</code>.   Pourquoi  ?  Il  est  toujours pr&eacute;f&eacute;rable  de
renvoyer  une r&eacute;f&eacute;rence  plut&ocirc;t  qu'un objet,  pour  des questions  de performances:  en  effet, renvoyer  un  objet  signifie effectuer  une copie,  op&eacute;ration &eacute;ventuellement  longue pour  des  objets volumineux, alors que  renvoyer une r&eacute;f&eacute;rence signifie  renvoyer simplement... une adresse.   Op&eacute;ration tr&egrave;s  rapide,  et ind&eacute;pendante  de  la taille  de l'objet.    C'est  ainsi   que  <code>operator+=</code>   renvoie  une r&eacute;f&eacute;rence.     Par   contre,    <code>operator+</code>    renvoie   un <code>complexe</code>. Ce  serait en effet  une erreur dans ce  cas de renvoyer une  r&eacute;f&eacute;rence, car celle-ci pointerait  sur une <em>variable
locale</em>     <a     href="types.html#ref-boum"><img     alt="avant"
src="avant.gif" /></a>. Cela a d'ailleurs une cons&eacute;quence dans le code que nous &eacute;crirons lors de l'utilisation de ces op&eacute;rateurs: ainsi il sera plus performant d'&eacute;crire <code>a&nbsp;+=&nbsp;b</code> que d'&eacute;crire <code> a&nbsp;=&nbsp;a&nbsp;+&nbsp;b </code>, bien que les deux &eacute;critures soient autoris&eacute;es et signifient la m&ecirc;me chose. C'est vrai d&egrave;s que <code>a</code> et <code>b</code> sont des objets.</p></div>

<h3><a name="ope-incr">Les op&eacute;rateurs d'incr&eacute;mentation ou d&eacute;cr&eacute;mentation</a></h3>

<p>Les op&eacute;rateurs <code>++</code>  et <code>--</code>
peuvent bien s&ucirc;r &ecirc;tre surcharg&eacute;s,  cependant un probl&egrave;me se pose: en C
comme  en C++,  les  versions pr&eacute;d&eacute;finies  de  ces op&eacute;rateurs  peuvent
&ecirc;tre:</p>

<ul>
  <li>soit pr&eacute;fix&eacute;es</li>
  <li>soit postfix&eacute;es</li>
</ul>

<p>L'op&eacute;ration est la m&ecirc;me, simplement la valeur de retour sera
diff&eacute;rente:</p>

<ul>
  <li>dans le cas <code>++i</code>, on incr&eacute;mente, <em>puis</em>
      on &eacute;value le r&eacute;sultat et on le renvoie</li>
  <li>dans le cas <code>i++</code>, on &eacute;value la variable, on
      incr&eacute;mente, mais on renvoie la variable <em>avant incr&eacute;mentation</em></li>
</ul>

<p>Il est possible  (et m&ecirc;me recommand&eacute;) d'utiliser la
m&ecirc;me distinction avec des op&eacute;rateurs surcharg&eacute;s. La convention adopt&eacute;e
par  le  langage  est   d'effectuer  deux  d&eacute;clarations  de  fonctions
diff&eacute;rentes:</p>

<ul>
  <li><code>operator++()</code> pour la version <em>pr&eacute;fix&eacute;e</em></li>
  <li><code>operator++(int)</code> pour la version <em>postfix&eacute;e</em></li>
</ul>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
 Dans le cas de l'op&eacute;rateur postfix&eacute;, on doit:</p>

<ul>
  <li>faire une copie locale de l'objet</li>
  <li>renvoyer la copie de l'objet, donc impossible de renvoyer une
      r&eacute;f&eacute;rence.</li>
</ul>

<p>d'o&ugrave; surco&ucirc;t (qui  peut ne pas &ecirc;tre n&eacute;gligeable,  suivant la taille de
l'objet).  Moralit&eacute;: utilisez  <em>toujours</em> la  version pr&eacute;fix&eacute;e,
sauf n&eacute;cessit&eacute; absolue.</p></div>

<p>Les op&eacute;rateurs <code>++</code> et <code>--</code> servent &agrave; d&eacute;finir des it&eacute;rateurs  <a
href="stdlib.html#iterateurs"><img    alt="apr&egrave;s"   src="apres.gif" /></a>.</p> 

<h3><a name="ope-affec">L'op&eacute;rateur d'affectation</a></h3>

<h4><a name="affec-init">Affectation n'est pas initialisation</a></h4>

<p>En d&eacute;pit  des apparences, les deux  lignes de code  ci-dessous ne sont
pas &eacute;quivalentes.</p>

<pre class="demo">
int A=4;
A=5;
</pre>

<p  >En  effet,  la   premi&egrave;re  ligne  correspond  &agrave;  une
d&eacute;claration de variable avec <em>initialisation</em>, alors  que la seconde ligne  correspond &agrave; une
<em>affectation</em>.     L'initialisation    est   une    affectation
<em>pr&eacute;c&eacute;d&eacute;e  d'une  allocation  de  m&eacute;moire</em>.   Dans  le  cas  de
l'initialisation,  la  fonction  appel&eacute;e  est le  <em>constructeur  de
copie</em>,   dans   le   cas    de   l'affectation   il   s'agit   de
l'<code>operator=</code>.   Afin  d'&eacute;viter  de  r&eacute;&eacute;crire du  code,  la
mani&egrave;re habituelle de  proc&eacute;der est de d&eacute;finir une  fonction priv&eacute;e de
copie, fonction  qui sera appel&eacute;e par le  constructeur <em>et</em> par
l'op&eacute;rateur  d'affectation.  Cela  pourrait donner  par  exemple, pour
notre objet <code>tableau</code>:</p>

<pre class="demo">
class tableau {
public:
  explicit tableau(int);
  tableau(const tableau&amp;);
  tableau&amp; operator=(const tableau&amp;);
  ~tableau() {delete buffer;};
  
private:
  int taille;
  char* buffer;
  <b>void copie(const tableau&amp;);</b>

};

void tableau::copie(const tableau&amp; b) {
  ... copier le buffer de b ...
};

tableau::tableau(int t) {
  buffer = new char[t];
};

tableau::tableau(const tableau b&amp;) {
  buffer = new char[b.taille];
  copie(b);
};
  
tableau&amp; tableau::operator=(const tableau&amp;) {
  delete buffer;
  taille = b.taille;
  buffer = new char(taille);
  copie(b);
  return *this;
};

void main() {
  tableau B(1024);
  tableau A(1024);
  A=B;
  
};
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />A la vue du code ci-dessus,
on pourrait &ecirc;tre tent&eacute; d'&eacute;crire pour l'op&eacute;rateur d'affectation:</p>

<pre class="demo">
  tableau&amp; tableau::operator=(const tableau&amp; b) {
  delete *this;
  this = new tableau(b);
  return *this;
};
</pre>

<p>Je  d&eacute;truis  l'objet   puis  je  le  reconstruis  en
utilisant le  constructeur de  copie...  et ce  faisant, je  scie tout
simplement la branche sur laquelle je suis assis !!! A &eacute;viter...</p></div>

<h5><a name="auto-ref">Auto r&eacute;f&eacute;rences</a></h5>

<p  >Il est  important  de pr&eacute;voir,  dans les  op&eacute;rateurs
d'affectation, le  cas <em>a priori</em>  stupide o&ugrave; une  variable est
affect&eacute;e &agrave; elle-m&ecirc;me: cela est  un cas de figure tout-&agrave;-fait possible,
par    le    jeu   des    pointeurs    et    des   r&eacute;f&eacute;rences.     Or,
<code>operator=</code>  risque  alors  de  provoquer un  plantage:  en
effet,    lors   d'une   autor&eacute;f&eacute;rence,    l'expression   <code>delete
buffer</code> supprimera aussi bien le  buffer de l'objet cible que le
buffer  de  l'objet  source...   de  sorte qu'on  en  vient  &agrave;  copier
n'importe quoi  dans la  fonction <code>copie</code>. Le  code correct
pour <code>operator=</code> sera donc:</p>

<pre class="demo">
tableau&amp; tableau::operator=(const tableau&amp; b) {
  if (this != &amp;b) {
     delete buffer;
     buffer = new char(b.taille);
     copie(b);
  };
  return *this;
};
</pre>

<h4><a name="affect-trio">Le trio infernal</a></h4>

<p>Le trio infernal est constitu&eacute; par les trois fonctions suivantes:</p>

<ul>
  <li>Constructeur de copie</li>
  <li>Op&eacute;rateur d'affectation</li>
  <li>Destructeur</li>
</ul>

<p>Si  l'une de ces trois fonctions  est inexistante, le
compilateur  en produira  une  version  par d&eacute;faut.   Dans  le cas  du
constructeur  de copie  ou  de l'affectation,  la  version par  d&eacute;faut
consiste en une  simple copie membre &agrave; membre.  De  sorte que de nombreuses classes 
se contentent de la version fournie par d&eacute;faut.</p>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
 <em>Si  vous fournissez  l'une de ces  trois fonctions,
fournissez  les  trois</em>.  Sinon,  gros  risques  de plantages,  le
compilateur se chargeant de fournir ses  versions "&agrave; lui" de la ou des
fonctions manquantes...</p></div>

<h4><a name="trio-cage">La mise en cage du trio infernal</a></h4>

<p>Lorsque l'on  &eacute;crit un  objet, on  peut parfaitement
<em>emp&ecirc;cher</em> les  utilisateurs de l'objet  en question d'utiliser
copie et  constructeur de copie: pour  cela, il suffit  de les d&eacute;finir
<em>dans  la  section  private</em>.   Ainsi,  seul  l'objet  lui-m&ecirc;me
(c'est-&agrave;-dire  <em>vous</em>,  le  concepteur)  sera  capable  de  les
utiliser.  Vous interdisez  aux <em>utilisateurs</em> de l'objet toute
copie de  celui-ci.  Dans ce  cas, constructeur de copie  et op&eacute;rateur
d'affectation peuvent d'ailleurs &ecirc;tre des fonctions vides...</p>

<pre class="demo">
class unique {
private:
   unique(const unique&amp;) {};
   unique&amp; operator=(const unique&amp;) {};
   ...
</pre>

<p>Nous verrons  lors du  chapitre sur l'h&eacute;ritage  une mise en cage  un peu
moins         brutale         de         l'op&eacute;rateur&nbsp;=         <a
href="heritage.html#prot-affect"><img    alt="apr&egrave;s"   src="apres.gif" /></a>.</p>

<p><a href="#">top</a></p><hr />

<h3><a name="conv-ope">Conversions et op&eacute;rateurs</a></h3>

<h4>Conversions vers une classe</h4>
<p >Nous  avons d&eacute;fini un  op&eacute;rateur <code>+</code>, mais
celui-ci ne  nous permet  que d'ajouter deux  complexes entre  eux. Et
pourtant, le code suivant est valide:</p>

<pre class="demo">
complexe A(1,1);
float B=1;
complexe C;
C = A + B;
C = B + A;
</pre>

<p>En  fait, dans un cas comme  celui-ci, le compilateur
cherche  &agrave; effectuer  des conversions  de types.   Puisque  nous avons
d&eacute;fini   des   valeurs   par    d&eacute;faut   pour  les param&egrave;tres du constructeur   <a
href="#valdef-construc"><img        alt="avant"        src="avant.gif" /></a>, 
le compilateur sait g&eacute;n&eacute;rer un complexe &agrave; partir d'un
flottant. Il  sait donc  faire une conversion  de types  flottant vers
complexe. Toutes  les conversions de  types seront donc trait&eacute;es &agrave;
 l'aide de constructeurs surcharg&eacute;s.</p>

<h4>Conversions depuis une classe</h4>

<p  >   Cependant,  comment  allons-nous   effectuer  une
conversion  de type  <em>depuis</em>  la classe  <code>complexe</code>
<em>vers</em> un type de base  du langage ?  La technique ci-dessus ne
le  permet  pas,  car  le  compilateur  ne  peut  deviner  <em>ce  que
signifierait</em>  une telle  conversion. Nous  allons  alors d&eacute;finir,
puis utiliser,  un <em>op&eacute;rateur de  conversion</em>. Dans le  cas des
nombres  complexes,  par  exemple,  nous pourrions  consid&eacute;rer  qu'une
conversion d'un complexe  vers un flottant consiste &agrave;  prendre la partie
r&eacute;elle du complexe. D'o&ugrave; la d&eacute;finition suivante:</p>

<pre class="demo">
class complexe {
     public:
       ...
       <b>operator float() {return r;};</b>
     private:
       ...
     };
</pre>

<p>A partir de maintenant, on peut faire une conversion de type comme on
a l'habitude en C:</p>

<pre class="demo">
...

complexe J(1,0);
<b>float I = (float)J;</b>
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Lorsqu'on d&eacute;finit un <code>operator type()</code>, il ne
<em>faut pas</em> sp&eacute;cifier de type de retour. C'est un peu bizarre,
mais assez logique, compte-tenu du fait que le type est d&eacute;j&agrave; sp&eacute;cifi&eacute;
dans le nom de l'op&eacute;rateur lui-m&ecirc;me.
</p></div>

<h3><a name="autres-ope">Autres op&eacute;rateurs</a></h3>

<p>Certains   op&eacute;rateurs seront &eacute;voqu&eacute;s un peu plus loin:</p>

<ul>
  <li><code>&lt;&lt;</code> et <code>&gt;&gt;</code> sont utilis&eacute;s
      pour les entr&eacute;es-sorties <a  href="stdlib.html#stream-fmt"><img
      alt="apr&egrave;s" src="apres.gif" /></a></li> 
  <li><code>*</code>, <code>-&gt;</code>, <code>-&gt;*</code>,
      <code>new</code> et <code>delete</code> permettent de
      d&eacute;finir des fonctions avanc&eacute;es de gestion de m&eacute;moire <a
      href="mem.html#compt"><img      alt="apr&egrave;s" 
      src="apres.gif" /></a></li>
  <li><code>[]</code> permet de d&eacute;finir des op&eacute;rateurs d'acc&egrave;s aux
      tableaux.</li>
  <li><code>()</code> permet de simuler des acc&egrave;s &agrave; des tableaux
      multidimensionnels</li>
  <li><code>()</code> permet &eacute;galement de d&eacute;finir des
      objets fonctions: un objet fonction est un objet dont <em>la
      seule raison d'&ecirc;tre</em> est d'encapsuler un appel de
      fonction. cf. les exercices sur ce chapitre pour plus de
      d&eacute;tails, et le chapitre sur la biblioth&egrave;que standard, qui fait
      largement appel &agrave; cette notion d'objets fonctions</li>
</ul>

<p><a href="#">top</a></p><hr />
<div class="autres langages"><p><img alt="DECHIRURE" src="dechirure.gif" /></p>
<table class="tableau">
  <tr>
    <th> Langage </th>
    <th> Surcharge d'une fonction </th>
    <th> Valeurs par d&eacute;faut des arguments </th>
    <th> Surcharge des op&eacute;rateurs </th>
  </tr>
  <tr>
    <td><b>C++</b> </td>
    <td><b>OUI</b></td><td><b>OUI</b></td><td><b>OUI</b></td>
  </tr>
  <tr>
    <td><b>perl</b></td>
    <td><b>Possible (1)</b></td><td><b>OUI</b></td><td><b>Possible (2)</b></td>
  </tr>
  <tr>
    <td><b>java</b></td>
    <td><b>OUI</b></td><td>NON</td><td>NON</td>
  </tr>
  <tr>
    <td><b>python</b></td>
    <td>NON</td><td><b>OUI</b></td><td><b>OUI</b></td>
  </tr>
</table>
<ol>
  <li>En perl, le typage des donn&eacute;es n'existe pas vraiment... du coup,
    le passage d'arguments est assez "souple" pour qu'il 
    soit possible de surcharger une fonction, m&ecirc;me si le langage ne
    le pr&eacute;voit pas explicitement</li>
  <li>La surcharge des op&eacute;rateurs est possible, en perl, par
  l'interm&eacute;diaire du module OVERLOAD. D'autre part, le fonction
  <code>tie</code> peut &ecirc;tre consid&eacute;r&eacute;e comme une sorte de surcharge
  des op&eacute;rateurs d'acc&egrave;s  aux tableaux.</li> 
</ol>
</div>

<p><a href="#">top</a></p><hr />
<p>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>
</div></body> </html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15" />
  <meta http-equiv="Content-Language" content="fr" />
  <!-- c'est trop la merde: j'ai une feuille de style pour IE -->
  <script type="text/javascript">
  if (navigator.appName.indexOf("Explorer") > -1)
  {
     var IE=true;
     document.write('<style type="text/css" media="screen">@import url(cours_ie.css);</style>');
  }
  else
  {
     document.write('<style type="text/css" media="screen">@import url(cours.css);</style>');
  }
  </script>
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Les types de base</title>
</head>

<body>
<!-- Javascript, xhtml et CSS inspire des tutoriels www.alsacreations.com/articles -->
<script type="text/javascript">
<!--
window.onload=montre;
function montre(id) {
  var d = document.getElementById(id);
  var b = document.getElementById('bouton_menu');

  for (var i = 1; i<=1; i++) {
    var m = document.getElementById('smenu'+i);
    if (m && m!=d) {
       m.style.display='none';
    }
  }
  if (d) {
     if (d.style.display=='none') {
        d.style.display='block';
     } else {
        d.style.display='none';
     }
  }
  b.style.display='none';
}

function cacher_menu() {      
   if (IE) return;
   var m = document.getElementById('menu');
   var b = document.getElementById('bouton_menu');
   montre();
   if (m.style.display=='none') {
      m.style.display='block';
      b.style.display='none';
   } else {
      m.style.display='none';
      b.style.display='block';
   }
}    
function bckgrnd(couleur,id) {
   document.getElementById(id).style.background=couleur;
}
//-->
</script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inra.fr" title="I.N.R.A."><img alt="logo INRA" src="inra.png" /></a></dt>
</dl>
<!--<dl class="img">
 <dt><a href="http://www.ups-tlse.fr" title="L'Universit&eacute; Paul sabatier"><img alt="logo ups" src="ups.jpg" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.adbt.com" title="L'adbt"><img alt="logo adbt" src="adbt.jpg" /></a></dt>
</dl>-->
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
    <dd id="smenu1"  style="height:20em;overflow:scroll;">
    	<ul>
		<li><a onclick="javascript=cacher_menu()"href="types.html#type-base">D&eacute;clarations de variables</a></li> 
		<li><a onclick="javascript=cacher_menu()"href="types.html#type-predef">Les types pr&eacute;d&eacute;finis</a>
		<ul>
			<li><a onclick="javascript=cacher_menu()"href="types.html#bool">Le type <code>bool</code></a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#char-num">Les types <code>char</code> ou num&eacute;riques</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#void">Le type <em>void</em></a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#struct">Les types <code>struct</code> et <code>union</code></a></li>
		</ul></li>
		<li><a onclick="javascript=cacher_menu()"href="types.html#ptr-ref-const">Pointeurs (*), r&eacute;f&eacute;rences (&amp;), descripteur const</a></li> 
		<li><a onclick="javascript=cacher_menu()"href="types.html#ptr-ana">Analogies avec le monde dit &quot;r&eacute;el&quot;</a>
		<ul>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#clonage">Initialisation = Cl&ocirc;nage</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-egal">Op&eacute;rateur= : Je me prends pour un autre</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-surnom">R&eacute;f&eacute;rences = Surnoms</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-ptr">Pointeurs = Attention, on vous montre du doigt</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-prmval">Passage des param&egrave;tres par valeur</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-prmref">Passage du client par r&eacute;f&eacute;rence</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-prmconstref">Passage du coiffeur par const r&eacute;f&eacute;rence</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-retval">Retour d'un param&egrave;tre par valeur</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-retref">Retour d'un param&egrave;tre par r&eacute;f&eacute;rence</a></li>
		   <li><a onclick="javascript=cacher_menu()"href="types.html#ptr-retptr">Retour d'un param&egrave;tre par pointeur</a></li>
		</ul></li>
		<li><a onclick="javascript=cacher_menu()"href="types.html#ptr-virt">Retour au monde virtuel</a>
		<ul>
			<li><a onclick="javascript=cacher_menu()"href="types.html#ref">Le type r&eacute;f&eacute;rence</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#ptr">Le type pointeur</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#ref-pourquoi">Une r&eacute;f&eacute;rence, pour quoi faire ?</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#desc-const">Le descripteur const</a></li> 
		</ul></li>
		<li><a onclick="javascript=cacher_menu()"href="types.html#class">Le type class</a> 
		<ul>
			<li><a onclick="javascript=cacher_menu()"href="types.html#priv-prot-pub">Sections priv&eacute;es, prot&eacute;g&eacute;es, publiques</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#pub">Section public </a></li>
			<li><a onclick="javascript=cacher_menu()"href="types.html#prot">Section protected</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#fct-memb">Fonctions membres </a></li>
			<li><a onclick="javascript=cacher_menu()"href="types.html#fct-amies">Fonctions amies</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#acces-donn">Acc&egrave;s aux donn&eacute;es</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#construct">Constructeurs</a></li>
			<li><a onclick="javascript=cacher_menu()"href="types.html#destruct">Destructeur</a></li>
			<li><a onclick="javascript=cacher_menu()"href="types.html#static">Le descripteur <code>static</code></a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#const">Le descripteur const</a></li> 
			<li><a onclick="javascript=cacher_menu()"href="types.html#this">Le pointeur *this</a></li> 
		</ul></li>
	</ul>
    </dd>
</dl>
<dl>
 <dt><a href="exos.html#pointeurs" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com/ref/">iostream</a></dt>
</dl>
<dl>
  <dt><a href="http://www.sgi.com/tech/stl/index.html">La STL</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cppreference.com/">REF</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1><a name="type-base">Les types de base</a></h1>

<h2><a name="decl-var">D&eacute;clarations de variables</a></h2>

<p>Les types  de  base du  <code>C++</code> sont  les
m&ecirc;mes   que  les   types  du   <code>C</code>,  avec   les  extensions
suivantes:</p>

<ul>
  <li>Le type <code>bool</code></li>
  <li>La notion de r&eacute;f&eacute;rence</li>
  <li>Le type <code>class</code> (fondamental, car c'est lui qui
      permet de d&eacute;finir les objets)</li>
</ul>

<h3><a name="portee-nom">La port&eacute;e d'un nom</a></h3>

<p>Un nom  [de type,  de variable,  de fonction,  ... ]
n'est utilisable qu'entre telle et telle ligne du code. Cet espace est
appel&eacute; la port&eacute;e  du nom. La port&eacute;e du  nom <code>A</code> est d&eacute;finie
de la mani&egrave;re suivante:</p>

<ul>
  <li>Elle commence &agrave; la ligne de d&eacute;claration de <code>A</code></li>
  <li>Elle se termine &agrave; la fin du bloc dans lequel la variable
      <code>A</code> a &eacute;t&eacute; d&eacute;finie. La fin de bloc est marqu&eacute;e par une
      accolade fermante <code><b>}</b></code>.</li>
</ul>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Une variable  peut  &ecirc;tre d&eacute;clar&eacute;e  &agrave; n'importe  quel
endroit du code, alors que le  C impose une d&eacute;claration de variable en
d&eacute;but de bloc uniquement.  Exemple:</p>

<pre class="demo">
...
   {
   ...
   <b>int A=5;    // DEBUT DE LA PORTEE DE A</b>
   ...
   <b>};          // FIN DE LA PORTEE DE A</b>
...
</pre></div>

<h4><a name="nom-global">Nom global</a></h4>

<p>Un nom  global est  un nom  d&eacute;fini &agrave;  l'ext&eacute;rieur de
toute  fonction,  de  toute  classe,   de  tout  espace  de  noms  (<a
href="stdlib.html#namedecl"><img      alt="apres"      src="apres.gif" /></a>).
Un nom  global sera  donc accessible  dans  tout le
programme.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Ne pas confondre variable globale et variable locale &agrave; la fonction
main:</p>

<pre class="demo">
...
<b>int A;             // variable globale</b>

int main() {
<b>    int B;         // variable locale a main</b>
    int C=f1();
};
    
int f1() {
    ...
    int C=A;       // pas de pb, A est accessible
    <b>C += B;        // ERREUR B n'est pas connu ici</b>
    return C;
};

</pre></div>

<h4><a name="masque">Masquage et r&eacute;solution de port&eacute;e</a></h4>

<p>Comme les  trains &agrave; un passage &agrave;  niveau, un nom peut
en cacher  un autre !  Pour masquer  un nom, il suffit  de d&eacute;clarer le
m&ecirc;me nom dans un bloc interne au premier. Le masquage sera termin&eacute; d&egrave;s
la fin du bloc interne. Bien entendu, rien n'emp&ecirc;che de masquer un nom
de variable  par un nom de  fonction, par exemple...  Il est toutefois
recommand&eacute; d'&eacute;viter de jouer avec cela, c'est une source de bogues pas
&eacute;vidents &agrave; d&eacute;tecter.</p>

<p>Un nom masqu&eacute;  <em>ne peut &ecirc;tre utilis&eacute; </em>, sauf
s'il  s'agit  d'une variable  globale:  dans  ce  cas, l'op&eacute;rateur  de
r&eacute;solution    de   port&eacute;e    <code><b>::</b></code>   permet
d'utiliser   le  nom  global,   comme  on   le  voit   dans  l'exemple
ci-dessous:</p>

<pre class="demo">
<b>int A=1;</b>
main () {
   <b>int B=1;</b>
   <b>int A=2;</b>
   cout &lt;&lt; A &lt;&lt; "\n";          // renvoie 2
   cout &lt;&lt; ::A &lt;&lt; "\n";        // renvoie 1
   {                           // ouverture d'un nouveau bloc
      <b>int B=2;</b>
      cout &lt;&lt; B &lt;&lt; "\n";       // renvoie 2
   }   
</pre>

<h4><a name="portee-var">Variables...</a></h4>

<p>La  port&eacute;e d'une variable est bien  entendu la port&eacute;e
du nom de cette variable.  Concr&egrave;tement, la m&eacute;moire est allou&eacute;e d&egrave;s le
d&eacute;but de la port&eacute;e, et la m&eacute;moire sera rendue au syst&egrave;me d&egrave;s la fin de
la port&eacute;e.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> Une  exception &agrave; la r&egrave;gle de
la  port&eacute;e:  dans  l'exemple  ci-dessous,  la port&eacute;e  de  la  variable
<code>i</code> est le  <em>bloc</em> situ&eacute; en-dessous de l'instruction
<code>for</code>.   C'est  parfaitement logique,  car  cela permet  de
d&eacute;finir des variables muettes  dans les boucles <code>for</code>, mais
ce comportement est diff&eacute;rent de ce  qu'on conna&icirc;t en <code>C</code>.</p>

<pre class="demo">
...
for (<b>int i=0</b>; i&lt;10;i++)    // DEBUT DE PORTEE DE i
   {...
    ...
   };                      //  FIN DE PORTEE DE i
</pre></div>


<h3><a name="decl-var">La structure d'une d&eacute;claration de variables</a></h3>

<p>Une d&eacute;claration de variables comprend:</p>

<ol>
  <li>Un descripteur optionnel (<code>const</code>, <code>extern</code>,
      <code>virtual</code>, ...)</li>
  <li>Un type de base <em>obligatoire</em> (<code>int</code> etc., ou type
      d&eacute;fini par le programmeur)</li>
  <li>Un d&eacute;clarateur <em>obligatoire</em>. Celui-ci est constitu&eacute; de:
      <ul>
	<li>un nom choisi par le programmeur</li>
	<li>un ou plusieurs op&eacute;rateurs de d&eacute;claration.</li> 
      </ul></li>
  <li>Un initialiseur optionnel.</li>
</ol>

<p>Exemple:</p>

<pre class="demo">
int* A [];
</pre>

<p>La d&eacute;claration de variables ci-dessus est
constitu&eacute;e de la mani&egrave;re suivante:</p>

<ol>
  <li>Pas de descripteur</li>
  <li>Type de base: <code>int</code></li>
  <li>D&eacute;clarateur constitu&eacute; de:
      <ul>
	<li>Le nom <code>A</code></li>
	<li>Les deux op&eacute;rateurs de d&eacute;claration <code><b>*</b></code> et
	    <code><b>[]</b></code>. Les op&eacute;rateurs <em>postfix&eacute;s</em>
	    (<code><b>[]</b></code>) ayant une priorit&eacute; sup&eacute;rieure aux
	    op&eacute;rateur <em>pr&eacute;fix&eacute;s</em> (<code><b>*</b></code>), on a d&eacute;clar&eacute;
	    un tableau de pointeurs, non pas un pointeur vers un tableau.</li>
      </ul></li>
  <li>Pas d'initialiseur.</li>
</ol>

<p>Quelques d&eacute;clarations l&eacute;gales:</p>

<pre class="demo">
char* ctbl[] = {"bleu","blanc","rouge"};    // 3 parties sont sp&eacute;cifi&eacute;es
const int A = 2;                            // 4 parties
int B;                                      // 2 parties seulement
</pre>

<p>quelques descripteurs sur lesquels nous reviendrons ult&eacute;rieurement:</p>

<dl>
  <dt><code><b>const</b></code></dt> 
  <dd>Permet de d&eacute;finir une variable constante. Par exemple, un objet constant. Nous verrons dans la suite que cela peut apporter quelques complications.</dd>
  <dt><code><b>mutable</b></code></dt>
  <dd>Utilis&eacute; dans les d&eacute;claration de classes, en lien avec <code>const</code></dd>
  <dt><code><b>static</b></code></dt>
  <dd>Utilis&eacute; dans les d&eacute;clarations de classes ou de fonctions</dd>
  <dt><code><b>virtual</b></code></dt>
  <dd>Utilis&eacute; dans les d&eacute;claration de classes</dd>
</dl>

<p><a href="#">top</a></p><hr />

<h2><a name="type-predef">Les types pr&eacute;d&eacute;finis</a></h2>

<h3><a name="bool">Le type <code>bool</code></a></h3>

<p>Un bool&eacute;en peut prendre les valeurs <code>true</code>
ou  <code>false</code>. Il  est possible  de convertir  un  bool&eacute;en en
entier et  vice-versa; dans ce cas, <code>true</code>  se convertit en
<code>1</code>,  <code>false</code>  se  convertit en  <code>0</code>.
Dans l'autre  sens, <code>0</code> est  converti en <code>false</code>
et tout  entier non  nul est converti  en <code>true</code>. </p>

<h3><a name="char-num">Les types <code>char</code> ou num&eacute;riques</a></h3>

<p>Les types usuels du C sont utilisables en <code>C++</code>:</p>

<ul>
  <li><code><b>char</b></code>, <code><b>unsigned char</b></code>, <code><b>signed
      char</b></code></li>
  <li><code><b>int</b></code>, <code><b>short int</b></code>, <code><b>long int</b></code></li>
  <li><code><b>unsigned int</b></code>, <code><b>unsigned short int</b></code>,
      <code><b>unsigned long int</b></code></li>
  <li><code><b>float</b></code>, <code><b>double</b></code>, <code><b>long double</b></code></li>
</ul>

<h3><a name="void">Le type <em>void</em></a></h3>

<p>Il  s'agit  d'un   "pseudo-type",  qui   veut  dire
"rien". On peut l'employer comme type de pointeur;</p>

<pre class="demo">void*</pre>

<p>signifie  "pointeur vers n'importe  quoi". <code>void</code> peut aussi &ecirc;tre employ&eacute; comme
type de  retour de fonction:</p>

<pre class="demo">
void  f()
</pre>

<p>  signifie "fonction qui ne  renvoie aucune valeur" (proc&eacute;dure en pascal).</p>

<div class="attention"><p><img  alt="ATTENTION"   src="attention.gif" /> La d&eacute;claration  suivante:</p>

<pre class="demo">
fonction();
</pre>

<p>devrait  en  toute  logique
correspondre &agrave;  une fonction qui  ne renvoie aucune  valeur.  H&eacute;las...
le C consid&egrave;re que le type <code>int</code> est renvoy&eacute; par d&eacute;faut. Le
C++ a bien s&ucirc;r suivi le m&ecirc;me usage, pour des raisons de compatibilit&eacute;.
Donc  pour ne  rien  renvoyer  il faut  sp&eacute;cifier:</p>

<pre class="demo">
void fonction_1();
</pre></div>

<h3><a name="struct">Les types <code>struct</code> et <code>union</code></a></h3>

<p>Disons pour simplifier que ces types sont utilis&eacute;s en
C++  de la  m&ecirc;me  mani&egrave;re qu'en  C:  m&ecirc;me si  l'on  peut d&eacute;clarer  des
fonctions-membres dans les structures, il est pr&eacute;f&eacute;rable de s'en tenir
au type <code>class</code> d&eacute;crit  ci-dessous pour d&eacute;finir des objets,
et utiliser <code>struct</code> et  <code>union</code> pour le code de
plus bas niveau.</p>

<p><a href="#">top</a></p><hr />

<h2><a name="ptr-ref-const">Pointeurs (*), r&eacute;f&eacute;rences (&amp;), descripteur const</a></h2>

<div class="attention"><p><img alt="ATTENTION"  src="attention.gif" /><b>Note typographique</b>. On le verra dans la suite, il est ais&eacute; de confondre:</p>
<ul>
	<li>les deux significations du caract&egrave;re * dans: <code>int * x</code> et <code> y = *x </code></li>
	<li>les deux significations du caract&egrave;re &amp; dans: <code> int &amp; </code> et <code> x = &amp; y </code></li>
</ul>
Pour faciliter les choses, on &eacute;crira:

<ul>
	<li><b><code> int*  x</code></b> ou <b><code> int&amp;  y </code></b> pour les d&eacute;clarations</li>
	<li><b><code> *x </code></b> ou <b><code> &amp;y </code> </b>pour les op&eacute;rateurs.</li>
</ul>

<p>Notons que la norme du C++ permet d'ins&eacute;rer un espace entre le caract&egrave;re et le nom de la variable ou du
 type, mais cette pr&eacute;sentation est plus claire pour le lecteur, et correspond bien &agrave; 
 la r&eacute;alit&eacute; du compilateur: en effet, dans une d&eacute;claration <code> int * x </code> ou 
 <code>int &amp; y </code>, il s'agit bel et bien d'utiliser les <i>types</i> <code>int*</code> ou <code>int&amp;</code>.</p></div>

<h2><a name="ptr-ana"><img src="61.gif" alt="Pour les terriens"  width="20" />
 Quelques analogies avec le monde dit "r&eacute;el"</a></h2>

<p>Soit un objet de type... <code>homme</code>. Comment cet objet peut-il se manipuler, et quelle analogie peut-on faire avec la vie "r&eacute;elle" ?</p>
<h2>Initialisation, op&eacute;rateur = : Un peu de Science Fiction</h2>
<p>Contrairement &agrave; ce qu'on pourrait penser, ces op&eacute;rations, qui paraissent les plus simples (par analogie avec les maths), sont en fait trËs lourdes pour l'ordinateur...</p>

<h3><a name="clonage">Initialisation = Cl&ocirc;nage</a></h3>

<pre class="demo">
homme jacques;
<b>homme paul = jacques;</b>
</pre>

<p><code>paul</code> est obtenu par "cl&ocirc;nage" &agrave;
partir de <code>jacques</code>. Les deux objets sont
parfaitement identiques lorsque le code ci-dessus est ex&eacute;cut&eacute;,
mais ensuite ils vivent chacun leur vie, et leur destin peut
&ecirc;tre diff&eacute;rent dans la suite du programme.</p>  

<div class="attention"><p><img alt="ATTENTION"  src="attention.gif" />L'initialisation comme l'affectation ne sont pas des
op&eacute;rations simples a priori: elles se traduisent au minimum par une
copie bit &agrave; bit, qui peut &ecirc;tre longue si les objets sont gros, et
&eacute;ventuellement par des op&eacute;rations plus complexes comme l'allocation de
ressources. On essaiera donc de les &eacute;viter dans la mesure du possible,
tout au moins lorsqu'on a affaire &agrave; des objets &eacute;labor&eacute;s.</p></div>

<h3><a name="ptr-egal">Op&eacute;rateur= : Je me prends pour un autre.</a></h3>

<pre class="demo">
homme pierre;
...
<b>pierre = paul;</b>
</pre>

<p>Ici, <code>pierre</code> a une vie avant sa rencontre avec 
<code>paul</code>. L'op&eacute;rateur= va "jeter" toutes les donn&eacute;es qui
concernent pierre  et les remplacer par celles de <code>paul</code>. Ensuite, chaque
objet vit sa vie, comme pr&eacute;c&eacute;demment...</p> 

<div class="attention"><p><img alt="ATTENTION"  src="attention.gif" />Ces op&eacute;rations permettent d'obtenir 
deux objets <i>&eacute;gaux</i>, on l'a vu, mais pas <i>identiques</i>.</p></div>

<h3><a name="ptr-surnom">R&eacute;f&eacute;rences = Surnoms</a></h3>

<pre class="demo">
homme pierre;
<b>homme&amp; pierrot = pierre;</b>
<b>homme&amp; tonton = pierre;</b>
</pre>

<p>La situation ci-contre est bien plus courante: tout simplement, <code>pierre</code> porte
plusieurs surnoms. Les uns l'appelleront <code>pierrot</code>, les autres <code>tonton</code>. 
Dans tous les cas,il s'agit de la m&ecirc;me personne (du m&ecirc;me objet). Tout ce qui arrivera &agrave;
<code>pierre</code> arrivera aussi &agrave; <code>pierrot</code>, puisqu'il s'agit du m&ecirc;me individu. 
De m&ecirc;me qu'une personne peut avoir autant de surnoms qu'on le souhaite, de m&ecirc;me un
objet peut avoir un nombre illimit&eacute; de r&eacute;f&eacute;rences. Mais il n'y a jamais qu'un seul objet.</p> 

<div class="attention"><p><img alt="ATTENTION"  src="attention.gif" />Cette fois, on a obtenu deux objets <i>identiques</i> (donc aussi &eacute;gaux).
</p></div>

<p><a href="#">top</a></p><hr />

<h3><a name="ptr-ptr">Pointeurs = Attention, on vous montre du doigt</a></h3>

<pre class="demo">
homme pierre;
<b>homme* ce_mec = pierre;</b>
<b>homme* le_type_la_bas = pierre;</b>
<b>homme* encore_un_bebe= new(homme);</b>
</pre>

<p><code>pierre</code> est montr&eacute; du doigt une fois, deux fois, ... autant de fois que vous le
d&eacute;sirez: donc <code>homme</code> d&eacute;signe un objet a priori compliqu&eacute;, mais 
<code>homme* </code> d&eacute;signe tout simplement le doigt qui pointe sur un homme. (en C++, 
comme en C,on a autant de types de doigts diff&eacute;rents que d'objets point&eacute;s. Cela permet
d'&eacute;viter de nombreuses erreurs de programme).</p>

<div class="attention"><p><img alt="ATTENTION"  src="attention.gif" />Bien entendu, on peut avoir autant de pointeurs que
l'on veut. Mais chaque pointeur est un nouvel objet. Les pointeurs sont d&eacute;licats &agrave;
manier, simplement parce qu'il est possible de "casser" le lien entre pointeur et objet point&eacute;. 
Cela peut amener deux situations ennuyeuses:</p> 
<ul>
  <li>Le pointeur est d&eacute;truit, mais pas l'objet point&eacute;. Si rien ne
      pointe plus sur lui, on peut perdre sa trace dans la m&eacute;moire de
      l'ordinateur... celui-ci a alors la migraine (fuites de
      m&eacute;moire). </li>
  <li>L'objet point&eacute; peut dispara&icirc;tre, alors que le pointeur continue
      de pointer sur lui: Risque  important de plantages al&eacute;atoires.</li>
</ul>
</div>

<p><a href="#">top</a></p><hr />

<h2>Pierre va chez le coiffeur...</h2>

<p>Soit la fonction <code>coupe</code> qui a 
deux param&egrave;tres: le coiffeur et le client, le coiffeur coupant les
cheveux au client.</p> 

<h3><a name="ptr-prmval">Passage des param&egrave;tres par valeur</a></h3>

<pre class="demo">
void coupe(<b>homme coiffeur, homme client</b>);
...
homme pierre;
homme jacques;
coupe(jacques, pierre);
</pre>

<p><code>pierre</code> ainsi que <code>jacques</code> sont ici pass&eacute;s par valeur. Autrement
dit, arriv&eacute;s au salon de coiffure, la machine cl&ocirc;ne <code>pierre</code> d'une part, 
<code>jacques</code> d'autre part, et c'est le cl&ocirc;ne du coiffeur qui va couper les cheveux
au cl&ocirc;ne de pierre. Apr&egrave;s quoi, les deux cl&ocirc;nes sont d&eacute;truits,
et <code>pierre</code> repart avec les cheveux 	longs. L'histoire est stupide, certes, mais ce genre d'erreurs
arrive fr&eacute;quemment (en C++, en tous cas).</p> 

<p><a href="#">top</a></p><hr />

<h3><a name="ptr-prmref">Passage du client par r&eacute;f&eacute;rence</a></h3>
<pre class="demo">
void coupe(<b>homme coiffeur, homme&amp; client</b>);
...
homme pierre;
homme jacques;
coupe(jacques, pierre);
</pre>

<p><code>pierre</code> est pass&eacute; par r&eacute;f&eacute;rence &agrave; la fonction 
<code>coupe</code>: <code>client</code> est tout simplement un surnom qu'on lui donne dans ce contexte. 
<code>jacques</code> est toujours pass&eacute; par valeur, de sorte que dans cette histoire, c'est le cl&ocirc;ne 
de <code>jacques</code> qui coupera les cheveux &agrave; son <code>client</code>, qui se trouve &ecirc;tre
<code>pierre</code>. Pas de probl&egrave;me, le cl&ocirc;ne de <code>jacques</code> est par d&eacute;finition aussi bon 
coiffeur que <code>jacques</code> lui-m&ecirc;me. Mais le cl&ocirc;nage n'est-il pas une op&eacute;ration un peu 
compliqu&eacute;e, simplement pour une histoire de coupe de cheveux ? Un avantage &agrave; signaler: si
<code>pierre</code> est m&eacute;content du travail du coiffeur, il pourra toujours casser la figure au cl&ocirc;ne de
<code>jacques</code>, <code>jacques</code> lui-m&ecirc;me ne sera pas touch&eacute;... en termes plus techniques, 
si la variable locale <code>coiffeur</code> est modifi&eacute;e par le programme, cela n'aura pas d'impact sur <code>jacques</code> 
(pas d'effets de bords). </p>

<p><a href="#">top</a></p><hr />

<h3><a name="ptr-prmconstref">Passage du coiffeur par const r&eacute;f&eacute;rence</a></h3>


<pre class="demo">
void coupe(<b>const homme&amp; coiffeur, homme&amp; client</b>);
...
homme pierre;
homme jacques;
coupe(jacques, pierre);
</pre>

<p>dans le contexte de la fonction <code>coupe</code>, <code>pierre</code> s'appelle maintenant
<code>client</code>, alors que <code>jacques</code> s'appelle <code>coiffeur</code>. 
Plus besoin d'op&eacute;rations compliqu&eacute;es comme le cl&ocirc;nage, alors qu'un surnom fait si bien
l'affaire. De plus, le descripteur <code>const</code> prot&egrave;ge le coiffeur contre les clients m&eacute;contents: 
m&ecirc;me si <code>pierre</code> est m&eacute;content de sa coupe, il ne pourra pas casser la figure &agrave; son coiffeur
(car l'&eacute;tat de celui-ci ne peut changer, &agrave; cause de <code>const</code>). D'un point-de-vue technique, 
la variable locale <code>coiffeur</code> ne peut &ecirc;tre modifi&eacute;e, il ne peut donc l&agrave; non plus y avoir 
d'effets de bords. Ainsi, la s&eacute;mantique (signification) de cet appel et celle de l'appel pr&eacute;c&eacute;dent 
sont les m&ecirc;mes, simplement le code est ici plus optimis&eacute;. </p>

<p><a href="#">top</a></p><hr />

<h2>Un accouchement difficile</h2>

<p>Voici l'histoire d'un accouchement &agrave; haut risque, suite &agrave; l'ex&eacute;cution de la fonction 
<code>co&iuml;t</code>...</p>

<h3><a name="ptr-retval">Retour d'un param&egrave;tre par valeur</a></h3>

<pre class="demo">
<b>humain</b> coit(homme&amp; h, femme&amp; f) {
   ...
   humain enfant = h + f;
   ...
   <b>return enfant;</b>
};

homme pierre;
femme marie;
humain loulou = coit(pierre,marie);
</pre>

<p>Une dr&ocirc;le de mani&egrave;re de faire un enfant: l'enfant nait dans le contexte de la fonction <code>coit</code>,
mais &agrave; la fin de la fonction, on en fait un cl&ocirc;ne, on sort le cl&ocirc;ne et on massacre l'enfant. 
Merci de ne pas pr&eacute;venir le comit&eacute; d'&eacute;thique... C'est long, compliqu&eacute; et immoral, mais
&ccedil;a marche.</p> 

<p><a href="#">top</a></p><hr />

<h3><a name="ptr-retref">Retour d'un param&egrave;tre par r&eacute;f&eacute;rence</a></h3>

<pre class="demo">
<b>humain&amp;</b> coit(homme&amp; h, femme&amp; f) {
   ...
   humain enfant = h + f;
   ...
   <b>return enfant;</b>
};

homme pierre;
femme marie;
humain&amp; loulou = coit(pierre,marie);
</pre>

<p>Voil&agrave; qui est encore pire: l'enfant, apr&egrave;s sa naissance, est retourn&eacute; sous le nom <code>loulou</code>... mais tout-de-suite apr&egrave;s il est d&eacute;truit, puisqu'il s'agit d'une variable
locale &agrave; la fonction <code>coit</code>, qui n'existe donc que le temps que la fonction est ex&eacute;cut&eacute;e.</p>

<div class="attention"><p><img alt="ATTENTION"  src="attention.gif" /> Attention, cela ne veut pas dire qu'on ne doit pas 
renvoyer de r&eacute;f&eacute;rences en sortie d'une fonction. On ne doit pas renvoyer de r&eacute;f&eacute;rence sur un
objet interne &agrave; la fonction, car cet objet cesse d'exister lorsque la fonction a fini son ex&eacute;cution. 
Le pire, c'est que... &ccedil;a peut marcher: rien ne dit que le syst&egrave;me aura d&eacute;truit tout-de-suite l'objet. 
Mais gare au plantage si vous changez de conditions (de compilateur, par exemple).</p></div>

<h3><a name="ptr-retptr">Retour d'un param&egrave;tre par pointeur</a></h3>

<pre class="demo">
<b>humain*</b> coit(homme&amp; h, femme&amp; f) {
   ...
   humain* enfant = new humain(h,f);
   ...
   <b>return enfant;</b>
};

homme pierre;
femme marie;
humain* nouveau_ne = coit(pierre,marie);
</pre>

<p>Cette fois, &ccedil;a va mieux: l'enfant est cr&eacute;&eacute; par <code>new</code>, mais il est <i>quelque part
ailleurs</i>, et <i>il n'a pas &eacute;t&eacute; baptis&eacute; (pas de nom)</i>. On ne sait que l'appeler <code>*enfant</code>.
Seul le pointeur est interne &agrave; la fonction. On renvoie (par une recopie) le pointeur &agrave; l'ext&eacute;rieur,
et on d&eacute;truit le pointeur d'origine (mais cela n'a aucune importance, l'enfant est pr&eacute;serv&eacute;). </p>

<p><a href="#">top</a></p><hr />

<h2><a name="ptr-virt">Retour au monde virtuel...</a></h2>
<h3><a name="ref">Le type r&eacute;f&eacute;rence</a></h3>

<p>Soit le programme suivant:</p>

<pre class="demo">
int A=3;
int&amp; a=A;
A++;
cout &lt;&lt; "valeur de A = " &lt;&lt; A &lt;&lt; "valeur de a = " &lt;&lt; a &lt;&lt; "\n";
</pre>

<p>Le  programme renvoie  4 pour A  comme pour  a. Que
s'est-il  pass&eacute; ?   La  ligne <code>int  &amp;a=A</code> qui  signifie
"r&eacute;f&eacute;rence", revient &agrave; d&eacute;clarer un <em>synonyme</em> &agrave; A (m&ecirc;me adresse
m&eacute;moire, mais  nom diff&eacute;rent).  L'adresse en m&eacute;moire  sera donc <em>la
m&ecirc;me</em> pour A et pour a.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
La d&eacute;claration suivante <em>dans un  programme ou une fonction</em> n'a  pas de sens:</p>

<pre class="demo">
<b>int &amp; a;</b>            // ERREUR DE COMPILATION !!!
</pre>

<p>En  effet, un  synonyme  est  un synonyme,  encore
faut-il  pr&eacute;ciser  de  quoi   on  est  synonyme.   Par  contre,  cette
d&eacute;claration <em>en  tant que  membre d'une classe</em>  a un  sens: on
pr&eacute;cisera  de quoi  on est  synonyme  lors de  l'initialisation de  la
classe.<a     href="#init-memb"><img    alt="apres"    src="apres.gif" /></a>).  
De m&ecirc;me, une  telle d&eacute;claration  dans une  liste de
param&egrave;tres  d'une   fonction  a  une   signification  <a  href="#prm-ref"><img
alt="apres" src="apres.gif" /></a></p>
</div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
On  <em>ne  peut  pas</em>
changer  de "cible":  une  fois  qu'on a  dit  que <code>a</code>  est
synonyme   de  <code>A</code>,   <code>a</code>   reste  synonyme   de
<code>A</code>     durant    toute     sa     port&eacute;e.
Dans le code suivant: </p>

<pre class="demo">
nt A=3;
int&amp; a=A;

int B=5;
<b>a=B;</b>
</pre>

<p>L'expression: <b><code>a=B</code></b>   changera  la   <em>valeur</em>  de
<code>a</code>, donc aussi la valeur de <code>A</code>.</p>
</div>

<h3><a name="ptr">Le type pointeur</a></h3>

<p>De m&ecirc;me que ci-dessus, Le programme suivant
imprimera deux fois le chiffre 4:</p>

<pre class="demo">
int A=3;
int* a;

<b>a = &amp;A;</b>
A++;
cout &lt;&lt; "valeur de A = " &lt;&lt; A &lt;&lt; "valeur pointee par a = " &lt;&lt; *a &lt;&lt; "\n";
</pre>

<p><code><b>a</b></code>  est un
<em>pointeur</em>;  A l'inverse des r&eacute;f&eacute;rences, il est possible (<em>quoique dangereux</em>) de ne
pas l'initialiser; d'autre part, <code><b>a</b></code> peut
pointer sur n'importe quelle variable, ainsi que le montre le code
suivant:</p>

<pre class="demo">
int A=3;
int B=6;
int* a;

<b>a= &amp;A;</b>
cout &lt;&lt; "valeur de A = " &lt;&lt; A &lt;&lt; "valeur pointee par a = " &lt;&lt; *a &lt;&lt; "\n";
<b>a= &amp;B;</b>
cout &lt;&lt; "valeur de B = " &lt;&lt; B &lt;&lt; "valeur pointee par a = " &lt;&lt; *a &lt;&lt; "\n";
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Dans
l'expression      <code><b>a= &amp;B</b></code>      le     signe
<code><b>&amp;</b></code>  est  un  <em>op&eacute;rateur</em>.   Il  ne
s'agit pas  d'une  d&eacute;claration  de  type  comme  dans  le
paragraphe pr&eacute;c&eacute;dent:  le m&ecirc;me symbole  a donc deux significations
diff&eacute;rentes. </p></div>

<h3><a name="ref-pourquoi">Une r&eacute;f&eacute;rence, pour quoi faire ?</a></h3>

<p>Les principales utilisations des r&eacute;f&eacute;rences sont les suivantes:</p>

<ul>
  <li>Le passage des param&egrave;tres aux fonctions</li>
  <li>La d&eacute;claration de membres de classes</li>
  <li>La valeur de retour renvoy&eacute;e par les fonctions</li>
</ul>

<p>Les deux premi&egrave;res utilisations sont utiles pour:</p>

<ul>
  <li>Economiser de la place en m&eacute;moire, si les objets &agrave; passer prennent beaucoup de m&eacute;moire.</li>
  <li>Utiliser le polymorphisme <a href="heritage.html"><img  alt="apres" src="apres.gif" /></a> </li>
</ul>

<h4><a name="prm-ref">Passage des param&egrave;tres par r&eacute;f&eacute;rence</a></h4>

<p>Le programme ci-dessous renvoie 5:</p>

<pre class="demo">
void f(<b>int X</b>) {
   X=0;
};

main() {
   int A=5;
   <b>f(A);</b>
   cout &lt;&lt; A &lt;&lt; "\n";
};
</pre>

<p>En effet, lorsque  la variable  <code>X</code> est
pass&eacute;e &agrave;  la fonction <code>f</code>, sa  <em>valeur</em> est recopi&eacute;e
dans  la variable  locale  <code>X</code>. C'est  la  copie locale  de
<code>X</code> qui est mise &agrave; z&eacute;ro, elle sera d&eacute;truite d&egrave;s le retour de
la fonction. Par contre, le programme ci-dessous renvoie 0:</p>

<pre class="demo">
void f(<b>int&amp; X</b>) {
   X=0;
};

main() {
   int A=5;
   <b>f(A);</b>
   cout &lt;&lt; A &lt;&lt; "\n";
};
</pre>

<p>En        effet,       la        d&eacute;claration
<code><b>int&amp; X</b></code>  dans  le  prototype de  la  fonction
<code>f</code>    indique    un    passage    des    param&egrave;tres    par
r&eacute;f&eacute;rence. <code>X</code> est donc un <em>synonyme</em> de la variable
pass&eacute;e,  et   non  plus  une   recopie.   En  cons&eacute;quence,   la  ligne
<code><b>X=0</b></code>  dans <code>f</code>  remet  &agrave; 0  la
variable  <code>A</code>. Passer  un param&egrave;tre  par  r&eacute;f&eacute;rence revient
donc &agrave; passer un param&egrave;tre &agrave;  la fonction, tout en laissant &agrave; celle-ci
la possibilit&eacute; de modifier la valeur de la variable ainsi pass&eacute;e, donc
d'en faire aussi une<em> valeur de retour</em></p>

<h4><a name="pourquoi-renv-ref">Pourquoi renvoyer des r&eacute;f&eacute;rences ?</a></h4>

<p>Pour deux raisons principales:</p>
<ul>
  <li>Renvoyer une r&eacute;f&eacute;rence est tr&egrave;s rapide, car une r&eacute;f&eacute;rence n'est
      qu'une adresse (quelques octets). Par contre, renvoyer un objet
      peut &ecirc;tre co&ucirc;teux en ressources, car cela met en jeu le
      constructeur  de copie  <a href="surch.html#surch-construc"><img
      alt="apres" src="apres.gif" /></a>, et l'objet peut
      &ecirc;tre tr&egrave;s volumineux</li>
  <li>Renvoyer une r&eacute;f&eacute;rence permet aussi de renvoyer une
      "<code>lvalue</code>", c'est-&agrave;-dire quelque chose qui peut se
      mettre &agrave; gauche d'un signe <code>=</code></li>
</ul>

<p>Regardons en effet le programme suivant:</p>

<pre class="demo">
int A,B;
int&amp; renvAouB(bool s) {
  return (s==true ?) A : B;
};

main() {
  A = 10;
  B = 20;
  cout &lt;&lt; A &lt;&lt; B &lt;&lt;"\n";  // ecrit 10 20
  <b>renvAouB(true) = 5;</b> 
  cout &lt;&lt; A &lt;&lt; B &lt;&lt;"\n";  // ecrit 5 20
};
</pre>

<p>La  fonction renv renvoie  une <em>r&eacute;f&eacute;rence</em>
vers  la   variable  <code>A</code>.   Il  est   donc  l&eacute;gal  d'&eacute;crire
<code><b>renv(true)=5</b></code>   m&ecirc;me   s'il   peut   para&icirc;tre
surprenant de mettre &agrave; gauche  du signe &eacute;gal un appel de fonction.<br />
Ce m&eacute;canisme  est utilis&eacute; par  les objets d&eacute;finis par  la biblioth&egrave;que
standard  (<a   href="stdlib.html#"><img  alt="apres"  src="apres.gif" /></a>),
en  particulier  <code><b>map</b></code>,
<code><b>vector</b></code>  etc. Il  est  &eacute;galement courant,
dans  beaucoup  de fonctions-membres  ou  d'op&eacute;rateurs surcharg&eacute;s,  de
renvoyer une  r&eacute;f&eacute;rence, par exemple  une r&eacute;f&eacute;rence &agrave;  l'objet courant
<code>*this</code><a      href="types.html#this"><img      alt="apres"
src="apres.gif" /></a></p>

<div class="attention"><p><a name="ref-boum"><img alt="ATTENTION" src="attention.gif" /></a>
La  fonction  suivante a  de fortes chances  de planter &agrave;  l'ex&eacute;cution: en effet, elle  renvoie une
r&eacute;f&eacute;rence vers une  variable <em>locale</em>, et lorsque l'instruction
<code>return</code> est  ex&eacute;cut&eacute;e, cette variable  est d&eacute;truite...  le
r&eacute;sultat est  th&eacute;oriquement non pr&eacute;dictible,  mais moi je  vous pr&eacute;dis
pas mal d'emb&ecirc;tements.</p>
<pre class="demo">
int A;
int&amp; renv() {
  <b>int A=99;</b>
  return A;      // boum !!! plantage probable.
};
</pre></div>

<p><a href="#">top</a></p><hr />

<div class="autres"><p><big><img alt="Les autres ?" src="dechirure.gif"  width="25" />Autres langages objets</big></p>

<table border="1">
  <tr>
    <th align="center"> Langage </th>
    <th align="center"> Pointeur </th>
    <th align="center"> R&eacute;f&eacute;rence </th>
  </tr>
  <tr><td> C++ </td><td><b>OUI</b></td><td><b>OUI</b></td></tr>
  <tr><td> perl</td><td><b>OUI</b><sup>1</sup></td><td>NON</td></tr>
  <tr><td>java</td><td>NON</td><td>NON</td></tr>
  <tr><td>python<sup>2</sup></td><td>NON</td><td>NON</td></tr>
</table>
<ol>
  <li>Une <em>r&eacute;f&eacute;rence</em> perl est en fait &eacute;quivalent &agrave; un <em>pointeur</em> C ou C++. Par contre, &eacute;tant donn&eacute; que perl int&egrave;gre un "ramasse-miette" (gestion de la m&eacute;moire), l'utilisation des r&eacute;f&eacute;rences en perl est assez diff&eacute;rente de celle des pointeurs en C/C++.</li>
  <li>La situation en python est un peu particuli&egrave;re: en effet, dans ce langage, toutes les variables sont des pointeurs vers des z&ocirc;nes de m&eacute;moire. Il faut avoir cela pr&eacute;sent &agrave; l'esprit lorsqu'on r&eacute;alise des affectations.</li>
</ol></div>

<p><a href="#">top</a></p><hr />
      
<h3><a name="desc-const">Le descripteur const</a></h3>

<h4><a name="const-ref">Utilisation avec des r&eacute;f&eacute;rences:</a></h4>

<p>Pourquoi passer les param&egrave;tres par r&eacute;f&eacute;rence ? Pour deux raisons:</p>

<ul>
  <li>Le param&egrave;tre est utilis&eacute; <em>en entr&eacute;e</em>, mais aussi <em>en
      sortie</em>... cf. ci-dessus.</li>
  <li>Le param&egrave;tre est bien un param&egrave;tre d'entr&eacute;e pur, mais sa recopie
      prendrait un temps processeur non n&eacute;gligeable: cela peut &ecirc;tre le
      cas si l'on passe une variable de type <code>struct</code> ou
      <code>class</code> avec un grand nombre de champs.</li> 
</ul>

<p>Dans  le second  cas, il y  a danger: en  effet, si
l'un ou l'autre champ de l'objet pass&eacute; en param&egrave;tre est modifi&eacute;, on se
retrouve  avec un  "effet de  bord" non  d&eacute;sir&eacute;, erreur  pas  simple &agrave;
d&eacute;tecter...   dans ce  cas, le  <code>C++</code> offre  un  moyen bien
pratique         d'&eacute;viter         cela:         le         descripteur
<code><b>const</b></code>,  plac&eacute; devant  la  d&eacute;claration du
param&egrave;tre,   assure   que  celui-ci   <em>ne   pourra  pas</em>   &ecirc;tre
modifi&eacute; par la fonction. Ainsi, le programme suivant ne pourra pas &ecirc;tre compil&eacute;:</p>

<pre class="demo">
void f( const int&amp; X) {
   <b>X=0;</b>          // Erreur, car X est constant
};
</pre>

<h5><a name="ptr-prm">Passage des param&egrave;tres par pointeur</a></h5>

<p>Les  possibilit&eacute;s   offertes  par  le  passage  de
param&egrave;tres  par  r&eacute;f&eacute;rence  rendent  obsol&egrave;te l'&eacute;quivalent  en  C:  le
passage   des  param&egrave;tres   par  pointeurs.   Voici   deux  programmes
&eacute;quivalents, &agrave; vous de d&eacute;cider lequel est le plus lisible:</p>

<p><b>En C:</b></p>

<pre class="demo">
void f(<b>int* X</b>) {
   <b>*X=0;</b>
};

main() {
   int A=5;
   <b>f(&amp;A);</b>
};
</pre>

<p><b>En C++:</b></p>

<pre class="demo">
void f(<b>int&amp; X</b>) {
   <b>X=0;</b>
};

main() {
   int A=5;
   <b>f(A);</b>
};
</pre>


<p> Le programme C++ est bien plus lisible, ne
serait-ce  que parce  que  c'est lui  qui  minimise l'utilisation  des
signes  barbares  tels   que  <code>&amp;</code>  ou  <code>*</code>.</p>


<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" /> Il n'est  utile de passer les param&egrave;tres par
pointeur <em>que si le cas pointeur=NULL</em> doit &ecirc;tre envisag&eacute;:</p>

<pre class="demo">
void f( int* X) {
   if (X == NULL) {
      ...faire quelque chose
   } else {
      ...faire autre chose
   };
};
</pre>

<p>Il n'est  pas possible  de g&eacute;rer  ce cas  avec des
r&eacute;f&eacute;rences,   puisqu'une  r&eacute;f&eacute;rence   n'est   par  d&eacute;finition   "synonyme" de quelque chose.</p></div>

<div class="attention"> <p> <img  alt="ATTENTION" src="attention.gif" /> Une  fonction prenant  des param&egrave;tres
par   <code>const   &amp;</code>    ne   <em>doit   jamais   renvoyer   ce
param&egrave;tre</em>...  il y a risque important de crash. Exemple:</p>

<pre class="demo">
const int&amp; f(<b>const int&amp; x</b>) {
  <b>return x;</b>
};

main() {
  int A = 10;
  int B = f(A);
  int C = f(4);
};
</pre>   

 <p>La  ligne <code>int B  = f(A)</code> ne pose  pas de
probl&egrave;me, par  contre que  se passe-t-il avec  la ligne <code>int  C =
f(4)</code>  ?  Le compilateur  cr&eacute;e une  variable temporaire  de type
entier,  l'initialise  &agrave; 4,  appelle  la  fonction <code>f</code>  qui
renverra une r&eacute;f&eacute;rence &agrave;  cette variable temporaire... et <em>supprime
juste  apr&egrave;s la  variable temporaire</em>.   R&eacute;sultat, on  se retrouve
avec une r&eacute;f&eacute;rence  qui pointe sur...  rien du  tout, risque important
de plantages.  Voir ci-dessous (chapitre gestion de la m&eacute;moire)  d'autres exemples de gags 
du m&ecirc;me genre <a href="mem.html"><img  alt="apres" src="apres.gif" /></a></p></div>

<h4><a name="const-ptr">Utilisation de const avec des pointeurs</a></h4>

<p>Le descripteur <code>const</code>  peut s'employer
&eacute;galement   avec  des   pointeurs,  de   sorte  que   les  diff&eacute;rentes
d&eacute;clarations ci-dessous sont  l&eacute;gales, et emp&ecirc;chent d'&eacute;crire certaines
instructions... donc emp&ecirc;chent de faire certaines erreurs:</p>

<pre class="demo">
<b>const</b> int* a      = new(int);
<b>*</b>a = 10;                        // Erreur car *a est constant
int* <b>const</b> b      = new(int);
b = <b>new</b>(int);                   // Erreur car b est constant
<b>const</b> int* <b>const</b> c = new(int);
<b>*</b>c = 10;                        // Erreur car *c est constant
c  = <b>new</b>(int);                  // Erreur car c est constant
</pre>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
L'expression <code><b>const  int* a</b></code>  <em>ne garantit
 pas</em> que <code><b>*a</b></code> ne changera jamais
de valeur.   Il garantit <em>uniquement</em> qu'il  sera impossible de
taper         quelque        chose        dans         le        style
<code><b>*a=10</b></code>. Mais le code suivant montre qu'il
est parfaitement  possible que <b><code>*a</code></b> change
de valeur.   Il suffit pour  cela qu'un autre pointeur,  non constant,
soit d&eacute;fini avec la m&ecirc;me adresse:</p>

<pre class="demo">
int A=10;
const int* a = &amp;A;
cout &lt;&lt; "*a = " &lt;&lt; *a &lt;&lt; "\n";
A=100;
cout &lt;&lt; "*a = " &lt;&lt; *a &lt;&lt; "\n";
</pre></div>

<p><a href="#">top</a></p><hr />

<h2><a name="class">Le type class</a></h2>

<p>Le type class va nous permettre de cr&eacute;er diff&eacute;rents objets. C'est donc gr&acirc;ce &agrave; 
ce type qu'il est possible de faire de la programmation objets en C++.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Attention,  une  d&eacute;claration  de  classe  est  une
<em>d&eacute;claration de type</em>. Or,  un objet est <em>une variable</em>.
Une  classe  va permettre  de  cr&eacute;er  (on dit aussi instancier)  des objets  d'un
certain type.   En d'autres termes, une classe  est un <em>moule</em>,
elle  sert   &agrave;  cr&eacute;er  des   objets, mais  elle  n'est  pas   un  objet
elle-m&ecirc;me.</p></div>

<h3><a name="priv-prot-pub">Sections priv&eacute;es, prot&eacute;g&eacute;es, publiques</a></h3>

<p>Voici  la d&eacute;claration d'une  classe qui impl&eacute;mente
des nombres complexes:</p>

<pre class="demo">
class complexe {
<b>public:</b>
   void init(float x, float y);
   void copie(const complexe&amp; y);
<b>private:</b>
   float r;
   float i;
}   
</pre>

<p>Il s'agit  d'une d&eacute;claration  tr&egrave;s proche  du type
<code>struct</code>    du   C.   Cependant,    par   rapport    &agrave;   la
<code>struct</code> du C, plusieurs diff&eacute;rences fondamentales:</p>

<ul>
  <li>Certains membres sont des fonctions</li>
  <li>On peut d&eacute;clarer des membres qui sont eux-m&ecirc;mes des types  <a
      href="stdlib.html#localtype"><img  alt="apres" src="apres.gif" /></a>
      (on parle alors de types locaux).</li>  
  <li>Les membres sont d&eacute;clar&eacute;s dans diff&eacute;rentes sections avec des
      notions de protection par rapport &agrave; l'ext&eacute;rieur</li>
</ul>

<p>On  retrouve  ainsi la  notion  de  protection
(encapsulation)   des  variables   et  des   fonctions  propre   &agrave;  la
programmation  structur&eacute;e,   mais  int&eacute;gr&eacute;e  au   syst&egrave;me  de  typage,
puisqu'il  s'agit de  d&eacute;clarer un  nouveau  type de  donn&eacute;es.  Ce  qui
correspond   &agrave;   l'impl&eacute;mentation    se   trouve   dans   la   section
<code>private</code>,  alors que  ce qui  correspond &agrave;  l'interface se
trouve  dans  la  section  <code>public</code>.  En  d'autres  termes,
l'int&eacute;rieur  de l'objet  (son  squelette) se  trouve  dans la  section
<code>private</code>,  alors que l'interface  avec le  monde ext&eacute;rieur
(les boutons, voyants,  en un mot son comportement)  se trouve dans la
section <code>public</code>.</p>

<h4><a name="priv">Section private</a></h4>

<p>Tout ce qui  est d&eacute;clar&eacute;  dans cette  section sera
utilisable <em>uniquement</em> (ou  presque, il y a aussi  les amis <a
href="#fct-amies"><img alt="apres"  src="apres.gif" /></a>) &agrave;
partir d'une variable de m&ecirc;me classe; ainsi, dans l'exemple ci-dessus,
le code:</p>

<pre class="demo">
complexe X;
...
<b>X.r=0;</b>
<b>X.i=0;</b>
</pre>

<p>produira   une  erreur   &agrave;   la  compilation,   car
<code>r</code> et <code>i</code> &eacute;tant des membres priv&eacute;s, ils ne sont
pas   accessibles  &agrave;   partir  "de   l'ext&eacute;rieur".   Par   contre,  si
<code>X</code> et  <code>Y</code> sont  deux complexes, le  code &eacute;crit
<em>dans  les  fonctions-membres   de  la  classe  complexe</em>  peut
atteindre les variables priv&eacute;es <em>de toutes les variables de type
complexe</em>,   ainsi  qu'on  le   voit  dans   l'exemple  ci-dessous
(fonctions <code>init</code> et <code>copie</code>):</p>

<pre class="demo">
class complexe {
public:
   void init(float x, float y) {r=x;   i=y;};
   void copie(const complexe&amp; y)  {r=y.r; i=y.i;};
<b>private:</b>
   float r;
   float i;
}   
</pre>

<h4><a name="priv-nota">Notations</a></h4>

<p>La  fonction  <code>init</code> acc&egrave;de  aux  membres
priv&eacute;s  de la  variable  elle-m&ecirc;me.  Dans  ce  cas, il  suffit de  les
appeler par  leur nom de  membre (il ne  peut y avoir  d'ambiguit&eacute;) et
l'expression <code>r=x</code>  signifie "affecter la  partie r&eacute;elle de
ce complexe &agrave; la valeur pass&eacute;e par param&egrave;tre".</p>

<p>La  fonction <code>copie</code> acc&egrave;de  aux membres
priv&eacute;s de  la variable, mais <code>aussi</code> aux  membres priv&eacute;s du
complexe y. Dans ce cas, il  faut sp&eacute;cifier le nom de variable en plus
du nom de champ, d'o&ugrave; l'expression <code>y.r</code></p>

<h3><a name="pub">Section public</a></h3>

<p>Tout ce  qui  est d&eacute;clar&eacute;  dans  cette section  sera
utilisable  depuis l'ext&eacute;rieur de l'objet.  Ainsi,  dans l'exemple  pr&eacute;c&eacute;dent les
fonctions   <code>init</code>  et   <code>copie</code>   peuvent  &ecirc;tre
appel&eacute;es depuis le programme principal:</p>

<pre class="demo">
complexe X;
...
X.init(0,0);
</pre>

<h3><a name="prot">Section protected</a></h3>

<p>Cette section sera  d&eacute;crite plus tard, lorsque nous
aborderons l'h&eacute;ritage  <a  href="heritage.html"><img
alt="apres" src="apres.gif" /></a>.</p>

<h3><a name="fct-memb">Fonctions membres </a></h3>

<p>Les membres  d'une  <code>class</code> peuvent  &ecirc;tre
soit des types, soit des variables, soit des  fonctions. Dans ce
dernier cas, on parle de fonctions membres, ou encore de m&eacute;thodes.</p>

<h4><a name="def-fct-memb">D&eacute;finition des fonctions-membres</a></h4>

<p>Dans  l'exemple  pr&eacute;c&eacute;dent,  nous avons  d&eacute;clar&eacute;  et
d&eacute;fini les  deux fonctions-membres  &agrave; l'int&eacute;rieur de  l'objet lui-m&ecirc;me
(voir   plus  loin   <a   href="surch.html#decl-def"><img  alt="apres"
src="apres.gif" /></a> la  diff&eacute;rence  entre d&eacute;claration  et
d&eacute;finition).  Cela offre deux avantages:</p>

<ul>
  <li>Code plus compact et plus lisible pour de petites fonctions</li>
  <li>Rapidit&eacute; d'ex&eacute;cution plus importante, car la fonction est ainsi
      d&eacute;clar&eacute;e implicitement <em>inline</em>, ce qui veut dire que le
      compilateur mettra directement les instructions dans le code, en
      &eacute;vitant ainsi la perte de temps d&ucirc;e aux appels de fonctions.</li>
</ul>

<p>Toutefois, cela est difficilement concevable pour des
fonctions plus longues. Dans ce cas,  on ne met dans la d&eacute;claration de
classe que la  d&eacute;claration de la fonction, sa  d&eacute;finition viendra plus
tard...  oui,  mais alors il  faudra bien sp&eacute;cifier  l'appartenance de
cette fonction &agrave;  une classe donn&eacute;e. Cela se  fait avec  l'op&eacute;rateur 
de  port&eacute;e <code>::</code> (Voir ci-dessous les exemples).</p>

<h3><a name="fct-amies">Fonctions et classes amies</a></h3>

<p>Il  est possible de donner l'acc&egrave;s  aux membres
priv&eacute;s et  prot&eacute;g&eacute;s de  la classe &agrave;  certaines fonctions  d&eacute;finies par
ailleurs dans le programme, ou &agrave; <em>toutes</em> les fonctions membres
d'une autre classe: il suffit de d&eacute;clarer ces fonctions ou ces classes
dans la section <code>public</code> (il s'agit d'une  fonctionnalit&eacute; de l'interface)  en ajoutant
devant la d&eacute;finition de  fonction le mot-cl&eacute; <code>friend</code>. Nous
reparlerons des fonctions amies lors de la discussion sur la surcharge
des    op&eacute;rateurs   <a    href="surch.html#ope-ami"><img   alt="apres"
src="apres.gif" /></a></p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Une fonction-membre d'une classe a acc&egrave;s aux
donn&eacute;es priv&eacute;es 
<i>de tous les objets de sa classe</i>. Cela revient &agrave; dire que
l'unit&eacute; de protection  
n'est pas l'objet, mais <i>la classe</i>. Et la notion de fonction
amie, et surtout de classe amie 
permet encore d'&eacute;largir cette notion de protection au "groupe de
classes".  On peut se poser la question suivante: n'y a-t-il pas
contradiction entre l'encapsulation des  donn&eacute;es d'une part  et cette
notion d'amies  d'autre part&nbsp;? 
Bien  &eacute;videmment  si: &agrave;  manier  avec  pr&eacute;caution...  toutefois,  dans
certains cas,  il est utile  de d&eacute;clarer des classes  amies: certaines
"abstractions" ne  sont pas n&eacute;cessairement impl&eacute;ment&eacute;es  par une seule
classe,  mais  par  deux  ou  plusieurs  classes.  Dans  ce  cas,  les
diff&eacute;rentes  classes  participant &agrave;  cette  abstraction devront  avoir
acc&egrave;s aux  m&ecirc;mes donn&eacute;es priv&eacute;es...   sans quoi nous  devrons enrichir
l'interface   de   mani&egrave;re    exag&eacute;r&eacute;e,   au   risque   justement   de
<em>casser</em> le processus d'encapsulation.</p></div>

<h3><a name="acces-donn">Acc&egrave;s aux donn&eacute;es</a></h3>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
Dans  chaque section, on peut trouver  des types, des
variables, ou des fonctions.  Cependant, m&ecirc;me si le langage 
ne  l'impose  pas,  il  est   pr&eacute;f&eacute;rable  de  s'en  tenir  aux  usages
suivants:</p>

<ul>
  <li>Les types (&eacute;num&eacute;rations notamment) peuvent &ecirc;tre d&eacute;finis aussi
      bien dans la section  <code>public</code> que dans la section
      <code>private</code>.</li> 
  <li>Les   variables ne seront d&eacute;finies  <em>que</em>   dans   la  section
      <code>private</code>: en effet, les variables jouent en quelque
      sorte le r&ocirc;le de squelette de l'objet, elles d&eacute;finissent sa
      <em>structure interne</em></li>
  <li>Les fonctions peuvent &ecirc;tre d&eacute;finies aussi bien dans la section
      <code>private</code> que dans la section <code>public</code>.
      <ul>
	<li>Dans la section <code>private</code>, on trouvera les
	    fonctions qui participent au <em>fonctionnement
	    interne</em> de l'objet.</li>
	<li>Dans la section <code>public</code>, on trouvera les
	    <em>fonctions d'interface</em>. En particulier, on
	    trouvera des fonctions permettant de modifier les
	    variables priv&eacute;es (<em>mutator</em>), ou encore des
	    fonctions permettant de lire la valeur de ces variables
	    (<em>accessor</em>). Le fait de passer par des fonctions
	    pour ces op&eacute;rations, plut&ocirc;t que de d&eacute;clarer simplement la
	    variable dans la section <code>public</code>, offre une
	    tr&egrave;s grande souplesse, car les fonctions membres peuvent
	    parfaitement faire autre chose, en interne, que de
	    simplement &eacute;crire ou lire une variable.</li>
      </ul></li>
</ul></div>

<p>Cela permettra  donc de  contr&ocirc;ler  tr&egrave;s pr&eacute;cis&eacute;ment
l'acc&egrave;s aux donn&eacute;es. La contrepartie  &eacute;tant, bien s&ucirc;r, une plus grande
lourdeur,  puisqu'il y  a  plus  de fonctions  &agrave;  &eacute;crire. Notre  objet
<code>complexe</code> pourrait devenir:</p>

<pre class="demo">
class complexe {
public:
   <b>void init(float x, float y)</b> {r=x;   i=y; _calc_module();};
   <b>copie(const complexe&amp; y)</b>  {r=y.r; i=y.i; m=y.m;};
   <b>float get_r()</b> { return r;};
   <b>float get_i()</b> { return i;};
   <b>void set_r(float x)</b> { r=x; _calc_module();};
   <b>void set_i(float x)</b> { i=x; _calc_module();};
   <b>float get_m()</b> {return m;};
private:
   float r;
   float i;
   float m;
   float _calc_module();
}

float complexe::_calc_module() {
    m = sqrt(r*r + i*i);
}
</pre>

<p>Nous   venons   d'introduire  un   nouveau   champ:
<code>m</code>,    qui   repr&eacute;sente    le    module.    La    fonction
<code>_calc_module</code>    est   une   fonction    priv&eacute;e,   appel&eacute;e
automatiquement d&egrave;s  que la partie  r&eacute;elle ou la partie  imaginaire du
complexe  est  modifi&eacute;e. Ainsi,  les  fonctions <code>set_r</code>  et
<code>set_i</code>    modifient   les    champs    <code>r</code>   et
<code>i</code> de  notre objet,  mais elles font  <em>aussi</em> autre
chose: elles lancent le calcul du module. Il ne serait pas possible
d'impl&eacute;menter   ce   type   de   fonctionnement  en   utilisant   pour
<code>r</code> et  <code>i</code> des champs publics. Le  prix &agrave; payer
est   toutefois    l'existence   des   fonctions   <code>get_r</code>,
<code>get_i</code>  et <code>get_m</code>,  qui sont  triviales. Etant
d&eacute;clar&eacute;es  <code>inline</code>  dans  le  corps  de  l'objet,  elles
ne  causeront 
cependant  pas  de perte  de  performance.<br />  Par  ailleurs, il  est
&eacute;vident que le champ  <code>m</code> ne <em>doit pas</em> &ecirc;tre public:
en effet, si tel &eacute;tait le cas, le code suivant:</p>

<pre class="demo">
complexe X;
X.init(5,5);
<b>X.m=2;</b>
</pre>

<p>serait   autoris&eacute;    par   le compilateur, avec  un r&eacute;sultat  d&eacute;sastreux
 (aucune coh&eacute;rence  dans les champs de l'objet). On peut  bien  s&ucirc;r  se demander  s'il  est utile  de
programmer un objet  complexe de cette mani&egrave;re. Apr&egrave;s  tout, il serait
aussi simple de  lancer le calcul  du module directement  dans la
fonction <code>get_m</code>... bien s&ucirc;r, mais cette  mani&egrave;re de faire
pr&eacute;sente certains avantages:</p>

<ul>
  <li>L'objet <code>complexe</code> ainsi d&eacute;fini est
      coh&eacute;rent, puisqu'on est assur&eacute; que le module, maintenu par
      l'objet lui-m&ecirc;me, sera toujours correct. Et la variable
      <code>m</code> peut &ecirc;tre utilis&eacute;e par d'autres
      fonctions membres, puisque l'on est s&ucirc;r qu'elle est en
      permanence &agrave; jour.</li>
  <li>Supposons un programme qui initialise de temps en temps des
      complexes, mais qui passe son temps &agrave; utiliser le module des
      complexes dans d'autres calculs: cet objet se r&eacute;v&egrave;lera tr&egrave;s
      performant, puisque le calcul du module ne sera effectu&eacute; que lors
      de l'initialisation. Cet argument, peut &ecirc;tre tr&egrave;s fort lorsqu'il
      s'agit de calculs co&ucirc;teux en ressources.</li>
</ul>

<p>Mais peut-&ecirc;tre  qu'au cours  du  d&eacute;veloppement, nous
allons justement  nous apercevoir que  le programme passe son  temps &agrave;
initialiser  des complexes, et  n'utilise le  calcul du  module qu'une
fois de temps  en temps.  Dans ce cas, l'argument  ci-dessus se renverse,
et cette impl&eacute;mentation conduit &agrave;  un objet peu performant.  Qu'&agrave; cela
ne tienne, nous allons r&eacute;&eacute;crire l'objet <em>complexe</em>:</p>

<pre class="demo">
class complexe {
public:
   <b>void init(float x, float y)</b> {r=x;   i=y;};
   <b>copie(const complexe&amp; y)</b>  {r=y.r; i=y.i;};
   <b>float get_r()</b> { return r;};
   <b>float get_i()</b> { return i;};
   <b>void set_r(float x)</b> { r=x;};
   <b>void set_i(float x)</b> { i=x;};
   <b>float get_m()</b> {return sqrt(r*r+i*i);};
private:
   float r;
   float i;
}
</pre>

<p>Le nouveau  <code>complexe</code> est plus simple que
le  pr&eacute;c&eacute;dent, il  calcule  le  module uniquement  lorsque  l'on en  a
besoin:  il   n'est  donc  plus  n&eacute;cessaire  de   maintenir  le  champ
<code>m</code>.<br /> Par contre,  il a un autre d&eacute;faut:  &agrave; chaque appel
de <code>get_m()</code>, le module est recalcul&eacute;, ce qui peut s'av&eacute;rer co&ucirc;teux  si les  appels &agrave;  cette fonction  sont nombreux.   La version suivante de <code>complexe</code> r&eacute;soudra ce probl&egrave;me.  Le module est calcul&eacute;  <em>uniquement</em> en  cas de  besoin, c'est-&agrave;-dire  non pas lors     de    <em>chaque</em>    appel     &agrave;    <code>get_m()</code>, <em>uniquement</em>  lors  du  premier  appel  &agrave;  <code>get_m()</code> suivant une  modification du module.  Voici le code, qui  se complique un peu:</p>

<pre class="demo">
class complexe {
public:
  <b>void init(float x, float y)</b> {r=x; i=y; m=0; m_flg=false;};
  <b>void copie(const complexe&amp; y )</b>  {r=y.r; i=y.i; m=y.m;};
  <b>float get_r()</b> { return r;};
  <b>float get_i()</b> { return i;};
  <b>void set_r(float x)</b> { r=x; m_flg=false;};
  <b>void set_i(float x)</b> { i=x; m_flg=false;};
  <b>float get_m();</b>
private:
  float r;
  float i;
  <b>bool m_flg;</b>
  float m;
  void _calc_module() {m=sqrt(r*r+i*i);};
};

float complexe::get_m() {
  if (!m_flg) {
    _calc_module();
    m_flg=true;
  };
  return m;
};
</pre>

<p>Ce qui  est remarquable,  c'est que  dans  ces trois
versions,  <em>seule l'impl&eacute;mentation  a chang&eacute;</em>.   Autrement dit,
tout le code qui  <em>utilise</em> cet objet restera identique.  C'est
tr&egrave;s important,  car ce code  est peut-&ecirc;tre gros, peut-&ecirc;tre  &eacute;crit par
d'autres  personnes,  etc.  D'o&ugrave;  l'importance  de <em>bien  sp&eacute;cifier
l'interface</em>,  et  de  ne  mettre  dans  l'interface  <em>que  des
fonctions</em>:  une  fonction  triviale   un  jour  peut  se  r&eacute;v&eacute;ler
compliqu&eacute;e le  lendemain, si son interface  est la m&ecirc;me  le passage de
l'une &agrave;  l'autre sera indolore.  Passer  d'une op&eacute;ration d'affectation
de membre  &agrave; un  appel de fonction  (ou r&eacute;ciproquement) est  une autre
histoire...  Cet argument de maintenabilit&eacute; du code vaut largement que
l'on  &eacute;crive  des  fonctions  triviales  comme  <code>get_r</code>  ou
<code>get_i</code>...</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
 Il   ne   faut   pas   abuser   des   fonctions
<code>get_xxx</code> et <code>set_xxx</code>: en effet, attention &agrave; ne
donner ainsi l'acc&egrave;s <em>qu'&agrave; certains membres</em> priv&eacute;s. Sans cela,
donner un  acc&egrave;s, m&ecirc;me  r&eacute;duit, &agrave; tous  les membres priv&eacute;s,  risque de
vous  conduire &agrave;  nier la  notion d'encapsulation  des donn&eacute;es,  et de
rendre probl&eacute;matique l'&eacute;volution de l'objet.</p></div>

<h3><a name="construct">Constructeurs</a></h3>

<p>Nous avons dit pr&eacute;c&eacute;demment que les types d&eacute;finis par
l'utilisateur devaient se comporter  "presque" comme les types de base
du langage. Cela  est loin d'&ecirc;tre vrai pour ce qui  est de notre objet
<code>complexe</code>: par exemple, pour d&eacute;clarer une variable r&eacute;elle,
nous  pouvons  &eacute;crire   <code>float  X=2;</code>  Comment  faire  pour
d&eacute;clarer un objet complexe, tout  en l'initialisant &agrave; la valeur (2,0),
par exemple ? Actuellement, nous devons &eacute;crire:</p>

<pre class="demo">
complexe X;
X.init(2,0);
</pre>

<p>Ce n'est  pas g&eacute;nial... d'une part le  code est assez
diff&eacute;rent de ce  qu'il est pour initialiser des  r&eacute;els ou des entiers,
mais surtout que se passe-t-il  si nous oublions d'appeler la fonction
init   ?  Cet   oubli   est  possible,   justement  parce   que
l'initialisation   du  <code>complexe</code>   se   fait  de   mani&egrave;re
diff&eacute;rente des  autres types.<br /> C'est pour r&eacute;soudre  ce probl&egrave;me que
le  C++   propose  une  fonction  membre sp&eacute;ciale,  appel&eacute;e
constructeur. Le constructeur poss&egrave;de deux sp&eacute;cificit&eacute;s:</p>

<ul>
  <li>Le nom est impos&eacute; (m&ecirc;me nom que le nom de la classe).</li>
  <li>Il ne renvoie aucune valeur.</li>
</ul>

<pre class="demo">
class complexe {
public:
  <b>complexe(float x, float y):r(x),i(y),m(0),m_flg(false) {};</b> 
  void copie(const complexe&amp; y )  {r=y.r; i=y.i; m=y.m;};
  float get_r() { return r;};
  float get_i() { return i;};
  void set_r(float x) { r=x; m_flg=false;};
  void set_i(float x) { i=x; m_flg=false;};
  float get_m() const;
private:
  float r;
  float i;
  bool m_flg;
  float m;
  void _calc_module() {m=sqrt(r*r+i*i);};
};
</pre>

<p>Rien   n'a    chang&eacute;,   &agrave;    part    la   fonction
<code>init</code>,       remplac&eacute;e      par       le      constructeur
(<code>complexe</code>).  Mais cela  change tout:  en effet, on peut maintenant  
&eacute;crire dans  le  programme  utilisateur de  la classe:</p>

<pre class="demo">
float A = 5;
...
<b>complexe X(2,0);</b>
</pre>

<p>On voit qu'on a une d&eacute;claration "presque" &eacute;quivalente
&agrave;  ce  qu'on  a  avec   un  type  pr&eacute;d&eacute;fini.  La  diff&eacute;rence  provient
<em>uniquement</em>  de ce que  nous avons  besoin de  deux param&egrave;tres
pour initialiser un complexe, et non  pas un seul comme pour un entier
ou un r&eacute;el. Mais nous verrons au paragraphe suivant qu'il y a moyen de
faire encore mieux.</p>

<h4><a name="construct-predef">Constructeur pr&eacute;d&eacute;fini</a></h4>

<p>En  fait, il n'est pas indispensable  de d&eacute;finir un
constructeur:  si l'on supprime  le constructeur  de la  d&eacute;finition de
classe pr&eacute;c&eacute;dente, le programme  compilera toujours. Simplement, il ne
sera  pas possible d'initialiser  explicitement l'objet.   En d'autres
termes,  l'expression  <code>complexe   X;</code>  sera  valide,  mais
l'expression   <code>complexe  X(0,0)</code>   sera  refus&eacute;e   par  le
compilateur.  Le compilateur  appellera simplement le constructeur par
d&eacute;faut  de l'objet... Attention toutefois, celui-ci n'initialisera pas les membres de l'objet.</p>

 <div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
 Le (ou les, cf. plus loin)
constructeurs d&eacute;finis pas l'utilisateur ne s'ajoutent pas au
constructeur par d&eacute;faut, ils le <em>remplacent</em>. Autrement dit,
nous avons le choix entre:</p>

<ul>
  <li>Une classe <code>complexe</code> sans constructeur. Dans ce cas,
      l'expression <code>complexe C;</code> sera accept&eacute;e, mais
      l'expression <code>complexe&nbsp;C(0,0);</code> sera refus&eacute;e.</li>
  <li>Une classe <code>complexe</code> avec constructeur, telle que
      d&eacute;finie ci-dessus. Dans ce cas, l'expression <code>complexe&nbsp;C;</code> 
      sera refus&eacute;e, mais l'expression <code>complexe&nbsp;C(0,0)</code> sera accept&eacute;e.</li>
</ul>

<p>Bien  s&ucirc;r, il  y a  moyen de  d&eacute;passer ces  limitations,  nous verrons comment  un   peu  plus  tard   <a href="surch.html#valdef-construc"><img alt="apres" src="apres.gif" /></a>.</p>
</div>
 <div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
 Si vous d&eacute;finissez votre constructeur par d&eacute;faut, attention &agrave; bien initialiser <em>tous</em> les membres de votre objet: le constructeur par d&eacute;faut du syst&egrave;me est compl&egrave;tement d&eacute;sactiv&eacute;, vous devez tout initialiser explicitement.</p></div>
 
<h4><a name="init-memb">Initialisation des membres</a></h4>

<p>Le constructeur est le lieu id&eacute;al pour faire deux choses:</p>

<ul>
  <li>Initialiser les donn&eacute;es membres</li>
  <li>Allouer des ressources (m&eacute;moire en particulier, mais aussi
      &eacute;ventuellement ouverture d'une connexion r&eacute;seau, cr&eacute;ation d'un
      fichier, etc).</li>
</ul>

<p>En  fait, ces  deux  actions  sont diff&eacute;rentes.   Il
existe une  syntaxe particuli&egrave;re, permettant  de mettre en  valeur ces
diff&eacute;rences: l'initialisation des membres peut se faire <em>avant</em>
le bloc de d&eacute;finition de la fonction constructeur, mais <em>apr&egrave;s</em>
le nom de la fonction, comme on le voit dans le code suivant:</p>

<pre class="demo">
class complexe {
private:
   float r;
   float i;
   ...
public:
   <b>complexe(float x, float y) : r(x), i(y), m(0), m_flg(false) { };</b> 
   ...
}
</pre>

<p>Cette mani&egrave;re de  proc&eacute;der est int&eacute;ressante, car elle
s&eacute;pare  proprement les deux  fonctions du  constructeur: initalisation
des membres  d'une part, ex&eacute;cution de  code (allocation
de m&eacute;moire  ou autre ressource)  d'autre part. S'il n'y a rien d'autre &agrave; faire
que des initialistations, le corps de la fonction peut &ecirc;tre vide: dans ce cas, on doit &eacute;crire
des accolades vides <code>{}</code> &agrave; la suite de la liste d'initialisation. </p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />Lorsqu'un membre est d&eacute;clar&eacute; en tant
que r&eacute;f&eacute;rence, la <em>seule mani&egrave;re</em> de l'initialiser est de passer par la liste d'initialisation:</p>

<pre class="demo">
class objet {
private:
   <b>complexe&amp; X;</b>
   ...
public:
   <b>object (const complexe&amp; C) : X(C) {};</b>
};
</pre></div>

<h3><a name="destruct">Destructeur</a></h3>

<p>Nous  avons vu qu'une fonction,  le constructeur, est
appel&eacute;e  lors de  la  cr&eacute;ation de  la  variable.  De  m&ecirc;me, une  autre
fonction, le <em>destructeur,</em> est appel&eacute;e lors de sa destruction.
Le destructeur poss&egrave;de les sp&eacute;cificit&eacute;s suivantes:</p>

<ul>
  <li>Le nom est impos&eacute; (caract&egrave;re ~ suivi du nom de la classe)</li>
  <li>Il ne renvoie rien.</li>
  <li>Il ne prend pas de param&egrave;tre</li>
</ul>

<p>Un des  r&ocirc;les  du constructeur  est  de demander  au
syst&egrave;me  certaines ressources: fichier, m&eacute;moire,  etc.   Il faut
bien un jour rendre la ressource au syst&egrave;me, c'est pr&eacute;cis&eacute;ment le r&ocirc;le
du destructeur: fermeture de fichier, lib&eacute;ration de m&eacute;moire,...</p>

<h4><a name="compl-debug">Le type complexe en mode debug</a></h4>

<p>A titre  d'exemple pour l'utilisation du constructeur
et  du destructeur,  nous allons  adjoindre un  syst&egrave;me de  d&eacute;bogage &agrave;
notre objet  <code>complexe</code>: le constructeur  &eacute;crira un message
sur  l'erreur standard,  tandis  que le  destructeur  &eacute;crira un  autre
message.   Ainsi, m&ecirc;me  dans le  code le  plus compliqu&eacute;,  nous aurons
toujours  une  trace  de  la  cr&eacute;ation  ou de  la  destruction  de  la
variable. Cela pourrait s'&eacute;crire de la mani&egrave;re suivante:</p>

<pre class="demo">
class complexe {
public:
   <b>complexe(float x, float y);
   ~complexe();</b>
   ...
private:
   ...
}

<b>complexe::complexe(float x, float y):r(x),i(y),m_flg(false) {
   cerr &lt;&lt; "Creation d'un objet de type complexe\n";
}</b>

<b>~complexe::complexe()</b> {
   cerr &lt;&lt; "Destruction d'un objet de type complexe\n";
}

main() {
   ...
   if (...) {
      <b>complexe A(0,0);</b>   // Appel du constructeur
      ...
   };                                     // Appel du destructeur
</pre>

<p>A  l'ex&eacute;cution, ce  programme enverra un  message sur
l'erreur standard  d&egrave;s que l'instruction  <code>complex A(0,0);</code>
sera  ex&eacute;cut&eacute;e  (c'est-&agrave;-dire &agrave;  l'entr&eacute;e  du  <code>if</code>), et  &agrave;
nouveau lors de la destruction  de la m&ecirc;me variable, c'est-&agrave;-dire lors
du passage sur l'accolade  fermante (<code><b>}</b></code>) (fin de la
port&eacute;e de la variable).</p>

<h3><a name="static">Le descripteur <code>static</code></a></h3>

<p>Le  code ci-dessus envoie  un message lors  de chaque
appel  du constructeur  et du  destructeur.  Cela  peut &ecirc;tre  une aide
pr&eacute;cieuse  lors de  la  mise au  point  du programme,  mais il  serait
souhaitable de pouvoir inhiber ce fonctionnement: lorsque
le  programme sera  mis en  exploitation,  le mode  debug n'aura  plus
aucune  raison d'&ecirc;tre.   M&ecirc;me en  p&eacute;riode de  d&eacute;boguage,  nous voulons
avoir la possibilit&eacute; de passer  ponctuellement en mode d&eacute;bug, ou de le
d&eacute;sactiver. Voici un premier essai:</p>

<pre class="demo">
class complexe {
public:
   complexe(float x, float y): r(x),i(y),m_flg(false),<b>debflg(false)</b> {};
   ~complexe();
   <b>void set_debug() { debflg=true;};
   void clr_debug() { debflg=false;};</b>
   ...
private:
   ...
   <b>bool debflg=false;</b>
}

complexe::complexe(float x, float y) {
   ...
   <b>if (debflg) {cerr &lt;&lt; "Creation d'un objet de type complexe\n";};</b>
}

~complexe::complexe() {
   <b>if (debflg) {cerr &lt;&lt; "Destruction d'un objet de type complexe\n";};</b>
}
</pre>

<p>Ce code nous pose deux probl&egrave;mes:</p>

<ol>
  <li>Le constructeur n'enverra jamais de message: en effet,
      <code>debflg</code> est false par d&eacute;faut, et l'objet aura d&eacute;j&agrave; &eacute;t&eacute;
      cr&eacute;&eacute;, donc le constructeur aura d&eacute;j&agrave; &eacute;t&eacute; appel&eacute; lorsque nous
      serons en mesure d'appeler la fonction <code>set_debug</code>.</li>
  <li>Il serait fastidieux... et pour tout dire sujet &agrave; bien des
      erreurs, d'appeler <code>set_debug</code> ou
      <code>clr_debug</code> pour chaque objet, de mani&egrave;re
      individuelle. Nous avons besoin au contraire d'un membre et
      d'une fonction-membre qui puisse contr&ocirc;ler le mode debug
      simultan&eacute;ment pour <em>tous</em> les objets <code>complexe</code>.</li>
</ol>

<h4><a name="static-memb">Une donn&eacute;e membre statique</a></h4>

<p>La d&eacute;claration suivante r&eacute;sout une partie de notre probl&egrave;me:</p>

<pre class="demo">
class complexe {
public:
   complexe(float x, float y): r(x),i(y),m_flg(false) {};
private:
   ...
   <b>static</b> bool debflg;
}
</pre>

<p>Le   descripteur  <code>static</code>  signifie  que
<code>debflg</code> est un membre <em>commun &agrave; tous les objets de type
<code>complexe</code></em>:   alors  qu'un   membre   "ordinaire"  est
sp&eacute;cifique &agrave; chaque <em>objet</em>, un membre statique sera sp&eacute;cifique
&agrave; chaque  <em>classe d'objet</em>. Du point-de-vue  de l'allocation 
m&eacute;moire, on peut consid&eacute;rer qu'il s'agit d'une r&eacute;f&eacute;rence &agrave; une z&ocirc;ne de
m&eacute;moire allou&eacute;e ailleurs. Du coup:</p>

<ul>
  <li>la d&eacute;claration <code>static bool debflg</code> ne provoquera pas
      de nouvelle allocation m&eacute;moire</li>
  <li>il est interdit d'initialiser ce  membre comme on le ferait avec
      un  membre  ordinaire.</li>
</ul>

<p>Cette  seconde  restriction est  compr&eacute;hensible;  en
effet,  un initialisateur  pos&eacute;  au m&ecirc;me  endroit  que la  d&eacute;claration
aurait  pour  cons&eacute;quence la  r&eacute;initialisation  du  membre statique  &agrave;
chaque cr&eacute;ation de  variable de type complexe.  Ce  qui rendrait ledit
membre compl&egrave;tement  inutile. Il  faudra donc avoir  quelque part
dans le code une d&eacute;finition de variable:</p>

<pre class="demo">
bool complexe::debflg=false;
</pre>

<h4><a name="static-fct-memb">Fonctions membres statiques</a></h4>

<p>Le   code  ci-dessus   pr&eacute;sente   encore  un   gros
inconv&eacute;nient:  il  est impossible  de  jouer avec  <code>debflg</code>
avant    d'avoir    cr&eacute;&eacute;   au    moins    une    variable   de    type
<code>complexe</code>. La solution  est d'utiliser, en  plus du  membre statique
<code>debflg</code>,    deux   <em>fonctions-membres</em>   statiques;
<code>set_debug</code>  et  <code>clr_debug</code>.  De m&ecirc;me  que  les
membres  statiques  sont  <em>li&eacute;s  &agrave; une  classe  d'objets</em>,  les
fonctions-membres statiques sont  <em>li&eacute;es &agrave; une classe d'objet</em>,
pas &agrave; un objet.</p>

<p>Le code devient alors:</p>

<pre class="demo">
class complexe {
public:
   ...
   <b>static</b> void set_debug() { debflg=1;};
   <b>static</b> void clr_debug() { debflg=0;};
private:
   ...
   static bool debflg;
   ...
};

bool complexe::debflg=false;

main () {
   <b>complexe::set_debug();</b>        // passe en mode debug
   ...
   <b>complexe::clr_debug();</b>        // sort du mode debug
</pre>


<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Les membres statiques ou les fonctions-membres statiques sont des choses
<em>tr&egrave;s diff&eacute;rentes</em> des membres ou fonctions-membres ordinaires:</p>

<ul>
  <li>Ils ob&eacute;issent aux r&egrave;gles de port&eacute;e des membres</li>
  <li>Les fonctions-membres statiques ont le droit d'acc&eacute;der aux
      membres priv&eacute;s de l'objet, par contre ils doivent pour cela 
      utiliser le pointeur <code>*this</code> <a  href="#this"><img alt="apres" src="apres.gif" /></a></li>
</ul>
</div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Les fonctions membres statiques ressemblent beaucoup aux fonctions amies
<a  href="#fct-amies"><img alt="avant" src="avant.gif" /></a>:</p>

<ul>
  <li>De m&ecirc;me qu'une fonction amie de la classe, elles ont acc&egrave;s &agrave;
      l'ensemble des membres et des fonctions membres (private,
      protected, public) de celle-ci.</li>
  <li>Par contre, une fonction amie peut &ecirc;tre:
      <ul>
	<li>Soit une fonction "ordinaire"</li>
	<li>Soit une fonction membre d'une autre classe</li>
      </ul>
      Une fonction membre statique d'une classe est... uniquement une
      fonction membre de cette classe: c'est donc uniquement 
      la port&eacute;e qui diff&eacute;rencie fonction membre statique et fonction
      amie.</li>
</ul></div>

<h3><a name="const">Le descripteur const</a></h3>

<p>Le descripteur  <code>const</code> est  un  des plus
utilis&eacute;s parce que tr&egrave;s utile, mais  il est aussi un des plus d&eacute;licats
&agrave;    utiliser.    Toute   variable    peut    &ecirc;tre   d&eacute;clar&eacute;e    comme
<code>const</code>,  ce  qui  veut  dire  que cette  variable  est  en
fait... une constante.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
Puisqu'il sera  impossible, une fois la constante
d&eacute;clar&eacute;e,  de  modifier  sa  valeur,  il  est indispensable  de l'initialiser.  
 Donc l'expression <code>const&nbsp;int&nbsp;A;</code>  produira un
message d'erreur,  alors que <code>const&nbsp;int&nbsp;A=5;</code> sera accept&eacute;
par  le   compilateur.</p></div>

<h4>const, pourquoi faire ?</h4>

<p>Il est utile, par exemple lorsqu'on passe
un objet  par r&eacute;f&eacute;rence  &agrave; une fonction,  d'exprimer le fait  que cet
objet  est  constant,  c'est-&agrave;-dire   que  toute  op&eacute;ration  visant  &agrave;
<em>modifier  explicitement </em>  l'objet doit  &ecirc;tre  interdite.
<a  href="#desc-const"><img alt="avant" src="avant.gif" /></a></p>

<h4>membres constants</h4>

<p>Un objet  peut  avoir une  donn&eacute;e membre  constante.
Soit  une   classe  appel&eacute;e  <code>tableau</code>.  Dans  son constructeur, cette classe  alloue de  la m&eacute;moire pour  un tableau d'entiers.  La  m&eacute;moire est rendue au syst&egrave;me dans le destructeur.  La taille du
tableau est constante durant  toute la dur&eacute;e de vie de l'objet
(une fois  que le tableau existe,  il n'est pas pr&eacute;vu  qu'on puisse lui
changer sa taille).  Par contre, la taille du  tableau peut &ecirc;tre choisie
lors de la construction de  l'objet. <br /> Afin de faire ressortir dans
le code cette  sp&eacute;cificit&eacute;, et afin d'&ecirc;tre s&ucirc;r  qu'un bogue ne modifie
pas  la taille  du tableau  inopin&eacute;ment, on  utilise une  donn&eacute;e membre
constante. Le code ci-dessous est incorrect:</p>

<pre class="demo">
class tableau {
public:
  tableau(int);
  ~tableau() {delete buffer;};
private:
  <b>const</b> int taille;
  char* buffer;
};

tableau::tableau(int sz) {
  <i>taille=sz</i>;           // PAS POSSIBLE CAR taille EST CONSTANT
  buffer = new char[sz];
};

void main() {
  tableau B(1024);
};
</pre>

<p>Cela marcherait  si  <code>taille</code> n'&eacute;tait  pas
d&eacute;clar&eacute;      <code>const</code>.       En     effet,      l'expression
<code>taille=sz;</code> ne  peut pas avoir  de sens, puisque  taille est
une constante.   Par contre, la technique des  initialisateurs de membres,
d&eacute;crite ci-dessus, fonctionne tr&egrave;s bien dans ce cas:</p>

<pre class="demo">
class tableau {
public:
  tableau(int);
  ~tableau() {delete buffer;};
private:
  <b>const</b> int taille;
  char* buffer;
};

tableau::tableau(int sz) : <b>taille(sz)</b> {
  buffer = new char[sz];
};

void main() {
  tableau B(1024);
};
</pre>

<h4>Objets constants</h4>

<p>Il  est bien  s&ucirc;r possible d'utiliser  le descripteur
<code>const</code> avec  des objets, pas seulement  avec des variables
de types pr&eacute;d&eacute;finis.</p>

<h5>Les fonctions membres constantes</h5>

<p>Par  exemple,  si  nous  retournons  &agrave;  notre  objet
complexe, on pourrait d&eacute;finir  le complexe constant i par: <code>const
complexe i(0,i);</code>Oui, mais  nous avons un probl&egrave;me: le code
suivant ne compilera jamais.</p>

<pre class="demo">
class complexe {
public:
   complexe(float, float);
   float get_r() { return r;};
   float get_i() { return i;};
   ...
private:
   float r;
   float i;
   ...
};
main() {
   const complexe i(0,1);
   <b>float X = i.get_i();</b>
}
</pre>

<p>En  effet,  <em>personne</em>  ne peut  garantir  au
compilateur que  la fonction <code>get_i()</code> ne  va pas elle-m&ecirc;me
modifier l'objet  i. Il est clair  que <em>certaines</em>  fonctions-membres doivent
&ecirc;tre utilisables  sur des objets  constants (<code>get_r, get_i</code>
par exemple),  parce qu'elles ne  vont <em>pas modifier</em>  cet objet
(ce  sont  des <em>accessor</em>),  alors  que  d'autres fonctions  ne
peuvent   pas   &ecirc;tre   utilis&eacute;es   dans  ce   contexte   (<code>set_r,
set_i</code>),  car   elles  vont   modifier  l'objet  (ce   sont  des
<em>mutator</em>).  Il suffit  d'ajouter le mot-cl&eacute; <code>const</code>
<em>apr&egrave;s</em> la d&eacute;finition de  la fonction pour d&eacute;finir un accessor.
Dans ce cas, toute tentative de modification de l'objet (qui serait une incoh&eacute;rence dans le code) sera d&eacute;tect&eacute;e par le compilateur.  Notre
objet complexe s'&eacute;crit donc:</p>

<pre class="demo">
class complexe {
private:
   float r;
   float i;
   ...
public:
   complexe(float, float);
   float get_r() <b>const</b> { return r;};
   float get_i() <b>const</b> { return i;};
   ...
};
main() {
   const complexe i(0,1);
   float X = i.get_i();
}
</pre>

<h5>Le descripteur mutable</h5>

<p>Essayons d'utiliser le descripteur <code>const</code>
avec le complexe troisi&egrave;me version &eacute;crit plus haut. Il y a un probl&egrave;me
avec la fonction <code>get_m()</code>. En effet, pour pouvoir utiliser
cette  fonction avec  un  objet  constant, il  faut  lui attribuer  le
descripteur  <code>const</code>...  Or,  le compilateur  refusera, car
<code>get_r()</code> ne fait pas que  de renvoyer la valeur du module,
il  lui arrive &eacute;galement  de le  <em>calculer</em>. Donc,  les membres
<code>m</code>   et  <code>flg_m</code>   seront  modifi&eacute;s.    Que  se
passe-t-il  ?    Cela  veut-il  dire  que   cette  impl&eacute;mentation  est
incompatible avec  le fait  de d&eacute;clarer des  complexes constants  ? Ce
serait une s&eacute;v&egrave;re limitation:  c'est l'impl&eacute;mentation la plus efficace ! Pour   s'en  sortir,  il   faut  tout  d'abord   remarquer  que
<code>get_m</code>  ne va  pas  <em>r&eacute;ellement</em> modifier  l'objet.
Cette fonction  modifie deux membres  priv&eacute;s, mais <em>uniquement</em>
pour des raisons d'impl&eacute;mentation.  En fait, vis-&agrave;-vis de l'ext&eacute;rieur,
rien  n'a   chang&eacute;:  on  parle  de   <em>constante  logique</em>,  par
opposition aux  <em>constantes physiques</em>.  Les champs  qui ont le
droit  de varier  tout en  laissant l'objet  constant  du point-de-vue
logique sont  affubl&eacute;s du descripteur  <code>mutate</code>. Dans notre
cas,      il     s'agit      des     champs      <code>m</code>     et
<code>m_flg</code>. L'objet devient alors:</p>

<pre class="demo">
class complexe {
public:
  ...
  float get_r() const { return r;};
  float get_i() const { return i;};
  float get_m() const;
private:
  ...
  <b>mutable</b> bool m_flg;
  <b>mutable</b> float m;
  void _calc_module() const {m=sqrt(r*r+i*i);};
};

float complexe::get_m() const {
  if (!m_flg) {
    _calc_module();
    m_flg=true;
  };
  return m;
};
</pre>

<h3><a name="this">Le pointeur *this</a></h3>

<p>Supposons que  l'on veuille  modifier &agrave;  la  fois la
valeur de  la partie r&eacute;elle  et la valeur  de la partie  imaginaire de
notre nombre complexe. Nous pouvons &eacute;crire le code suivant:</p>

<pre class="demo">
complexe C(0,0);
C.set_r(2);
C.set_i(3);
</pre>

<p>Or, les fonctions <code>set_r</code> et <code>set_i</code> agissent sur le complexe C. Il est utile de se
d&eacute;brouiller pour qu'elles renvoient le complexe qu'elles viennent de modifier, plut&ocirc;t que rien du tout. Cela permet par exemple d'&eacute;crire le code suivant:</p>

<pre class="demo">
C.set_r(2).set_i(3);
</pre>

<p>Cette expression ne peut avoir un sens que si  la  valeur
renvoy&eacute;e par <code>set_r(2)</code>  est une <em>r&eacute;f&eacute;rence</em> vers le
m&ecirc;me  objet que  <code>C</code>: dans  ce  cas <code>C.set_r(2)</code> ex&eacute;cute la fonction  <code>set_r(2)</code>, renvoie <code>C</code>, de sorte   que <code>C.set_r(2).set_r(3)</code>   est   &eacute;quivalent   &agrave; <code>C.set_r(3)</code><br /> Le  C++ offre un  outil pour arriver  &agrave; ce
r&eacute;sultat: il s'agit du pointeur <code>*this</code>. Ce pointeur est une    variable   priv&eacute;e   pr&eacute;d&eacute;finie   qui   pointe
<em>toujours</em> sur l'objet dans  lequel on se trouve.  Pour arriver
au r&eacute;sultat ci-dessus, il  suffira donc de renvoyer <code>*this</code>
comme valeur  de retour.  D'o&ugrave;  la d&eacute;finition suivante des fonctions
<code>set_xxx</code>:</p>

<pre class="demo">
class complexe {
public:
   <b>complexe&amp;</b> set_r(float x) { r=x; _calc_module(); return *this;};
   <b>complexe&amp;</b> set_i(float y) { r=y; _calc_module(); return *this;};
private:
   ...
</pre>

<p>Le pointeur <code>*this</code> est tr&egrave;s utilis&eacute; pour les op&eacute;rateurs, et prendra tout son sens avec eux <a  href="surch.html"><img alt="apres"
src="apres.gif" /></a>. Voil&agrave; au passage une nouvelle  utilisation de la r&eacute;f&eacute;rence en tant que
valeur de retour d'une fonction <a  href="#ptr-retref"><img alt="avant" src="avant.gif" /></a>.</p>

<h4>Utilisation de this pour nommer les variables</h4>

<p>Dans les exemples pr&eacute;c&eacute;dents, on s'est toujours arrang&eacute; pour donner un nom diff&eacute;rent &agrave; la varaible membre d'un objet et au param&ecirc;tre du constructeur. En effet, il faut &eacute;viter d'utiliser des constructions dans le genre <code>x(x)</code> ou <code>x=x</code>. <code>this</code> permet d'&eacute;viter de se creuser trop la t&ecirc;te:</p>

<pre class="demo">
class complexe {
public:
   complexe(float x, float y): this->x(x),this->y(y),...{};
private:
   float x,y;
}
</pre>

<p><a href="#">top</a></p><hr />

<h4><img alt="Les autres ?" src="dechirure.gif"  width="20" />
Autres langages objets...</h4>

<table class="tableau">
  <tr>
    <th align="center"> Langage </th>
    <th align="center"> class </th>
    <th align="center"> private, public, protected </th>
    <th align="center"> Fonctions membres </th>
    <th align="center"> Constructeurs </th>
    <th align="center"> Destructeurs </th>
    <th align="center"> Fonctions amies </th>
    <th align="center"> Fonctions membres statiques </th>
    <th align="center"> Donn&eacute;es membres statiques </th>
    <th align="center"> Donn&eacute;es ou fonctions membres const </th>
    <th align="center"> Pointeur this </th>
  </tr>
  <tr>
    <td><b>C++</b> </td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
  </tr>
  <tr>
    <td><b>perl</b></td>
    <td>NON</td><td>NON</td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td><b>OUI</b></td><td>NON</td>
    <td>NON</td><td><b>OUI</b></td>
    <td>NON</td><td>NON(1)</td>
  </tr>
  <tr>
    <td><b>java</b></td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td>NON</td><td>NON</td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td>NON</td><td><b>OUI</b></td>
  </tr>
  <tr>
    <td><b>python</b></td>
    <td><b>OUI</b></td><td>NON</td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td><b>OUI</b></td><td>NON</td>
    <td><b>OUI</b></td><td><b>OUI</b></td>
    <td>NON</td><td><b>OUI</b></td>
  </tr>
</table>
<ol>
  <li>Le tableau associatif <code>%self</code> dans lequel on met g&eacute;n&eacute;ralement les donn&eacute;es des objets en perl, joue toutefois le m&ecirc;me r&ocirc;le que <code>this</code>.</li>
</ol>

<p><a href="#">top</a></p><hr />
<address><a href="mailto:emmanuel.courcelle@toulouse.inra.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@toulouse.inra.fr&gt;</a></address>
<p>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>
</div>
</body> </html>

