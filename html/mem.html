<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Language" content="fr" />
    <style type="text/css" media="screen">
        @import url("cours.css");
    </style>
    <!-- [if lte IE 6]>
        <style type="text/css" media="screen">
            @import url("cours_ie.css");
        </style>
    <![endif]-->
  <style type="text/css" media="print">
         @import url(coursprint.css);
  </style>
  <title>Gestion de la m&eacute;moire</title>
</head>

<body>
<script type="text/javascript" src="cours.js"></script>

<div id="menu" class="menu">
<dl class="img">
 <dt><a href="http://www.cnrs.fr" title="C.N.R.S."><img alt="logo CNRS" src="cnrs.png" /></a></dt>
</dl>
<dl class="img">
 <dt><a href="http://www.inp-toulouse.fr" title="I.N.P.T."><img alt="logo INPT" src="inpt.png" /></a></dt>
</dl>
<dl>  
 <dt><a href="index.html" title="sommaire" onmouseover="javascript:montre('smenu1')">Sommaire</a></dt>
 <dd id="smenu1">
	<ul>
		<li><a href="mem.html#alloc-dynam">Qu'est-ce que l'allocation dynamique de m&eacute;moire? </a>
		<ul>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#pile-tas">Pointeurs empil&eacute;s, objets entass&eacute;s</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#fuite-mem">Objets perdus et fuites de m&eacute;moire</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#dangling">Les pointeurs qui pendouillent</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#proprio">Propri&eacute;taires et r&eacute;f&eacute;rents</a></li> 
		</ul></li>
		<li><a onclick="javascript=cacher_menu()" href="mem.html#oper">Op&eacute;rateurs et fonctions</a> 
		<ul>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#new">Les op&eacute;rateurs <code>new</code> et <code>delete</code></a></li>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#new-tab">Les op&eacute;rateurs <code>new[]</code> et <code>delete[]</code></a></li>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#malloc">Fonctions malloc, free, realloc</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#except">En cas d'erreur d'allocation</a></li> 
		</ul></li>
		<li><a onclick="javascript=cacher_menu()" href="mem.html#obj">Objets utilis&eacute;s pour la gestion de la m&eacute;moire</a> 
		<ul>
			<li><a onclick="javascript=cacher_menu()" href="mem.html#unique_ptr">L'objet <code>unique_ptr</code></a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#gest">Objets gestionnaires de ressources</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#robuste">Produire du code robuste, malgr&eacute; les exceptions</a></li> 
			<li><a onclick="javascript=cacher_menu()" href="mem.html#compt">Les objets &agrave; comptage de r&eacute;f&eacute;rence</a></li> 
		</ul></li>
	</ul>
 </dd>
</dl>
<dl>
 <dt><a href="exos.html#memoire" title="Les exercices de ce chapitre">Exercices</a></dt>
</dl>
<dl>
  <dt><a href="http://www.cplusplus.com">cplusplus</a></dt>
</dl>
<dl>
  <dt><a href="http://c.developpez.com/faq/cpp/">FAQ C++</a></dt>
</dl>
<dl>
  <dt><a href="http://www.stroustrup.com/C++11FAQ.html">C++11</a></dt>
</dl>
<dl>
  <dt><a href="http://www.boost.org/">BOOST</a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" onclick="javascript=cacher_menu()"><img alt="cacher le menu" title="cacher le menu" src="fleche-droite.png" /></a></dt>
</dl>
<dl class="fleche">
  <dt><a class="pas_ie" href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a></dt>
</dl>
</div>

<div id="bouton_menu" class="menu">
<a onclick="javascript=cacher_menu()"><img alt="afficher le menu" title="afficher le menu" src="fleche-gauche.png" /></a>
<a href="#"><img alt="haut de la page" title="haut de la page" src="fleche-haut.png" /></a>
</div>

<div id="contenu">
<h1><a name="surch-fonc-op">Gestion de la m&eacute;moire</a></h1>

<p>Ce paragraphe  traite des  pointeurs,  des probl&egrave;mes
li&eacute;s &agrave; l'allocation  dynamique de m&eacute;moire, et des  moyens qui existent
de r&eacute;soudre ces probl&egrave;mes...   plut&ocirc;t d'&eacute;viter leur apparition, car en
ce domaine le pr&eacute;ventif est bien plus ais&eacute; que le curatif...</p>

<h2><a name="alloc-dynam">Qu'est-ce que l'allocation dynamique de m&eacute;moire ?</a></h2>

<p >Nous avons vu pr&eacute;c&eacute;demment  que la dur&eacute;e de vie d'une
variable     s'&eacute;tendait     durant      toute     la     port&eacute;e     <a
href="types.html#portee-nom"><img      alt="avant"     src="avant.gif" /></a>  de   son  nom.
   La   m&eacute;moire  est  allou&eacute;e,   et  le
constructeur de l'objet est appel&eacute;  en d&eacute;but de port&eacute;e; le destructeur
est appel&eacute; et la m&eacute;moire est rendue au syst&egrave;me &agrave; la fin de port&eacute;e. Les
objets utilis&eacute;s ainsi utilisent une  partie de la m&eacute;moire vive appel&eacute;e
<code>la pile</code>.  La structure  de pile est en effet parfaitement
adapt&eacute;e  &agrave;  la  gestion  des  r&egrave;gles  de  port&eacute;e.  Or,  il  peut  &ecirc;tre
int&eacute;ressant de stocker des donn&eacute;es &agrave; des endroits de la m&eacute;moire qui ne
seront  pas sujets soumis  aux r&egrave;gles  de port&eacute;e;  cela peut  se faire
gr&acirc;ce &agrave;:</p>

<ul>
  <li>d'une part  l'utilisation de pointeurs</li>
  <li>d'autre part &agrave; des op&eacute;rateurs permettant de g&eacute;rer explicitement
      l'allocation m&eacute;moire et sa lib&eacute;ration.</li>  
</ul>

<p >L'allocation-lib&eacute;ration de  m&eacute;moire &eacute;tant &agrave; la charge
du  programmeur, elle  peut se  faire  dans n'importe  quel ordre.  La
structure de pile n'est alors plus  adapt&eacute;e, et de fait la m&eacute;moire est
allou&eacute;e dans une autre z&ocirc;ne de la m&eacute;moire, appel&eacute;e <code>le tas</code>
(<code>heap</code>).</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" /> Le programmeur
doit <em>effectivement</em> g&eacute;rer la  lib&eacute;ration de m&eacute;moire... s'il ne
le fait pas, ou s'il le  fait mal, les pires cons&eacute;quences (&agrave; savoir un
plantage du programme) peuvent arriver.</p></div>

<h3><a name="pile-tas">Pointeurs empil&eacute;s, objets entass&eacute;s</a></h3>

<p >La  seule z&ocirc;ne de  m&eacute;moire que le  programme <em>peut
adresser directement</em>  est la  pile.  Les pointeurs  se trouveront
donc quelque  part dans  la pile, au  m&ecirc;me titre que  n'importe quelle
variable. Les <em>objets point&eacute;s</em>,  par contre, se trouveront dans
le tas. Il doit y avoir  <em>en permanence</em> un lien entre ces deux
z&ocirc;nes de m&eacute;moire.  Garder ce lien intact est la premi&egrave;re pr&eacute;occupation
d'une bonne gestion de la m&eacute;moire.</p>

<h3><a name="fuite-mem">Objets perdus et fuites de m&eacute;moire</a></h3>

<p  >Lorsqu'un  objet  est allou&eacute;  dynamiquement,  <em>au
moins un  pointeur</em> doit  pointer sur lui:  sinon, le  lien &eacute;voqu&eacute;
ci-dessus est bris&eacute;,  et l'objet est inutilisable. On  peut dire qu'il
est  perdu,  mais   surtout  <em>la  m&eacute;moire  correspondante</em>  est
perdue. Avant de briser le lien,  il aurait fallu rendre la m&eacute;moire au
syst&egrave;me. Suivant les  cas de figure, cela peut &ecirc;tre  grave ou pas. Par
exemple, si l'allocation  de m&eacute;moire a lieu dans  une boucle, &agrave; chaque
it&eacute;ration de la boucle on perd un peu de m&eacute;moire...  d'o&ucirc; l'expressoin
fuite de m&eacute;moire.  Si le nombre  d'it&eacute;rations est important, il y a un
moment o&ucirc; le  syst&egrave;me refusera de donner de  la m&eacute;moire suppl&eacute;mentaire
au programme, et celui-ci sera interrompu brutalement.</p>

<h3><a name="dangling">Les pointeurs qui pendouillent</a></h3>

<p  >Il  est   parfaitement  possible  de  faire  pointer
plusieurs pointeurs vers  le m&ecirc;me objet.  Mais dans  ce cas si l'objet
est d&eacute;truit (car le  programmeur a consciencieusement rendu la m&eacute;moire
au syst&egrave;me)  les autres pointeurs  pointeront sur une z&ocirc;ne  de m&eacute;moire
qui  ne  contient  plus  de  donn&eacute;es  valides...  soit  elle  contient
n'importe  quoi   ("du  jargon"  (<code>garbage</code>)),   soit  elle
contient  de  nouvelles  donn&eacute;es,  mais  qui  ne  sont  peut-&ecirc;tre  pas
structur&eacute;es de  la m&ecirc;me mani&egrave;re  que les pr&eacute;c&eacute;dentes.  Le  pointeur va
donc "pendouiller", et  si on cherche &agrave; l'utiliser,  il peut se passer
n'importe quoi, mais le pire est &agrave; craindre.</p>

<h3><a name="proprio">Propri&eacute;taires et r&eacute;f&eacute;rents</a></h3>

<p>Compte tenu de ce qui pr&eacute;c&egrave;de, on voit donc qu'on peut d&eacute;finir deux sortes de
pointeurs:</p>

<ul>
  <li>Un pointeur <em>propri&eacute;taire</em> de l'objet. Il a la responsabilit&eacute; de
      la destruction de cet objet. L'objet est le <em>r&eacute;f&eacute;rent</em>.</li>
  <li>Les autres pointeurs. Ils peuvent acc&eacute;der &agrave; l'objet tant que
      celui-ci existe, mais ils ne sont pas cens&eacute;s s'occuper de sa destruction.</li>
</ul>

<p>Bien  s&ucirc;r, la propri&eacute;t&eacute;  d'un objet peut  passer d'un
pointeur  &agrave;  l'autre. D'autre  part,  il  faut  bien avoir  pr&eacute;sent  &agrave;
l'esprit que ces notions, importantes  lors de la phase de conception,
<em>ne sont  pas pr&eacute;sentes  dans le langage  lui-m&ecirc;me</em>: le  C++ ne
comprend en effet aucune gestion  de la m&eacute;moire, celle-ci restant &agrave; la
charge du programmeur. Cependant, des objets (dont l'un d'entre eux se
trouve  d&eacute;clar&eacute;  dans  la  biblioth&egrave;que standard)  vont  pouvoir  nous
aider.</p>

<p><a href="#">top</a></p><hr />

<h2><a name="oper">Op&eacute;rateurs et fonctions</a></h2>

<h3><a name="new">Les op&eacute;rateurs <code>new</code> et <code>delete</code></a></h3>

<p>L'op&eacute;rateur <code>new</code> est utilis&eacute; pour allouer
de  la m&eacute;moire  pour un  objet, <code>delete</code>  est  utilis&eacute; pour
redonner  la m&eacute;moire  au  syst&egrave;me.  Le (ou  les)  param&egrave;tres pass&eacute;s  &agrave;
<code>new</code> seront pass&eacute;s au constructeur de l'objet:</p>

<pre class="demo">
main() {
   const complexe J(0,1);
   <b>complexe* C = new complexe(5,5);</b>
   *C = J;
   <b>delete C;</b>
};
</pre>

<h3><a name="new-tab">Les op&eacute;rateurs <code>new[]</code> et <code>delete[]</code></a></h3>

<p>Ils  servent  &agrave;   allouer  de  la  m&eacute;moire  pour  un
<em>tableau</em>  d'objets.  Ils  ne  peuvent etre  utilis&eacute;s  qu'&agrave;  la
condition qu'existe pour notre objet un constructeur par d&eacute;faut, &agrave; qui
on puisse ne  pas passer de param&egrave;tres. C'est le  cas pour notre objet
<code>complexe</code>, nous pouvons donc &eacute;crire:</p>

<pre class="demo">
main() {
   const complexe J(0,1);
   int taille=100;
   <b>complexe* C = new complexe[taille];</b>
   for (int i=0; i&lt;100; ++i) {
       C[i] = J;
   }
   <b>delete[] C;</b>
};
</pre>

<p>Un tableau de 100 complexes est dynamiquement allou&eacute;.
Les  complexes sont tous  initialis&eacute;s &agrave;  0 (constructeur  par d&eacute;faut),
puis  affect&eacute;s  &agrave; la  valeur  <code>J</code>.  Enfin,  le tableau  est
d&eacute;truit et la m&eacute;moire est rendue au syst&egrave;me.</p>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />  On  ne  peut  allouer  un
tableau  d'objets  de cette  mani&egrave;re  <em>que</em>  si  les objets  en
question poss&egrave;dent  un constructeur par d&eacute;faut. Il  n'est pas possible
de passer des param&egrave;tres aux constructeurs des objets cr&eacute;&eacute;s.</p></div>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />La taille peut parfaitement &ecirc;tre une variable, comme on le voit dans cet exemple.</p></div>

<h3><a name="malloc">Fonctions malloc, free, realloc</a></h3>

<p>Nous   avons   en  <code>C</code>   des   fonctions
d'allocation    dynamique   de    m&eacute;moire:    <code>malloc</code>   et
<code>free</code> pour allouer de la  m&eacute;moire et la rendre au syst&egrave;me,
<code>realloc</code>  pour refaire une  allocation m&eacute;moire  lorsque le
bloc   pr&eacute;c&eacute;demment  allou&eacute;   est  trop   juste. Tout   cela  est
r&eacute;utilisable, &agrave; condition de bien faire la différence entre les deux utilisations:</p>

<ul>
  <li><code>new</code> alloue la m&eacute;moire, <em>puis</em> appelle le
      constructeur. <code>malloc</code> <em>ne sait pas ce qu'est un objet !</em>. malloc alloue une zone de mémoire (bas niveau), alors que new initialise un objet ou un tableau d'objets (haut niveau).</li>
  <li><code>delete</code> appelle le destructeur <i>puis</i> rend la m&eacute;moire au syst&egrave;me. <code>free</code> <em>ne sait pas ce qu'est un 
  destructeur</em>, il ne risque donc pas de l'appeler.</li>
</ul>

<h3><a name="except">En cas d'erreur d'allocation</a></h3>
<p>S'il n'est pas possible d'allouer la mémoire demandée, <tt>new</tt> lancera l'exception <tt>bad_alloc</tt>. Par contre, 
<tt>malloc</tt> ou <tt>calloc</tt> se contentera de renvoyer un pointeur <tt>nullptr</tt></p>

<p>Conclusion: pour du code  C++, il n'y a aucune raison
de  ne  pas  utiliser  les  op&eacute;rateurs  du  C++,  <code>new</code>  et
<code>delete</code>.  Mais  il faut  savoir que le  code C  &eacute;crit avec
<code>malloc</code>  et  <code>free</code> (m&ecirc;me  <code>realloc</code>
dans le  cas de z&ocirc;nes d'entiers  ou de caract&egrave;res,  par exemple) reste
utilisable.</p>

<h3><a name="constr-destr">Allocation m&eacute;moire et constructeurs-destructeurs</a></h3>

<p>Le  constructeur d'un  objet est l'endroit  r&ecirc;v&eacute; pour
appeler <code>new</code>.  De m&ecirc;me, le  destructeur du m&ecirc;me  objet est
l'endroit r&ocirc;v&eacute; pour appeler <code>delete</code>.</p>

<h4>Constructeurs de copie</h4>

<p>Attention  au constructeur de copie;  &agrave; chaque copie,
il  faudra  prendre  une  d&eacute;cision;  il peut  en  effet  se  pr&eacute;senter
plusieurs cas de figure:</p>

<ol>
  <li>L'objet source est propri&eacute;taire d'un objet r&eacute;f&eacute;rent, l'objet
      copi&eacute; pointe vers le r&eacute;f&eacute;rent sans &ecirc;tre propri&eacute;taire.</li>
  <li>L'objet source est propri&eacute;taire d'un r&eacute;f&eacute;rent, &agrave; la suite de la
      copie l'objet copi&eacute; devient le nouveau propri&eacute;taire.</li>
  <li>Le r&eacute;f&eacute;rent de l'objet source est copi&eacute; dans une autre z&ocirc;ne
      m&eacute;moire, et l'objet copi&eacute; est propri&eacute;taire de la copie du r&eacute;f&eacute;rent.</li>
</ol>

<div class="attention"><p><img alt="ATTENTION" src="attention.gif" />
  Des  trois   solutions
ci-dessus, la  premi&egrave;re est  <em>tr&egrave;s dangereuse</em>: en  effet, elle
risque  fort  d'aboutir &agrave;  des  objets  "irresponsables" vis-&agrave;-vis  de
l'allocation m&eacute;moire. Cette  solution est toutefois acceptable lorsque
les   objets   r&eacute;f&eacute;rents   comptent   eux-m&ecirc;mes  les   r&eacute;f&eacute;rences   <a
href="#compt"><img  alt="apres"  src="apres.gif" /></a>.  La
seconde solution peut &ecirc;tre impl&eacute;ment&eacute;e par un <code>unique_ptr</code>.</p></div>

<p><a href="#">top</a></p><hr />

<h2><a name="obj">Objets  utilis&eacute;s pour la gestion de la m&eacute;moire</a></h2>

<h3><a id="uniq-ptr">L'objet <tt>unique_ptr</tt></a></h3>

<p>Cet objet, défini dans la stl, définit un "smart pointer", c'est-à-dire un objet dont le rôle est de:</p>

<ul>
<li>Encapsuler un pointeur renvoyé par un appel new ou new[]</li>
<li>Libérer la mémoire allouée par celui-ci lorsque l'objet sort de sa portée: il y a un delete dans son destructeur.</li>
</ul>

<p>Un unique_ptr est <strong>toujours</strong> propriétaire de l'objet sur lequel il pointe. Un <tt>unique_ptr</tt> <strong>ne peut pas être copié</strong>, mais 
<strong>il peut être déplacé !</strong>. En effet si on copie un pointeur, on se retrouve avec deux pointeurs qui sont chacun responsables
de l'objet pointé, ce qui est une erreur si on ne prend pas des précautions. Si on déplace un pointeur, on passe simplement
la responsabilité de l'un vers l'autre.</p>.

<p>Le code suivant montre ce que devient notre code tableau défini plus haut lorsqu'on utilise un <tt>unique_ptr</tt> à la place d'un pointeur ordinaire:</p>

<pre class="demo">
#include <memory>
class tableau {
public:
  tableau(int);

private:
  const size_t taille;
  unique_ptr<int> buffer;
};

tableau::tableau(int s) : taille(s) {
  buffer = (unique_ptr&lt;int&gt;) new int [taille];
};

void main() {
  tableau t1(1000);
  try
  {
      tableau t2(100000000000000000);
  } 
  catch (bad_alloc & e)
  {
      cout << "oups, pas assez de mémoire !" << endl;
  }
};
</pre>

<h3><a name="gest">Objets gestionnaires de ressources</a></h3>

<p>Pour  &eacute;viter les  ennuis &eacute;voqu&eacute;s  ci-dessus, arrangez-vous  pour qu'un
objet <em>ne g&egrave;re qu'une seule ressource</em>. Eventuellement, si vous
devez g&eacute;rer  trois ressources, rien  ne vous emp&ecirc;che  d'utiliser trois
objets  diff&eacute;rents,  quitte  &agrave;   les  ins&eacute;rer  dans  un  autre  objet.</p>

<div class="regle"><p><img alt="REGLE  D'OR"  src="diam.gif" />
Les trois principes fondamentaux pour g&eacute;rer les ressources sont:</p>

<dl>
  <dt><b>Propri&eacute;t&eacute;</b></dt>
  <dd>A chaque ressource allou&eacute;e, correspond <em>un et un seul</em>
      objet gestionnaire, qui sera propri&eacute;taire de cette ressource.</dd>
  <dt><b>Responsabilit&eacute;</b></dt>
  <dd>L'objet gestionnaire est <em>responsable</em> de la ressource,
      et il est <em>le seul responsable</em></dd>
  <dt><b>Simplicit&eacute;</b></dt>
  <dd>L'objet gestionnaire ne fait <em>rien d'autre</em>.</dd>
</dl>
</div>

<p><code>unique_ptr</code> est un bon exemple d'objet dont l'unique raison
d'&ecirc;tre est la gestion d'une ressource (en l'occurrence la m&eacute;moire).</p>

<h3><a name="robuste">Produire du code robuste, simple à maintenir, lisible</a></h3>

<p>Mon code C++ idéal: pas de fuites de mémoire, lisible, performant</p>

<ul>
<li>Utiliser des objets gestionnaires de ressources: ostream, istream pour les fichiers, unique_ptr pour la mémoire, etc.</li>
<li>En particulier, ne pas utiliser de pointeurs</li>
<li>Ne pas utiliser de tableaux "à la C". Dans la mesure du possible, ne pas utiliser d'opérateur new/delete: utiliser à la place les conteneurs de la stl</li>
<li>Dans les conteneurs, on peut déposer soit des objets, soit des <tt>unique_ptr</tt></li>
<li>Pour itérer sur un conteneur, utiliser la nouvelle syntaxe for</li>
<li>Les fonctions peuvent retourner des objets, pas la peine de se creuser la cervelle en renvoyant des pointeurs</li>
<li>Ne pas écrire le trio infernal ni le quintette infernal, le compilateur s'en chargera</li>
</ul>

<p><a href="#">top</a></p><hr />
<address>
<a href="http://validator.w3.org/check?uri=referer"><img alt="xhtml" src="xhtml.png" /></a>
<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.fr"><img alt="Licence Creative Commons" src="cc-byncnd.png" /></a>
    <a href="mailto:emmanuel.courcelle@inp-toulouse.fr">Emmanuel Courcelle &lt;emmanuel.courcelle@inp-toulouse.fr&gt;</a></address>
</div></body> </html>
