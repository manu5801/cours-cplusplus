\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usetheme{Warsaw}
\usecolortheme{wolverine}
\usepackage{color}

\input{lstset.tex}

\title{Pointeurs et références}
\subtitle{Introduction au C++ et à la programmation objet}
\author{E. Courcelle}\institute{CALMIP, URA 3669}
\date{Mai 2022}

\pgfdeclareimage[height=0.5cm]{logo}{images/cnrs+inpt}
\logo{\pgfuseimage{logo}}

\addtobeamertemplate{footline}{\insertframenumber/\inserttotalframenumber}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\tableofcontents
\end{frame}

\section{Déclarations}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {initialisation}

\begin{block}{Clonage}
Initialiser un objet à partir d'un autre, c'est réaliser une opération de clonage:
\begin{enumerate}
\item allocation mémoire (temps !)
\item initialisation
\end{enumerate}
\em Cela peut conduire à des copies importantes en mémoire
\end{block}

\begin{lstlisting}[language=c++]
UnObjet nouveau = existant;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Affectation}

\begin{block}{Copie}
Affecter un objet à partir d'un autre, c'est recopier l'état de l'objet mais sans refaire l'allocation
\begin{enumerate}
\item Effacer les données (parfois désallocation-réallocation)
\item Recopier les données à partir de l'objet copié
\end{enumerate}
\em Cela peut conduire à des copies importantes en mémoire (temps)
\end{block}

\begin{lstlisting}[language=c++]
UnObjet nouveau;
...
nouveau = existant;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Les références}

\begin{block}{Aliases}
Une référence est un alias: le même objet porte plusieurs noms.
\begin{enumerate}
\item Pas d'allocation de mémoire ni de copie de données
\item La référence n'a de sens que durant l'étape de compilation (dans le binaire final les variables n'ont pas de noms)
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
UnObjet& nouveau = existant;

UnObjet& toto;  // NE COMPILE PAS !
\end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Les pointeurs}

\begin{block}{Une flèche}
Le pointeur est une "flèche" qui renvoie sur une donnée en mémoire. Il s'en suit que:
\begin{enumerate}
\item Le pointeur est un type de données à part entière, c'est une adresse mémoire.
\item On peut faire des "calculs" sur les pointeurs (incrémentation, soustraction, etc.) cela revient à faire des calculs d'adresses
\item Le pointeur est une donnée, il continue donc à avoir une existence dans le binaire après compilation
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
UnObjet obj;
UnObjet* ptr1 = &obj;
UnObjet* ptr2 = new UnObjet;
UnObjet obj1 = *ptr2;
\end{lstlisting}
\end{frame}


\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Les pointeurs}

\begin{block}{Une flèche}
Le pointeur est une "flèche" qui renvoie sur une donnée en mémoire. Il s'en suit que:
\begin{enumerate}
\item Le pointeur est un type de données à part entière, c'est une adresse mémoire.
\item On peut faire des "calculs" sur les pointeurs (incrémentation, soustraction, etc.) cela revient à faire des calculs d'adresses
\item Le pointeur est une donnée, il continue donc à avoir une existence dans le binaire après compilation
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
UnObjet obj;
UnObjet* ptr1 = &obj;
UnObjet* ptr2 = new UnObjet;
UnObjet obj1 = *ptr2;
\end{lstlisting}
\end{frame}

\section{Passage de paramètres}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Passage par valeur}

\begin{block}{Passage des paramètres par valeur}
Le code suivant utilise un objet A en paramètre et retourne un flottant. A est passé par valeur, c'est-à-dire que:
\begin{enumerate}
\item A est copié dans l'espace de la fonction
\item La copie de A est utilisée pour le calcul
\item Le résultat est renvoyé dans l'espace appelant
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
float une_fonction(UnObjet A) {
    float resultat = 0;
    resultat = ...
    return resultat
}
\end{lstlisting}

\begin{block}{}
\begin{itemize}
\item Avantage = Pas d'effets de bord possibles
\item Inconvénient = A peut être lourd à copier
\item A utiliser avec des types natifs
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Passage par référence}

\begin{block}{Passage des paramètres par référence}
Le code suivant utilise un objet A en paramètre, retourne un flottant mais modifie également l'état de A (c'est une variable de type Inout)
\begin{enumerate}
\item On utilise un "alias" pour nommer la variable A dans le contexte de la fonction
\item L'alias est utilisé pour le calcul
\item L'alias est modifié dans le calcul, donc la variable originale est modifiée également.
\item Le résultat est renvoyé d'une part dans l'espace appelant, d'autre part par le paramètre A
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
float une_fonction(UnObjet& A) {
    float resultat = 0;
    A.setQqchose(0);
    resultat = ...
    return resultat
}
\end{lstlisting}

\begin{block}{}
\begin{itemize}
\item Avantage = Pas de copie à réaliser, appel de paramètres très rapide
\item Inconvénient = A peut être modifié, donc effet de bord possible
\item A utiliser seulement avec des paramètres de type Inout
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Passage par const référence}

\begin{block}{Passage des paramètres par const \&}
Le code suivant utilise un objet A en paramètre et retourne un flottant sans modifier A.
\begin{enumerate}
\item On utilise un "alias" pour nommer la variable A dans le contexte de la fonction
\item L'alias est noté const, donc il ne peut pas être modifié dans le contexte de la fonction.
\item L'alias est utilisé pour le calcul
\item Le résultat est renvoyé dans l'espace appelant
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
float une_fonction(const UnObjet& A) {
    float resultat = 0;
    resultat = ...
    return resultat
}
\end{lstlisting}

\begin{block}{}
\begin{itemize}
\item Avantage = Pas de copie à réaliser, appel de paramètres très rapide, pas d'effet de bord possible
\item A utiliser à la place du passage par valeur (même sémantique) pour des paramètres de type objet
\end{itemize}
\end{block}
\end{frame}

\section{Retour des fonctions}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Retour par référence}

\begin{block}{Retour \&}
Le code suivant crée un objet dans la fonction et renvoie cet objet par référence: ça ne marche pas !!!

\begin{enumerate}
\item On crée l'objet dans le corps de la fonction
\item On retourne un alias de cet objet: l'alias correspond à une adresse mémoire qui n'est plus allouée puisque la fonction est terminée !
\item ça va planter... ou pas
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
UnObjet& une_fonction(float x) {
    UnObjet resultat = ...;
    return resultat
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Retour par pointeur}

\begin{block}{Retour *}
Le code suivant crée un objet dans la fonction en passant par l'opérateur new renvoie le pointeur sur cet objet:
ça marche, mais c'est vieux et moche.

\begin{enumerate}
\item On crée l'objet dans le corps de la fonction en utilisant new (afin de déposer l'objet dans le tas et pas dans la pile)
\item On retourne le pointeur sur cet objet.
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
UnObjet* une_fonction(float x) {
    UnObjet* resultat = new UnObjet(...);
    return resultat
}
\end{lstlisting}

\begin{itemize}
\item Avantage = Relativement efficace car un pointeur est un objet petit
\item Etait très souvent utilisé chez les Dinosaures, plus très utile aujourd'hui
\end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {Retour par valeur}

\begin{block}{On ne se prend pas la tête}
Le code suivant crée un objet dans la fonction, et le renvoie tout simplement.

\begin{enumerate}
\item On crée l'objet dans le corps de la fonction
\item On retourne cet objet par valeur: cela ne génère même pas de copie !
\end{enumerate}
\end{block}

\begin{lstlisting}[language=c++]
UnObjet une_fonction(float x) {
    UnObjet resultat = ...;
    return resultat
}
\end{lstlisting}

\begin{itemize}
\item Avantage = Elégant et efficace grâce au Return Value Optimization (RVO) implémenté par tous les compilateurs actuels.
\item Les dinosaures ne connaissaient pas le RVO !
\item A utiliser pour du code moderne
\end{itemize}
\end{frame}

\section{Le descripteur const}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle {const sur les pointeurs}

\begin{block}{Pour les dinosaures}
En C++ moderne, évitons d'utiliser des pointeurs "ordinaires..." Mais les dinosaures ont-ils vraiment disparu ?
\end{block}

\begin{lstlisting}[language=c++]
const int* a = new(int);
*a = 10;                        // Erreur car *a est constant
a = NULL;
int* const b = NULL;
b = new(int);                   // Erreur car b est constant
*b = 356;
const int* const c = new(int);
*c = 10;                        // Erreur car *c est constant
c = NULL;                       // Erreur car c est constant
\end{lstlisting}

\end{frame}

\section{malloc et les autres}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle{Pointeurs et tableaux}

\begin{block}{Dinosaures ou bas niveau}
En langage C, un tableau peut être vu comme un pointeur:
\end{block}

\begin{lstlisting}[language=c++]
#define TAILLE 100
int tab[TAILLE];
int *p, *q, *r;
p = &tab[0];          // p pointe sur le premier element
q = p + (TAILLE-1);   // q pointe sur le dernier element
r = q - (TAILLE-1);   // r pointe sur le premier element

// Initialiser le tableau en utilisant les pointeurs
for (int i=0, int* p=tab; i < TAILLE; ++i)
{
    *p++ = 0;
}

// Copier le tableau tab dans tab1
for (int i=0, int* p=tab, int* q=tab1; i < TAILLE; ++i)
{
    *q++ = *p++;
}
\end{lstlisting}

\begin{block}{}
En C++ moderne, on utilisera plutôt les objets de la stl !
\end{block}
\end{frame}

\begin{frame}[fragile=singleslide,shrink=20]
\frametitle{malloc et les autres}

\begin{block}{Dinosaures ou bas niveau}
En C, on utilise des appels bas niveau pour allouer des tableaux dynamiques
\end{block}

\begin{lstlisting}[language=c++]
void * malloc (size_t size);
void * calloc (size_t nbelts, size_t size);
void * realloc (void * ptr, size_t size);
void free (void * ptr);
\end{lstlisting}

\begin{lstlisting}[language=c++]
size_t dimension = 1000;
int* tab = (int *) calloc (dimension, sizeof(int));
if ( tab==NULL) { ...traitement des erreurs... };
free(tab);
\end{lstlisting}

\begin{block}{}
En C++ moderne, on utilisera plutôt les objets de la stl !
\end{block}
\end{frame}

\end{document}
  
